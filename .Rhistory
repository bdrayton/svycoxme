weighted_exp_risk_score = exp_risk_score,
S2 = at_risk_X_X,
X = X)
}
coxfit <- survival::coxph(survival::Surv(stat_time, stat) ~ X1, data = my_samp,  weight = my_samp$weight)
parts <- BB(survival::Surv(stat_time, stat) ~ X1, data = my_samp, beta = coef(coxfit), weight = my_samp$weight)
parts <- BB(survival::Surv(stat_time, stat) ~ X1, data = my_samp, beta = coef(coxfit), weight = my_samp$weight)
with(parts, {
S0 * X * exp_risk_score - S1 * exp_risk_score
})
# take the parts and calculate d2
dU <- function(parts){
t1 <- with(parts,{
-stat * (S2 / S0 - (S1 * S1) / (S0 * S0))
})
t2 <- with(parts, {
-cumsum(stat * weight * (S0 * X * exp_risk_score - S1 * exp_risk_score) / (S0 * S0)) * (X - S1/S0)/N_hat
})
t3 <- with(parts, {
- cumsum(stat * weighted_exp_risk_score / S0) * ( (S1 * S1) / (S0 * S0) - S2 / S0 )/N_hat
})
data.frame(t1, t2, t3)
}
dU(parts)
lapply(parts, class)
# take the parts and calculate d2
dU <- function(parts){
t1 <- with(parts,{
-stat * (S2 / S0 - (S1 * S1) / (S0 * S0))
})
t2 <- with(parts, {
-cumsum(stat * weight * (S0 * X * exp_risk_score - S1 * exp_risk_score) / (S0 * S0)) * (X - S1/S0)/N_hat
})
t3 <- with(parts, {
- cumsum(stat * weighted_exp_risk_score / S0) * ( (S1 * S1) / (S0 * S0) - S2 / S0 )/N_hat
})
list(t1, t2, t3)
}
dU(parts)
# take the parts and calculate d2
dU <- function(parts){
t1 <- with(parts,{
-stat * (S2 / S0 - (S1 * S1) / (S0 * S0))
})
t2 <- with(parts, {
-cumsum(stat * weight * (S0 * X * exp_risk_score - S1 * exp_risk_score) / (S0 * S0)) * (X - S1/S0)/N_hat
})
t3 <- with(parts, {
- cumsum(stat * weighted_exp_risk_score / S0) * ( (S1 * S1) / (S0 * S0) - S2 / S0 )/N_hat
})
t1 + t2 + t3
}
dU(parts)
sum(dU(parts))
BB <- function(formula, weight = NULL, data, beta){
model_frame <- model.frame(formula, data = data)
# first column (response) is actually a (masked) matrix with time and status.
response <- as.matrix(model_frame[ ,1])
time <- response[,"time"]
stat <- response[,"status"]
# sort data by time
time_order <- order(time)
stat <- stat[time_order]
weight <- weight[time_order]
model_frame <- model_frame[time_order, ]
model_matrix <- model.matrix(formula, data = model_frame)
# calculate the weighted risk sets.
# get X terms
X <- model_matrix[,-1, drop = FALSE]
# this should fail if beta and X don't match dimensions
# I need these to be Matrix::Matrix
risk_score <- Matrix::Matrix(X %*% beta)
# weighted.
exp_risk_score <- weight * exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
# this is S0_hat in binder
at_risk <- Matrix::Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
# this is S1_hat
exp_risk_score_X <- exp_risk_score * X
at_risk_X <- fast_risk_sets(exp_risk_score_X)
at_risk_X_X <- fast_risk_sets(exp_risk_score_X * X)
list(stat = stat,
weight = weight,
S0 = at_risk,
S1 = at_risk_X,
exp_risk_score = exp(risk_score),
weighted_exp_risk_score = exp_risk_score,
S2 = at_risk_X_X,
X = X)
}
coxfit <- survival::coxph(survival::Surv(stat_time, stat) ~ X1, data = my_samp,  weight = my_samp$weight)
# make this way smaller.
cluster_str <- data.frame(table(Size = rpois(2500, 2) + 6)) |>
dplyr::filter(Freq >=10)
cluster_str_list <- split(cluster_str, seq(nrow(cluster_str)))
max_cluster_digits <- max(nchar(as.character(cluster_str$Size)))
max_cluster_freq_digits <- max(nchar(as.character(cluster_str$Freq)))
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits, flag = "0")
nk_id <- formatC(nk, width = max_cluster_digits, flag = "0")
the_data <- one_dataset(~X1 + (1 | M1),
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(1),
random_effect_variance = list(M1 = 0)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M1, sep = "_" ))
})
devtools::load_all(".")
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits, flag = "0")
nk_id <- formatC(nk, width = max_cluster_digits, flag = "0")
the_data <- one_dataset(~X1 + (1 | M1),
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(1),
random_effect_variance = list(M1 = 0)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M1, sep = "_" ))
})
pop <- Reduce(rbind.data.frame, pop_list)
# weights
n_clusters <- dplyr::n_distinct(pop$id)
n_clusters_in_samp <- 50
# sample data
samp_cluster_ids <- unique(pop$id)[sample.int(n_clusters, n_clusters_in_samp)]
my_samp <- pop[pop$id %in% samp_cluster_ids, ]
my_samp$weight <- (n_clusters_in_samp/n_clusters)^-1
library(survey)
my_des <- svydesign(~id, weights = ~weight, data = my_samp)
svycox <- svycoxph(survival::Surv(stat_time, stat) ~ X1, design = my_des)
# target for variance
summary(svycox)
beta <- Matrix(coef(svycox))
beta
model_frame <- model.frame(svycox)
# sort by fail time
fail_time <- Matrix(as.matrix(model_frame[,1])[,"time"], ncol = 1)
model_frame <- model_frame[order(fail_time), ]
X <- model_frame[, "X1", drop = FALSE] |> as.matrix()
stat <- Matrix(as.matrix(model_frame[,1])[,"status"], ncol = 1)
weight <- my_samp$weight[order(fail_time)]
risk_score <- X %*% beta
exp_risk_score <- weight * exp(risk_score)
dim(risk_score)
#Q0_beta = Q0_b
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix::Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
Q0_beta <- at_risk
# Q1_beta
exp_risk_score_X <- exp_risk_score * X
at_risk_X <- fast_risk_sets(exp_risk_score_X)
Q1_beta <- at_risk_X
dim(Q0_beta)
dim(Q1_beta)
A <- X - Q1_beta / Q0_beta
N_hat <- sum(weights(my_des))
# the first part of this middle term is a cumulative hazard of sorts. the second is gradient.
B <- cumsum((stat * exp_risk_score) / Q0_beta)/N_hat
U_i <- stat * A - B * A
my_des$variables$U_i <- U_i@x
svytotal(~U_i, design = my_des)
var_est <- vcov(svytotal(~U_i, design = my_des))
sqrt(var_est)
BB <- function(formula, weight = NULL, data, beta){
model_frame <- model.frame(formula, data = data)
# first column (response) is actually a (masked) matrix with time and status.
response <- as.matrix(model_frame[ ,1])
time <- response[,"time"]
stat <- response[,"status"]
# sort data by time
time_order <- order(time)
stat <- stat[time_order]
weight <- weight[time_order]
model_frame <- model_frame[time_order, ]
model_matrix <- model.matrix(formula, data = model_frame)
# calculate the weighted risk sets.
# get X terms
X <- model_matrix[,-1, drop = FALSE]
# this should fail if beta and X don't match dimensions
# I need these to be Matrix::Matrix
risk_score <- Matrix::Matrix(X %*% beta)
# weighted.
exp_risk_score <- weight * exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
# this is S0_hat in binder
at_risk <- Matrix::Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
# this is S1_hat
exp_risk_score_X <- exp_risk_score * X
at_risk_X <- fast_risk_sets(exp_risk_score_X)
at_risk_X_X <- fast_risk_sets(exp_risk_score_X * X)
list(stat = stat,
weight = weight,
S0 = at_risk,
S1 = at_risk_X,
exp_risk_score = exp(risk_score),
weighted_exp_risk_score = exp_risk_score,
S2 = at_risk_X_X,
X = X)
}
coxfit <- survival::coxph(survival::Surv(stat_time, stat) ~ X1, data = my_samp,  weight = my_samp$weight)
U4 <- resid(coxfit, "dfbeta")
parts <- BB(survival::Surv(stat_time, stat) ~ X1, data = my_samp, beta = coef(coxfit), weight = my_samp$weight)
# these are U_i s from binder
U_i <- with(parts, {
weight * stat * (X - S1/S0)
})
N_hat <- sum(parts$weight)
# another version, from lin
U_i_2 <- with(parts, {
stat * (X - S1/S0) - cumsum(stat * weighted_exp_risk_score / S0) * (X - S1/S0)/N_hat
})
my_samp_sorted <- sortAndIndex(my_samp, "stat_time")
my_des <- svydesign(~id, weights = ~weight, data = my_samp_sorted)
my_des$variables$U_i <- U_i_2[, 1]
V_svy <- vcov(svytotal(~U_i, design = my_des))
svymean(~U_i, design = my_des)
svytotal(~U_i, design = my_des)
# linearly dependent, but one looks kind of standardised.
plot(U_i, U_i_2)
svyfit <- svycoxph(survival::Surv(stat_time, stat) ~ X1, design = my_des)
U3 <- resid(svyfit, type = "dfbeta")
plot(density(U3))
plot(U3, U_i, col = parts$stat + 1)
plot(U3, U_i_2, col = parts$stat + 1)
plot(U3, U_i, col = parts$stat + 1, ylab = "dfbeta", xlab = "Binder U_i")
devtools::load_all(".")
devtools::load_all(".")
install.packages("roxygen2")
devtools::load_all(".")
svycoxme::calc_ui
lme4:::getFixedFormula()
lme4:::getFixedFormula
lme4:::RHSForm
reformulate
?reformulate
Sys.getenv("USERNAME")
file.path("C:/Users/",username,"/Documents/PhD_local/svycoxme")
username <- Sys.getenv("USERNAME")
file.path("C:/Users/",username,"/Documents/PhD_local/svycoxme")
# allows for switching between Bradley and bdra011. Could extend to work with any
# computer.
username <- Sys.getenv("USERNAME")
devtools::load_all(file.path("C:/Users", username,"Documents/PhD_local/svycoxme"))
devtools::load_all(file.path("C:/Users", username,"Documents/PhD_local/svycoxme"))
Sys.getenv()
Sys.getenv("OneDrive")
devtools::load_all(file.path(Sys.getenv("OneDrive"),"Documents/PhD_local/svycoxme"))
cluster_str <- data.frame(table(Size = rpois(2500, 2) + 6)) |>
dplyr::filter(Freq >=10)
cluster_str_list <- split(cluster_str, seq(nrow(cluster_str)))
max_cluster_digits <- max(nchar(as.character(cluster_str$Size)))
max_cluster_freq_digits <- max(nchar(as.character(cluster_str$Freq)))
set.seed(949742)
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits, flag = "0")
nk_id <- formatC(nk, width = max_cluster_digits, flag = "0")
the_data <- one_dataset(~X1 + X2 + (1 | M1),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(X1 = 1, X2 = 1),
random_effect_variance = list(M1 = 0)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M1, sep = "_" ))
})
pop <- Reduce(rbind.data.frame, pop_list)
# simple random sample
my_samp <- pop[sample.int(nrow(pop), 500),]
# sort samp by time.
my_samp <- my_samp[order(my_samp$stat_time),]
my_samp$weights = nrow(pop)/500
N_hat <- sum(my_samp$weights)
coxfit_weighted <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2, data = my_samp, weights = weights)
coxfit_unweighted <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2, data = my_samp)
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits, flag = "0")
nk_id <- formatC(nk, width = max_cluster_digits, flag = "0")
the_data <- one_dataset(~X1 + X2 + (1 | M1),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(X1 = 1, X2 = 1),
random_effect_variance = list(M1 = 1)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M1, sep = "_" ))
})
pop <- Reduce(rbind.data.frame, pop_list)
#
# # weights
n_clusters <- dplyr::n_distinct(pop$id)
n_clusters
n_clusters_in_samp <- 50
# sample data
samp_cluster_ids <- unique(pop$id)[sample.int(n_clusters, n_clusters_in_samp)]
my_samp <- pop[pop$id %in% samp_cluster_ids, ]
my_samp$weight <- (n_clusters_in_samp/n_clusters)^-1
my_samp$weight
N_hat <- sum(my_samp$weights)
N_hat
N_hat <- sum(my_samp$weight)
N_hat
coxfit_weighted <- coxme::coxme(survival::Surv(stat_time, stat) ~ X1 + X2 + (1 | M1), data = my_samp, weights = weights)
coxfit_weighted <- coxme::coxme(survival::Surv(stat_time, stat) ~ X1 + X2 + (1 | M1), data = my_samp, weights = weight)
make_parts(coxfit_weighted, data = my_samp)
parts <- make_parts(coxfit_weighted, data = my_samp)
Di <- make_Di(parts)
names(parts)
names(parts)
temp <- t(parts$S1_X) %*% parts$S1_Z
dim(temp)
dim(S1_Z)
dim(parts$S1_Z)
coxfit_weighted <- coxme::coxme(survival::Surv(stat_time, stat) ~ X1 + X2 + (1 | id), data = my_samp, weights = weight)
parts <- make_parts(coxfit_weighted, data = my_samp)
temp <- t(parts$S1_X) %*% parts$S1_Z
dim(parts$S1_Z)
dim(temp)
dim(temp)
temp2 <- Matrix::tcrossprod(parts$S1_X, parts$S1_Z)
temp2 <- Matrix::crossprod(parts$S1_X, parts$S1_Z)
dim(temp)
microbenchmark::microbenchmark(
t(parts$S1_X) %*% parts$S1_Z,
Matrix::crossprod(parts$S1_X, parts$S1_Z),
with(parts, t(S1_X) %*% S1_Z),
with(Matrix::crossprod(S1_X, S1_Z)),
)
microbenchmark::microbenchmark(
t(parts$S1_X) %*% parts$S1_Z,
Matrix::crossprod(parts$S1_X, parts$S1_Z),
with(parts, t(S1_X) %*% S1_Z),
with(parts, Matrix::crossprod(S1_X, S1_Z)),
)
microbenchmark::microbenchmark(
t(parts$S1_X) %*% parts$S1_Z,
Matrix::crossprod(parts$S1_X, parts$S1_Z),
with(parts, t(S1_X) %*% S1_Z),
with(parts, Matrix::crossprod(S1_X, S1_Z))
)
microbenchmark::microbenchmark(
t(parts$S1_X) %*% parts$S1_Z,
Matrix::crossprod(parts$S1_X, parts$S1_Z),
with(parts, t(S1_X) %*% S1_Z),
with(parts, Matrix::crossprod(S1_X, S1_Z))
)
Matrix::crossprod(parts$S1_X, parts$S1_Z),
dim(parts$S2_XtZ)
dim(temp2)
dim(parts$S2_XtZ)
dim(parts$S2_XtX)
parts$S1_X[1, ]
parts$S1_X[1, , drop = FALSE]
t(parts$S1_X[1, , drop = FALSE])
t(parts$S1_X[1, , drop = FALSE]) %*% parts$S1_Z[1,, drop = FALSE]
t(parts$S1_X[1, , drop = FALSE]) %*% parts$S1_Z[1,, drop = FALSE]
mapply(function(m1, m2){
Matrix(m1) %*% Matrix(m2, nrow = 1)
},
m1 = parts$S1_X,
m2 = parts$S1_Z)
mapply(function(m1, m2){
Matrix(m1) %*% Matrix(m2, nrow = 1)
},
m1 = matrix(parts$S1_X),
m2 = matrix(parts$S1_Z))
first_rows <- t(parts$S1_X[1, , drop = FALSE]) %*% parts$S1_Z[1,, drop = FALSE]
dim(first_rows)
parts$S1_X[1, , drop = FALSE])
parts$S1_X[1, , drop = FALSE]
parts$S1_Z[1,, drop = FALSE]
m1 <- t(parts$S1_X[1, , drop = FALSE])
m2 <- parts$S1_Z[1,, drop = FALSE]
m1
m2
m1 <- t(parts$S1_X[1, , drop = TRUE])
m2 <- parts$S1_Z[1,, drop = TRUE]
m1
m2
source("~/.active-rstudio-document", echo=TRUE)
class(m1)
Matrix(m1) %*% Matrix(m2, nrow = 1)
Matrix(m1)
m1 <- parts$S1_X[1, , drop = TRUE]
m1
Matrix(m1)
m1 <- parts$S1_X[1, , drop = TRUE]
m2 <- parts$S1_Z[1,, drop = TRUE]
class(m1)
Matrix(m1) %*% Matrix(m2, nrow = 1)
dim(parts$S1_X)
dim(matrix(parts$S1_X))
dim(as.matrix(parts$S1_X))
res <- mapply(function(m1, m2){
Matrix(m1) %*% Matrix(m2, nrow = 1)
},
m1 = as.matrix(parts$S1_X),
m2 = as.matrix(parts$S1_Z))
res <- mapply(function(m1, m2){
Matrix(m1) %*% Matrix(m2, nrow = 1)
},
m1 = as.matrix(parts$S1_X),
m2 = as.matrix(parts$S1_Z), SIMPLIFY = "matrix")
dim(res)
length(res)
length(parts$stat)
dim(as.matrix(parts$S1_X))
trow <- function(m1, m2){
m <- Matrix(m1) %*% Matrix(m2, nrow = 1)
}
trow <- function(m1, m2){
m <- Matrix(m1) %*% Matrix(m2, nrow = 1)
m
}
res <- array(NA, dim = c(2, 50, 391))
res <- array(NA, dim = c(2, 50, 391))
for (i in seq(391)) {
res[,,i] <- t(parts$S1_X[i, , drop = FALSE]) %*% parts$S1_Z[i,, drop = FALSE]
}
test <- Matrix(1:4, nrow = 2)
test
test$x
test@x
dim(test) <- c(1,8)
dim(test) <- c(1,4)
test
# column major
(test <- Matrix(1:4, nrow = 2))
test@x
nrow(test) <- 1
first_rows <- t(parts$S1_X[1, , drop = FALSE]) %*% parts$S1_Z[1,, drop = FALSE]
Matrix::tcrossprod(parts$S1_X[1, , drop = FALSE], parts$S1_Z[1, , drop = FALSE])
Matrix::crossprod(parts$S1_X[1, , drop = FALSE], parts$S1_Z[1, , drop = FALSE])
frow <- Matrix::crossprod(parts$S1_X[1, , drop = FALSE], parts$S1_Z[1, , drop = FALSE])
identical(first_rows, frow)
all_rows <- mapply(crossprod, split(parts$S1_X, row(parts$S1_X)), split(parts$S1_Z, row(parts$S1_Z)))
all_rows <- mapply(Matrix::tcrossprod, split(parts$S1_X, row(parts$S1_X)), split(parts$S1_Z, row(parts$S1_Z)))
all_rows[1, ]
dim(allrow)
dim(all_row)
dim(all_rows)
all_rows[, 1]
first_rows
parts$S0
ncol(parts$S2_XtZ)
S0TS0 <- matrix(apply(parts$S0, 1, tcrossprod), nrow = ncol(parts$S2_XtZ))
apply(parts$S0, 1, tcrossprod)
tcrossprod(parts$S0[1])
dim(parts$S2_XtZ)
all_rows <- t(mapply(Matrix::tcrossprod, split(parts$S1_X, row(parts$S1_X)), split(parts$S1_Z, row(parts$S1_Z))))
dim(all_rows)
S0TS0 <- matrix(rep(apply(parts$S0, 1, tcrossprod), 100), nrow = ncol(parts$S2_XtZ))
dim(S0TS0)
S0TS0 <- matrix(rep(apply(parts$S0, 1, tcrossprod), 100), nrow = nrow(parts$S2_XtZ))
S0TS0
dim(S0TS0)
dim(parts$S2_XtZ)
dim(all_rows)
S0TS0 <- Matrix(rep(apply(parts$S0, 1, tcrossprod), 100), nrow = nrow(parts$S2_XtZ))
dim(S0TS0)
dim(parts$S2_XtZ)
dim(all_rows)
class(S0TS0)
class(parts$S2_XtZ)
class(all_rows)
all_rows <- t(mapply(Matrix::tcrossprod, split(parts$S1_X, row(parts$S1_X)), split(parts$S1_Z, row(parts$S1_Z)))) |> Matrix()
class(S0TS0)
class(parts$S2_XtZ)
class(all_rows)
dim(S0TS0)
dim(parts$S2_XtZ)
dim(all_rows)
S0TS0[, 1]
S0TS0[1, ]
all_rows/S0TS0
parts$S0
dim(S0TS0)
rep(parts$S0, 100)
Matrix(rep(parts$S0, 100), nrow = length(parts$S0))
S0rep <- Matrix(rep(parts$S0, 100), nrow = length(parts$S0))
parts$S2_XtZ
all_rows/S0TS0 - parts$S2_XtZ/S0rep
parts$weights
parts$stat
Matrix(parts$stat) * Matrix(parts$weights) *  (all_rows/S0TS0 - parts$S2_XtZ/S0rep)
