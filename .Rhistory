<<<<<<< Updated upstream
strat4 == 2 ~ n/160,
strat4 == 3 ~ n/120,
TRUE ~ 1))
nwts_join <- dplyr::left_join(nwts, select(s_counts, strata, strat4, weight)) |>
dplyr::mutate(id = dplyr::row_number())
nwts_join <- dplyr::left_join(nwts, dplyr::select(s_counts, strata, strat4, weight)) |>
dplyr::mutate(id = dplyr::row_number())
nwts_pop <- dplyr::select(nwts_join, instit, age_bin, stage, relaps,
trel, id, histol, weight, strat4, tumdiam)
# draw the complex sample.
nwts_samp <- dplyr::bind_rows(
dplyr::filter(nwts_pop, strat4 == 1) |>
dplyr::slice_sample(n = 120),
dplyr::filter(nwts_pop, strat4 == 2) |>
dplyr::slice_sample(n = 160),
dplyr::filter(nwts_pop, strat4 == 3) |>
dplyr::slice_sample(n = 120),
dplyr::filter(nwts_pop, strat4 == 4))
nwts_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_samp)
m0 <- svycoxph(Surv(trel, relaps) ~ instit + age_bin + stage*tumdiam, design = nwts_design)
pop_totals <- colSums(model.matrix(~ relaps + instit + age_bin + stage, data = nwts_pop))
pop_totals
pop_totals <- colSums(model.matrix(~ relaps + instit + age_bin + stage*tumdiam, data = nwts_pop))
pop_totals
cal_form <- ~ relaps + instit + age_bin + stage*tumdiam
pop_totals <- colSums(model.matrix(cal_form, data = nwts_pop))
# calibrate the weights using pop totals
var_cal <- calibrate(nwts_design, formula = cal_form,
pop=pop_totals, bounds = c(0.1, 10))
# fit a model using the calibrated design
m1 <- svycoxph(Surv(trel, relaps) ~ instit + age_bin + stage*tumdiam, design = var_cal)
popmodel <- coxph(Surv(trel, relaps) ~ instit + age_bin + stage*tumdiam,
data = nwts_pop, na.action = na.exclude())
popmodel <- coxph(Surv(trel, relaps) ~ instit + age_bin + stage*tumdiam,
data = nwts_pop, na.action = na.exclude)
# extract the dfbetas from this pop-level fit.
inffun <- dfbeta(popmodel)
# extract the dfbetas from this pop-level fit.
inffun <- resid(popmodel, "dfbeta")
# add the influence functions to the design
index <- match(nwts_samp$id, nwts_pop$id)
names(inffun)
colnames(inffun)
ncol(inffun)
names(pop_totals)
nwts_design_if <- update(nwts_design,
if1 = inffun[index, 1],
if2 = inffun[index, 2],
if3 = inffun[index, 3],
if4 = inffun[index, 4],
if5 = inffun[index, 5],
if6 = inffun[index, 6],
if7 = inffun[index, 7])
# extract the dfbetas from this pop-level fit.
inffun <- resid(popmodel, "dfbeta")
# add the influence functions to the design
index <- match(nwts_samp$id, nwts_pop$id)
nwts_design_if <- update(nwts_design,
if1 = inffun[index, 1],
if2 = inffun[index, 2],
if3 = inffun[index, 3],
if4 = inffun[index, 4],
if5 = inffun[index, 5],
if6 = inffun[index, 6],
if7 = inffun[index, 7])
ncol(inffun)
nwts_design_if <- update(nwts_design,
if1 = inffun[index, 1],
if2 = inffun[index, 2],
if3 = inffun[index, 3],
if4 = inffun[index, 4],
if5 = inffun[index, 5])
names(coef(popmodel))
# calibrate using the influence functions
if_cal <- calibrate(nwts_design_if,
formula = ~if1 + if2 + if3 + if4 + if5,
pop = c(pop_totals[1], if1 = 0, if2 = 0, if3 = 0, if4 = 0, if5 = 0))
# fit a model using the IF calibrated design
m2 <- svycoxph(Surv(trel, relaps) ~ instit + age_bin + stage*tumdiam, design = if_cal)
# Uncalibrated design
(m0_summary <- coef(summary(m0)))
# Calibrated with population variables
(m1_summary <- coef(summary(m1)))
# Calibrated with population influence functions
(m2_summary <- coef(summary(m2)))
str(m2_summary)
std_err <- Reduce(cbind, lapply(list(m0_summary, m1_summary, m2_summary), function(df) df[, "robust se"]))
# factor of reduction
round(matrix(std_err[ , 1], nr = 4, nc = 3) / std_err , 1)
std_err[ , 1]
# factor of reduction
round(matrix(std_err[ , 1], nr = 5, nc = 3) / std_err , 1)
# factor of reduction
round(matrix(std_err[ , 1], nr = 5, nc = 3) / std_err , 2)
m1_summary
m2_summary
m0_summary
# calibrate the weights using pop totals
var_cal <- calibrate(nwts_design, formula = cal_form,
pop=pop_totals) # dropped , bounds = c(0.1, 10)
# fit a model using the calibrated design
m1 <- svycoxph(Surv(trel, relaps) ~ instit + age_bin + stage*tumdiam, design = var_cal)
# Calibrated with population variables
(m1_summary <- coef(summary(m1)))
std_err <- Reduce(cbind, lapply(list(m0_summary, m1_summary, m2_summary), function(df) df[, "robust se"]))
# factor of reduction
round(matrix(std_err[ , 1], nr = 5, nc = 3) / std_err , 2)
# also consider
# data(nwts2ph, package = "addhazard")
data(nwtsco, package = "addhazard")
nwts <- nwtsco
names(nwts)
table(nwts$age>10)
table(nwts$age>1)
# also consider
# data(nwts2ph, package = "addhazard")
data(nwtsco, package = "addhazard")
nwts <- nwtsco
nwts <- nwtsco
# set up strata
nwts <- nwts |>
dplyr::mutate(instit = factor(instit, c(0, 1), labels = c("FH", "UH")),
stage4 = stage == 4,
stage = factor(stage, levels = 1:4,
labels = c("I-II", "I-II",
"III-IV", "III-IV")),
age_bin = factor(0 + age<1,
labels = c("<1Yr", ">=1Yrs")),
strata =interaction(instit, stage, age_bin, relaps))
table(nwts$stage4)
## collapse smallest 13 strata together.
s_counts <- nwts |>
dplyr::count(strata) |>
dplyr::arrange(desc(n)) |>
dplyr::mutate(rank = dplyr::row_number()) |>
dplyr::mutate(strat4 = dplyr::if_else(rank <= 3, rank, 4L)) |>
dplyr::group_by(strat4) |>
dplyr::mutate(weight = dplyr::case_when(strat4 == 1 ~ n/120,
strat4 == 2 ~ n/160,
strat4 == 3 ~ n/120,
TRUE ~ 1))
nwts_join <- dplyr::left_join(nwts, dplyr::select(s_counts, strata, strat4, weight)) |>
dplyr::mutate(id = dplyr::row_number())
nwts_pop <- nwts_join
# draw the complex sample.
nwts_samp <- dplyr::bind_rows(
dplyr::filter(nwts_pop, strat4 == 1) |>
dplyr::slice_sample(n = 120),
dplyr::filter(nwts_pop, strat4 == 2) |>
dplyr::slice_sample(n = 160),
dplyr::filter(nwts_pop, strat4 == 3) |>
dplyr::slice_sample(n = 120),
dplyr::filter(nwts_pop, strat4 == 4))
nwts_pop$in.subsample <- ntws_pop$id %in% ntws_samp$id
nwts_pop$in.subsample <- nwts_pop$id %in% nwts_samp$id
impmodel <- glm(histol~instit + age_bin + stage4*study, data = nwts_pop, subset = in.subsample, family = binomial )
nwts_pop$imphist <- predict(impmodel, newdata = nwts_pop, type = "response")
# replace predicted histology with actual histology where available (i.e. sampled children)
nwts_pop$imphist[nwts_pop$in.subsample] <- nwts$histol[nwts_pop$in.subsample]
# fit a model to the population data supplemented with the imputed histology
ifmodel <- coxph(Surv(trel, relaps) ~ imphist * age + stage * tumdiam, data = nwts_pop)
inffun <- resid(ifmodel, "dfbeta")
colnames(inffun) <- paste0("if", seq(ncol(inffun)))
colnames(inffun)
nwts_pop_if <- cbind(nwts_pop, inffun)
if_cal <- calibrate(if_design, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4)
# design with pop data
if_design <- twophase(id = list(~1, ~1), subset = ~in.subsample,
strata = list(NULL, ~strat4), data = nwts_pop_if)
if_cal <- calibrate(if_design, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4)
if_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_pop_if, subset = ~in.subsample)
if_cal <- calibrate(if_design, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4)
pop_totals <- colSums(~ if1 + if2 + if3 + if4 + if5 + strat4, data = nwts_pop_if)
pop_totals <- colSums(model.matrix(~ if1 + if2 + if3 + if4 + if5 + strat4,
data = nwts_pop_if))
pop_totals
if_cal <- calibrate(if_design, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4,
population = pop_totals)
# design with sample data. same as if_design
nwts_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_samp)
m0 <- svycoxph(Surv(trel, relaps) ~ instit + age_bin + stage*tumdiam, design = if_design)
cal_form <- ~ imphist * age + stage * tumdiam
pop_totals <- colSums(model.matrix(cal_form, data = nwts_pop))
# calibrate the weights using pop totals
var_cal <- calibrate(if_design, formula = cal_form,
pop=pop_totals) # dropped , bounds = c(0.1, 10)
# fit a model using the calibrated design
m1 <- svycoxph(Surv(trel, relaps) ~ histol + age_bin + stage*tumdiam, design = var_cal)
m1a <- svycoxph(Surv(trel, relaps) ~ histol + age_bin + stage*tumdiam, design = if_cal)
# fit the same model to the population
popmodel <- coxph(Surv(trel, relaps) ~ instit + age_bin + stage*tumdiam,
data = nwts_pop, na.action = na.exclude)
# Uncalibrated design
(m0_summary <- coef(summary(m0)))
if_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_pop_if, subset = ~in.subsample)
pop_totals <- colSums(model.matrix(~ if1 + if2 + if3 + if4 + if5 + strat4,
data = nwts_pop_if))
if_cal <- calibrate(if_design, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4,
population = pop_totals)
# design with sample data. same as if_design
nwts_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_samp)
# fit a model using the uncalibrated design
m0 <- svycoxph(Surv(trel, relaps) ~  histol * age + stage * tumdiam, design = if_design)
cal_form <- ~ imphist * age + stage * tumdiam
pop_totals <- colSums(model.matrix(cal_form, data = nwts_pop))
# calibrate the weights using pop totals
var_cal <- calibrate(if_design, formula = cal_form,
pop=pop_totals) # dropped , bounds = c(0.1, 10)
# fit a model using the variable calibrated design
m1 <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = var_cal)
# fit a model using the influence function calibrated design with imputation
m1a <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = if_cal)
nwts_pop_if <- cbind(nwts_pop, inffun)
if_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_pop_if, subset = ~in.subsample)
pop_totals <- colSums(model.matrix(~ if1 + if2 + if3 + if4 + if5 + strat4,
data = nwts_pop_if))
if_cal <- calibrate(if_design, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4,
population = pop_totals)
# design with sample data. same as if_design
nwts_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_samp)
# fit a model using the uncalibrated design
m0 <- svycoxph(Surv(trel, relaps) ~  histol * age + stage * tumdiam, design = if_design)
cal_form <- ~ imphist * age + stage * tumdiam
pop_totals <- colSums(model.matrix(cal_form, data = nwts_pop))
# calibrate the weights using pop totals
var_cal <- calibrate(if_design, formula = cal_form,
pop=pop_totals) # dropped , bounds = c(0.1, 10)
# fit a model using the variable calibrated design
m1 <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = var_cal)
# fit a model using the influence function calibrated design with imputation
m1a <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = if_cal)
# Uncalibrated design
(m0_summary <- coef(summary(m0)))
# Calibrated with population variables
(m1_summary <- coef(summary(m1)))
# Calibrated with population influence functions using imputed data
(m1a_summary <- coef(summary(m1a)))
# regular cox regression on the population data
m2 <- coxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, data = nwts_pop_if)
m2_summary <- coef(summary(m2))
m2_summary
### influence function calibration without imputation (instit swapped for histol)
popmodel <- coxph(Surv(trel, relaps) ~ instit * age + stage * tumdiam,
data = nwts_pop, na.action = na.exclude)
# extract the dfbetas from this pop-level fit.
inffun <- resid(popmodel, "dfbeta")
# add the influence functions to the design
index <- match(nwts_samp$id, nwts_pop$id)
nwts_design_if <- update(nwts_design,
if1 = inffun[index, 1],
if2 = inffun[index, 2],
if3 = inffun[index, 3],
if4 = inffun[index, 4],
if5 = inffun[index, 5])
# calibrate using the influence functions
if_cal <- calibrate(nwts_design_if,
formula = ~if1 + if2 + if3 + if4 + if5,
pop = c(pop_totals[1], if1 = 0, if2 = 0, if3 = 0, if4 = 0, if5 = 0))
# fit a model using the IF calibrated design
m3 <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = if_cal)
m3_summary <- coef(summary(m3))
(m3_summary <- coef(summary(m3)))
m2_summary
m1a_summary
confint(m3)
confint(m2)
confint(m1a)
des <- svydesign(~1, probs = ~1, data = nwts_pop, fpc = nrow(nwts_pop))
nrow(nwts_pop)
des <- svydesign(~1, probs = ~1, data = nwts_pop)
des <- svydesign(~1, probs = ~1, data = nwts_pop, fpc = nrow(nwts_pop) + 1)
des <- svydesign(~1, probs = ~1, data = nwts_pop, fpc = nrow(nwts_pop) + 1000)
des <- svydesign(~1, probs = ~1, data = nwts_pop, strata = NULL, fpc = nrow(nwts_pop) + 1000)
des <- svydesign(~1, probs = ~1, data = nwts_pop, strata = ~1, fpc = nrow(nwts_pop) + 1000)
des <- svydesign(~1, probs = ~1, data = nwts_pop, strata = ~1, fpc = nrow(nwts_pop))
des <- svydesign(~1, probs = ~1, data = nwts_pop, strata = ~1, fpc = 1)
des <- svydesign(~1, probs = ~1, data = nwts_pop, fpc = 1)
des <- svydesign(~1, probs = ~1, data = nwts_pop, fpc = 0.9)
des <- svydesign(~1, weights = ~1, data = nwts_pop, fpc = 0.9)
des <- svydesign(~1, weights = ~1, data = nwts_pop, fpc = ~0.9)
des <- svydesign(~1, weights = ~1, data = nwts_pop, fpc = ~1)
des <- svydesign(~1, weights = ~1, data = nwts_pop, fpc = 1)
des <- svydesign(~1, weights = ~1, data = nwts_pop, fpc = 0.5)
des <- svydesign(~1, data = nwts_pop, fpc = 0.5)
des <- svydesign(~1, data = nwts_pop, fpc = 1)
des <- svydesign(~1, data = nwts_pop, fpc = 10000)
table(nwts_pop$strat4)
des <- svydesign(~1, strata = strat4, data = nwts_pop, fpc = table(nwts_pop$strat4))
strat_counts <- table(nwts_pop$strat4)
des <- svydesign(~1, strata = strat4, data = nwts_pop, fpc = strat_counts)
des <- svydesign(~1, strata = ~strat4, data = nwts_pop, fpc = strat_counts)
strat_counts <- table(nwts_pop$strat4)*2
des <- svydesign(~1, strata = ~strat4, data = nwts_pop, fpc = strat_counts)
colSums(model.frame(~strat4), data = nwts_pop)
colSums(model.frame(~strat4, data = nwts_pop)
=======
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, M2 = 2)
>>>>>>> Stashed changes
)
colSums(model.frame(~strat4, data = nwts_pop))
colSums(model.frame(~as.factor(strat4), data = nwts_pop))
model.frame(~factor(strat4), data = nwts_pop)
colSums(model.matrix(~factor(strat4), data = nwts_pop))
colSums(model.matrix(~strat4, data = nwts_pop))
colSums(model.matrix(~factor(strat4), data = nwts_pop))
des <- svydesign(~1, strata = ~strat4, data = nwts_pop, fpc = colSums(model.matrix(~factor(strat4), data = nwts_pop)))
des <- svydesign(~1, strata = ~factor(strat4), data = nwts_pop, fpc = colSums(model.matrix(~factor(strat4), data = nwts_pop)))
des <- svydesign(~1, strata = ~factor(strat4), data = nwts_pop)
des <- svydesign(~1, probs = 1, strata = ~factor(strat4), data = nwts_pop)
des <- svydesign(~1, probs = 1, strata = ~factor(strat4), data = nwts_pop, fpc = colSums(model.matrix(~factor(strat4), data = nwts_pop)))
des <- svydesign(~1, probs = 1, strata = ~factor(strat4), data = nwts_pop,
fpc = 2*colSums(model.matrix(~factor(strat4), data = nwts_pop)))
colSums(model.matrix(~factor(strat4), data = nwts_pop))
colSums(model.matrix(~factor(strat4), data = nwts_pop))/nrow(nwts_pop)
colSums(model.matrix(~factor(strat4)-1, data = nwts_pop))/nrow(nwts_pop)
fpc_counts <- colSums(model.matrix(~factor(strat4)-1, data = nwts_pop))/nrow(nwts_pop)
fpc_props <- colSums(model.matrix(~factor(strat4)-1, data = nwts_pop))/nrow(nwts_pop)
des <- svydesign(~1, probs = 1, strata = ~factor(strat4), data = nwts_pop,
fpc = unname(fpc_props))
fpc_props <- colSums(model.matrix(~factor(strat4)-1, data = nwts_pop))/nrow(nwts_pop)
des <- svydesign(~1, probs = 1, strata = ~factor(strat4), data = nwts_pop,
fpc = unname(fpc_props))
fpc_df <- data.frame(strata = 1:4, prop = fpc_props)
fpc_df <- data.frame(strata = 1:4, prop = 1)
nwts_pop_fpc <- dplyr::left_join(nwts_pop, fpc_df, by = "strata")
fpc_df <- data.frame(strata = factor(1:4), prop = 1)
nwts_pop_fpc <- dplyr::left_join(nwts_pop, fpc_df, by = "strata")
des <- svydesign(~1, probs = 1, strata = ~strat4, data = nwts_pop_fpc,
fpc = ~prop)
nwts_pop_fpc <- dplyr::left_join(nwts_pop, fpc_df, by = "strata")
View(nwts_pop_fpc)
fpc_df <- data.frame(strata = factor(1:4), prop = 1)
levels(nwts_pop$strat4)
nwts_pop_fpc <- dplyr::left_join(nwts_pop, fpc_df, by = "strat4")
fpc_df <- data.frame(strat4 = 1:4, prop = 1)
fpc_df
nwts_pop_fpc <- dplyr::left_join(nwts_pop, fpc_df, by = "strat4")
des <- svydesign(~1, probs = 1, strata = ~strat4, data = nwts_pop_fpc,
fpc = ~prop)
fpc_df <- data.frame(strat4 = 1:4, prop = 0.9)
nwts_pop_fpc <- dplyr::left_join(nwts_pop, fpc_df, by = "strat4")
des <- svydesign(~1, probs = 1, strata = ~strat4, data = nwts_pop_fpc,
fpc = ~prop)
fpc_df <- data.frame(strat4 = 1:4, prop = 0.99)
nwts_pop_fpc <- dplyr::left_join(nwts_pop, fpc_df, by = "strat4")
des <- svydesign(~1, probs = 1, strata = ~strat4, data = nwts_pop_fpc,
fpc = ~prop)
m4 <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = des)
confint(m4)
confint(m3)
confint(m2)
confint(m1a)
library(survey)
# also consider
# data(nwts2ph, package = "addhazard")
data(nwtsco, package = "addhazard")
nwts <- nwtsco
# set up strata
nwts <- nwts |>
dplyr::mutate(instit = factor(instit, c(0, 1), labels = c("FH", "UH")),
stage4 = stage == 4,
stage = factor(stage, levels = 1:4,
labels = c("I-II", "I-II",
"III-IV", "III-IV")),
age_bin = factor(0 + age<1,
labels = c("<1Yr", ">=1Yrs")),
strata =interaction(instit, stage, age_bin, relaps))
## collapse smallest 13 strata together.
s_counts <- nwts |>
dplyr::count(strata) |>
dplyr::arrange(desc(n)) |>
dplyr::mutate(rank = dplyr::row_number()) |>
dplyr::mutate(strat4 = dplyr::if_else(rank <= 3, rank, 4L)) |>
dplyr::group_by(strat4) |>
dplyr::mutate(weight = dplyr::case_when(strat4 == 1 ~ n/120,
strat4 == 2 ~ n/160,
strat4 == 3 ~ n/120,
TRUE ~ 1))
nwts_join <- dplyr::left_join(nwts, dplyr::select(s_counts, strata, strat4, weight)) |>
dplyr::mutate(id = dplyr::row_number())
nwts_pop <- nwts_join
# draw the complex sample.
nwts_samp <- dplyr::bind_rows(
dplyr::filter(nwts_pop, strat4 == 1) |>
dplyr::slice_sample(n = 120),
dplyr::filter(nwts_pop, strat4 == 2) |>
dplyr::slice_sample(n = 160),
dplyr::filter(nwts_pop, strat4 == 3) |>
dplyr::slice_sample(n = 120),
dplyr::filter(nwts_pop, strat4 == 4))
nwts_pop$in.subsample <- nwts_pop$id %in% nwts_samp$id
# fit imptation model
impmodel <- glm(histol~instit + age_bin + stage4*study, data = nwts_pop, subset = in.subsample, family = binomial )
# predict histology for everyone
nwts_pop$imphist <- predict(impmodel, newdata = nwts_pop, type = "response")
# replace predicted histology with actual histology where available (i.e. sampled children)
nwts_pop$imphist[nwts_pop$in.subsample] <- nwts$histol[nwts_pop$in.subsample]
# fit a model to the population data supplemented with the imputed histology
ifmodel <- coxph(Surv(trel, relaps) ~ imphist * age + stage * tumdiam, data = nwts_pop)
# append influence functions to the pop data
inffun <- resid(ifmodel, "dfbeta")
colnames(inffun) <- paste0("if", seq(ncol(inffun)))
nwts_pop_if <- cbind(nwts_pop, inffun)
if_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_pop_if, subset = ~in.subsample)
pop_totals <- colSums(model.matrix(~ if1 + if2 + if3 + if4 + if5 + strat4,
data = nwts_pop_if))
if_cal <- calibrate(if_design, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4,
population = pop_totals)
# design with sample data. same as if_design
nwts_design <- svydesign(~1, strata = ~strat4, weights = ~weight,
data = nwts_samp)
# fit a model using the uncalibrated design
m0 <- svycoxph(Surv(trel, relaps) ~  histol * age + stage * tumdiam, design = if_design)
cal_form <- ~ imphist * age + stage * tumdiam
pop_totals <- colSums(model.matrix(cal_form, data = nwts_pop))
# calibrate the weights using pop totals
var_cal <- calibrate(if_design, formula = cal_form,
pop=pop_totals) # dropped , bounds = c(0.1, 10)
# fit a model using the variable calibrated design
m1 <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = var_cal)
# fit a model using the influence function calibrated design with imputation
m1a <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = if_cal)
# regular cox regression on the population data
m2 <- coxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, data = nwts_pop_if)
# Uncalibrated design
(m0_summary <- coef(summary(m0)))
# Calibrated with population variables # really biased?
(m1_summary <- coef(summary(m1)))
# Calibrated with population influence functions using imputed data
(m1a_summary <- coef(summary(m1a)))
m2_summary <- coef(summary(m2))
### influence function calibration without imputation (instit swapped for histol)
popmodel <- coxph(Surv(trel, relaps) ~ instit * age + stage * tumdiam,
data = nwts_pop, na.action = na.exclude)
# extract the dfbetas from this pop-level fit.
inffun <- resid(popmodel, "dfbeta")
# add the influence functions to the design
index <- match(nwts_samp$id, nwts_pop$id)
nwts_design_if <- update(nwts_design,
if1 = inffun[index, 1],
if2 = inffun[index, 2],
if3 = inffun[index, 3],
if4 = inffun[index, 4],
if5 = inffun[index, 5])
# calibrate using the influence functions
if_cal <- calibrate(nwts_design_if,
formula = ~if1 + if2 + if3 + if4 + if5,
pop = c(pop_totals[1], if1 = 0, if2 = 0, if3 = 0, if4 = 0, if5 = 0))
# fit a model using the IF calibrated design
m3 <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = if_cal)
(m3_summary <- coef(summary(m3)))
m2_summary
m1a_summary
# the imputed CI is narrower than the population fit. FPC correction? the CI for coxph is wrong without it.
confint(m3)
confint(m2)
confint(m1a)
fpc_props <- colSums(model.matrix(~factor(strat4)-1, data = nwts_pop))/nrow(nwts_pop)
fpc_df <- data.frame(strat4 = 1:4, prop = 0.99)
nwts_pop_fpc <- dplyr::left_join(nwts_pop, fpc_df, by = "strat4")
des <- svydesign(~1, probs = 1, strata = ~strat4, data = nwts_pop_fpc,
fpc = ~prop)
m4 <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = des)
confint(m4)
confint(m3)
confint(m2)
confint(m1a)
# design with pop data
if_design_tp <- twophase(id = list(~1, ~1), subset = ~in.subsample,
strata = list(NULL, ~strat4), data = nwts_pop_if)
if_cal <- calibrate(if_design_tp, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4,
population = pop_totals)
if_cal <- calibrate(if_design_tp, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4)
if_cal_tp <- calibrate(if_design_tp, phase = 2, calfun = "raking",
formula = ~ if1 + if2 + if3 + if4 + if5 + strat4)
# same, but with the twophase design
m1a_tp <- svycoxph(Surv(trel, relaps) ~ histol * age + stage * tumdiam, design = if_cal_tp)
confint(m1a)
confint(m1a_tp)
usethis::edit_r_profile()
interactive()
if(interactive()) {
}
if(interactive()) {
invisible()
}
<<<<<<< Updated upstream
usethis::edit_r_profile()
library(coxme)
install.packages("coxme")
library(coxme)
vignette(package = "coxme")
vignette("variance", package = "coxme")
data(gexchange)
seq(from = 0, to = 10, by = 1)
log(seq(from = 0, to = 10, by = 1))
log(Inf)
log(1000000000000000000)
pmax(1000)
=======
as.character
as.factor
factor
class(test$M1.M2)
test4 <- test
test4$offset = 0
for(i in seq_along(res)){
re <- data.frame(new_offset = res[[i]])
re[,re_names[i]] <- as(rownames(re), Class = class(test4[,re_names[i]]))
test4 <- dplyr::left_join(test4, re, by = re_names[i])
test4$offset = test4$offset + test4$new_offset
test4$new_offset <- NULL
}
test4$M1.M2
for(i in seq_along(res)){
re <- data.frame(new_offset = res[[i]])
re_class <- class(test4[,re_names[i]])
if (re_class == "factor"){
re[,re_names[i]] <- factor(rownames(re))
} else {
re[,re_names[i]] <- as(rownames(re), Class = re_class)
}
test4 <- dplyr::left_join(test4, re, by = re_names[i])
test4$offset = test4$offset + test4$new_offset
test4$new_offset <- NULL
}
# the coxph with offset should estimate the same coefs as coxme with the random effects.
fit_test4 <- coxph(Surv(stat_time, stat) ~ X1 + X2 + X3 + offset(offset), data = test4)
# not the same! am i combining the offsets wrongly? Yes, you must be.
cbind(
coef(fit_test),
coef(fit_test4))
test <- one_dataset(~X1 + X2 + X3 + (1 | M1) + (1| M1:M2),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, `M1:M2` = 2)
)
test$`M1.M2` = with(test, interaction(M1, M2))
fit_test <- coxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1) + (1 | `M1.M2`), data = test)
test <- one_dataset(~X1 + X2 + X3 + (1 | M1) + (1| M1:M2),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, `M1:M2` = 2)
)
test$`M1.M2` = with(test, interaction(M1, M2))
fit_test <- coxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1) + (1 | `M1.M2`), data = test)
res <- ranef(fit_test)
re_names <- names(res)
test4 <- test
test4$offset = 0
for(i in seq_along(res)){
re <- data.frame(new_offset = res[[i]])
re_class <- class(test4[,re_names[i]])
if (re_class == "factor"){
re[,re_names[i]] <- factor(rownames(re))
} else {
re[,re_names[i]] <- as(rownames(re), Class = re_class)
}
test4 <- dplyr::left_join(test4, re, by = re_names[i])
test4$offset = test4$offset + test4$new_offset
test4$new_offset <- NULL
}
# the coxph with offset should estimate the same coefs as coxme with the random effects.
fit_test4 <- coxph(Surv(stat_time, stat) ~ X1 + X2 + X3 + offset(offset), data = test4)
# not the same! am i combining the offsets wrongly? Yes, you must be.
cbind(
coef(fit_test),
coef(fit_test4))
test <- one_dataset(~X1 + X2 + X3 + (1 | M1) + (1| M1/M2),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, `M1:M2` = 2)
)
test <- one_dataset(~X1 + X2 + X3 + (1 | M1) + (1| M1/M2),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, M2 = 0.5, `M1:M2` = 2)
)
test <- one_dataset(~X1 + X2 + X3 + (1 | M1) + (1| M1/M2),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, M2 = 0.5, `M2:M1` = 2)
)
test$`M2.M1` = with(test, interaction(M1, M2))
fit_test <- coxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1) + (1 | `M1.M2`), data = test)
fit_test <- coxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1) + (1 | M2.M1), data = test)
res <- ranef(fit_test)
re_names <- names(res)
re_names
fit_test <- coxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1) + (1 | M2) + (1 | M2.M1), data = test)
res <- ranef(fit_test)
re_names <- names(res)
test4 <- test
test4$offset = 0
for(i in seq_along(res)){
re <- data.frame(new_offset = res[[i]])
re_class <- class(test4[,re_names[i]])
if (re_class == "factor"){
re[,re_names[i]] <- factor(rownames(re))
} else {
re[,re_names[i]] <- as(rownames(re), Class = re_class)
}
test4 <- dplyr::left_join(test4, re, by = re_names[i])
test4$offset = test4$offset + test4$new_offset
test4$new_offset <- NULL
}
# the coxph with offset should estimate the same coefs as coxme with the random effects.
fit_test4 <- coxph(Surv(stat_time, stat) ~ X1 + X2 + X3 + offset(offset), data = test4)
# not the same! am i combining the offsets wrongly? Yes, you must be.
cbind(
coef(fit_test),
coef(fit_test4))
devtools::load_all(".")
the_data <- one_dataset(~X1 + X2 + X3 + (1 | M),
my_k <- 50
my_nk <- 10
my_coefficients <- c(1, -0.7, 0.5)
my_theta <- c(M = 1)
the_data <- one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)
dist_args = list(k = my_k, nk = my_nk,
n = k * nk),
coefficients = my_coefficients,
random_effect_variance = my_theta))
the_data <- one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n))
dist_args = list(k = my_k, nk = my_nk,
n = k * nk),
coefficients = my_coefficients,
random_effect_variance = my_theta)
the_data <- one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n))
dist_args = list(k = my_k, nk = my_nk,
n = k * nk),
coefficients = my_coefficients,
random_effect_variance = my_theta)
the_data <- one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n))
dist_args = list(k = my_k, nk = my_nk,
n = my_k * my_nk),
coefficients = my_coefficients,
random_effect_variance = my_theta)
the_data <- one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk,
n = my_k * my_nk),
coefficients = my_coefficients,
random_effect_variance = my_theta)
View(the_data)
coxme::coxme(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M), data = the_data)
coxme_fit <- coxme::coxme(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M), data = the_data)
coxme::VarCorr(coxme_fit)
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M1) + (1 | M2)
my_k = 50
my_nk = 10
my_theta = c(M1 = 2, M2 = 1)
my_beta = c(1, -0.7, 0.5)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = my_theta
)
coxme_fit <- coxme::coxme(my_formula, data = ds)
ests <- est_parameters(my_formula, ds, control = control.list(grad = FALSE))
my_ndeps = rep(0.001, length(my_theta))
ests <- est_parameters(my_formula, ds, control = control.list(grad = FALSE))
ests <- est_parameters(my_formula, ds, control = control.list(grad = FALSE, ndeps = my_ndeps))
ests_w_gr  <- est_parameters(my_formula, ds, control = control.list(grad = TRUE, ndeps = my_ndeps))
ests_w_gr
exp(0)
>>>>>>> Stashed changes
