hits = round(hits, 1)) %>%
kbl()
res %>%
filter(nk == 2) %>%
select(-k, -nk, -param_name) %>%
mutate(parameter = rep(c("$\\hat{\\beta}_1$", "$\\hat{\\beta}_2$", "$\\hat{\\beta}_3$", "$\\hat{\\theta}$"), 3),
.before = everything()) %>%
mutate(across(c("mean", "estimated_se", "empirical_se"), ~round(.x, 3)),
hits = round(hits, 1)) %>%
kbl(col.names = c("Parameter", "Correct value", "Mean", "Estimated SE", "Empirical SE", "Hits (%)"),
align = "cccccc")
res %>%
filter(nk == 2) %>%
select(-k, -nk, -param_name) %>%
mutate(parameter = rep(c("$\\hat{\\beta}_1$", "$\\hat{\\beta}_2$", "$\\hat{\\beta}_3$", "$\\hat{\\theta}$"), 3),
.before = everything()) %>%
mutate(across(c("mean", "estimated_se", "empirical_se"), ~round(.x, 3)),
hits = round(hits, 1)) %>%
kbl(col.names = c("Parameter", "Correct value", "Mean", "Estimated SE", "Empirical SE", "Hits (%)"),
align = "cccccc")
res %>%
filter(nk == 2) %>%
select(-k, -nk, -param_name) %>%
mutate(parameter = rep(c("$\\hat{\\beta}_1$", "$\\hat{\\beta}_2$", "$\\hat{\\beta}_3$", "$\\hat{\\theta}$"), 3),
.before = everything()) %>%
mutate(across(c("mean", "estimated_se", "empirical_se"), ~round(.x, 3)),
hits = round(hits, 1))
res %>%
filter(nk == 2) %>%
select(-k, -nk, -param_name, -theta) %>%
mutate(parameter = rep(c("$\\hat{\\beta}_1$", "$\\hat{\\beta}_2$", "$\\hat{\\beta}_3$", "$\\hat{\\theta}$"), 3),
.before = everything()) %>%
mutate(across(c("mean", "estimated_se", "empirical_se"), ~round(.x, 3)),
hits = round(hits, 1)) %>%
kbl(col.names = c("Parameter", "Correct value", "Mean", "Estimated SE", "Empirical SE", "Hits (%)"),
align = "cccccc")
res %>%
filter(nk == 2) %>%
select(-k, -nk, -param_name, -theta) %>%
mutate(parameter = rep(c("$\\hat{\\beta}_1$", "$\\hat{\\beta}_2$", "$\\hat{\\beta}_3$", "$\\hat{\\theta}$"), 3),
.before = everything()) %>%
mutate(across(c("mean", "estimated_se", "empirical_se"), ~round(.x, 3)),
hits = round(hits, 1)) %>%
kbl(col.names = c("Parameter", "Correct value", "Mean", "Estimated SE", "Empirical SE", "Hits (%)"),
align = "cccccc") %>%
kable_styling()
res %>%
filter(nk == 2) %>%
select(-k, -nk, -param_name, -theta) %>%
mutate(parameter = rep(c("$\\hat{\\beta}_1$", "$\\hat{\\beta}_2$", "$\\hat{\\beta}_3$", "$\\hat{\\theta}$"), 3),
.before = everything()) %>%
mutate(across(c("mean", "estimated_se", "empirical_se"), ~round(.x, 3)),
hits = round(hits, 1)) %>%
kbl(col.names = c("Parameter", "Correct value", "Mean", "Estimated SE", "Empirical SE", "Hits (%)"),
align = "cccccc") %>%
kable_classic_2(full_width = F)
res %>%
filter(nk == 2) %>%
select(-k, -nk, -param_name, -theta) %>%
mutate(parameter = rep(c("$\\hat{\\beta}_1$", "$\\hat{\\beta}_2$", "$\\hat{\\beta}_3$", "$\\hat{\\theta}$"), 3),
.before = everything()) %>%
mutate(across(c("mean", "estimated_se", "empirical_se"), ~round(.x, 3)),
hits = round(hits, 1)) %>%
kbl(col.names = c("Parameter", "Correct value", "Mean", "Estimated SE", "Empirical SE", "Hits (%)"),
align = "cccccc") %>%
kable_classic_2(full_width = F) %>%
pack_rows(index = c("$\\theta = 0.5$" = 4, "$\\theta = 1$" = 4, "$\\theta = 2$" = 4))
res %>%
filter(nk == 2) %>%
select(-k, -nk, -param_name, -theta) %>%
mutate(parameter = rep(c("$\\hat{\\beta}_1$", "$\\hat{\\beta}_2$", "$\\hat{\\beta}_3$", "$\\hat{\\theta}$"), 3),
.before = everything()) %>%
mutate(across(c("mean", "estimated_se", "empirical_se"), ~round(.x, 3)),
hits = round(hits, 1)) %>%
kbl(col.names = c("Parameter", "Correct value", "Mean", "Estimated SE", "Empirical SE", "Hits (%)"),
align = "cccccc") %>%
kable_classic_2(full_width = F) %>%
pack_rows(index = c("$\\theta = 0.5$" = 4, "$\\theta = 1$" = 4, "$\\theta = 2$" = 4), latex_align = "c")
sqrt(0.1083818 )
# script to run sims on the ihaka server.
# runs 100000 iterations of something in parallel
# set up control
# file.path on remote machine that holds the fits.
# results_fits_filepath <- "/home/bdra011/data/fits.rds"
# results_fits_filepath <- "C:/Users/Bradley/OneDrive - The University of Auckland/PhD/outputs/simulations/data/fits.rds"
library(dplyr)
results_filepath <- "/home/bdra011/data/results.rds"
n_reps <- 10
thetas <- c(0.5, 1, 2)
par_combos <- data.frame(
k  = c(   100,  100, 100,  50, 50, 50),
nk = c(     2,    2,   2,   4,  4,  4),
theta = c(0.5,    1,   2, 0.5,  1,  2)
)
par_combo_list <- split(par_combos, seq(nrow(par_combos)))
par_combo_list <- lapply(par_combo_list, function(df){
one_list <- as.list(df)
append(one_list, values = list(beta = c(1, -0.7, 0.5),
max_iter = 10))
})
## Below here, no parameters should need changing.
# these are the functions for one simulation rep
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
get_beta_theta <- function(coxme_fit){
coef_est = cbind(coef(coxme_fit), confint(coxme_fit), sqrt(diag(vcov(coxme_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = unlist(coxme::VarCorr(coxme_fit)), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
ds <- one_dataset()
ds <- one_dataset(control = list(k = 100, nk = 4))
ds <- one_dataset(control = list(k = 100, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
ds
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
library(survey)
library(survival)
names(ds)
?frailty
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian"), data = ds)
summary(fit)
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "df"), data = ds)
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "aic"), data = ds)
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "aic"), data = ds)
fit2 <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
str(fit)
summary(fit)
fit$history
fit$history$theta
fit$history$`frailty(M, distribution = "gaussian", method = "aic")`$theta
sqrt(fit$history$`frailty(M, distribution = "gaussian", method = "aic")`$theta)
fit$frail
var(fit$frail)
fit$fvar
mean(fit$fvar)
sqrt(mean(fit$fvar))
fit$var2
summarise(fit)
summary(fit)
str(fit)
grep("0.987709", "blah0.9877098blah")
grep("0.987709", fit)
fit[17]
0.9877098^2
summary(fit)
fit[17]
fit[[17]]
fit[[17]][[3]]
fit[[17]][3]
fit[[17]][1]
fit[[17]][[1]]
fit[[17]][[1]]$history
fit[[17]][[1]]$history["theta"]
class(fit[[17]][[1]]$history)
fit[[17]][[1]][ ,"theta"]
dim(fit[[17]][[1]])
fit[[17]][[1]]
dim(fit[[17]][[1]]$history)
fit[[17]][[1]]$history[, "theta"]
last(fit[[17]][[1]]$history[, "theta"], 1)
last
tail(fit[[17]][[1]]$history[, "theta"], 1)
get_theta <- function(fit){
theta <- tail(fit[[17]][[1]]$history[, "theta"], 1)
theta
}
get_theta(fit)
one_ph_rep <- function(){
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "aic"), data = ds)
}
one_ph_rep()
one_ph_rep <- function(){
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "aic"), data = ds)
get_theta(fit)
}
one_ph_rep()
one_ph_rep()
one_ph_rep()
one_ph_rep()
one_ph_rep()
one_ph_rep()
one_ph_rep()
thetas <- replicate(1000, one_ph_rep())
mean(thetas)
one_ph_rep <- function(){
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
get_theta(fit)
}
thetas <- replicate(1000, one_ph_rep())
mean(thetas)
fit[[17]][[1]]$history
coef(fit)
confint(fit)
sqrt(diag(vcov(coxme_fit)))
sqrt(diag(vcov(fit)))
get_beta_theta <- function(coxph_fit){
coef_est = cbind(coef(coxme_fit), confint(coxme_fit), sqrt(diag(vcov(coxme_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = get_theta(coxph_fit), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
get_beta_theta(fit)
get_beta_theta <- function(coxph_fit){
coef_est = cbind(coef(coxph_fit), confint(coxph_fit), sqrt(diag(vcov(coxph_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = get_theta(coxph_fit), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
get_beta_theta(fit)
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit_me <- try(coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = ds))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
one_ph_rep(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5), ))
one_ph_rep(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
one_ph_rep(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
library(dplyr)
results_filepath <- "/home/bdra011/data/results.rds"
n_reps <- 10
thetas <- c(0.5, 1, 2)
par_combos <- data.frame(
k  = c(   100,  100, 100,  50, 50, 50),
nk = c(     2,    2,   2,   4,  4,  4),
theta = c(0.5,    1,   2, 0.5,  1,  2)
)
par_combo_list <- split(par_combos, seq(nrow(par_combos)))
par_combo_list <- lapply(par_combo_list, function(df){
one_list <- as.list(df)
append(one_list, values = list(beta = c(1, -0.7, 0.5),
max_iter = 10))
})
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
get_theta <- function(fit){
theta <- tail(fit[[17]][[1]]$history[, "theta"], 1)
theta
}
get_beta_theta <- function(coxph_fit){
coef_est = cbind(coef(coxph_fit), confint(coxph_fit), sqrt(diag(vcov(coxph_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = get_theta(coxph_fit), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
one_ph_rep <- function(){
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
get_theta(fit)
}
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit_me <- try(coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = ds))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
control_list_to_df <- function(control){
tibble::tibble(k = control$k,
nk = control$nk,
theta = control$theta,
param_name = c("beta_1", "beta_2", "beta_3", "theta"),
param_true = c(control$beta, control$theta))
}
stack_results <- function(results) {
stacked_results <- plyr::ldply(results, '[[', "results", .id = NULL)
control_lists <- lapply(results, '[[', "control")
control_dfs <- plyr::ldply(control_lists, control_list_to_df, .id = NULL)
dplyr::bind_cols(control_dfs, stacked_results) %>%
dplyr::as_tibble()
}
#create cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("par_combo_list", "one_dataset", "get_beta_theta", "one_me_rep", "%>%"))
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("par_combo_list", "one_dataset", "get_theta", "get_beta_theta", "one_ph_rep", "%>%"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_me_rep(control = params)
})
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_ph_rep(control = params)
})
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit <- survival::coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_ph_rep(control = params)
})
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("par_combo_list", "one_dataset", "get_theta", "get_beta_theta", "one_ph_rep", "%>%"))
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_ph_rep(control = params)
})
# script to run sims on the ihaka server.
# runs 100000 iterations of something in parallel
# set up control
# file.path on remote machine that holds the fits.
# results_fits_filepath <- "/home/bdra011/data/fits.rds"
# results_fits_filepath <- "C:/Users/Bradley/OneDrive - The University of Auckland/PhD/outputs/simulations/data/fits.rds"
library(dplyr)
results_filepath <- "/home/bdra011/data/results.rds"
n_reps <- 10
thetas <- c(0.5, 1, 2)
par_combos <- data.frame(
k  = c(   100,  100, 100,  50, 50, 50),
nk = c(     2,    2,   2,   4,  4,  4),
theta = c(0.5,    1,   2, 0.5,  1,  2)
)
par_combo_list <- split(par_combos, seq(nrow(par_combos)))
par_combo_list <- lapply(par_combo_list, function(df){
one_list <- as.list(df)
append(one_list, values = list(beta = c(1, -0.7, 0.5),
max_iter = 10))
})
## Below here, no parameters should need changing.
# these are the functions for one simulation rep
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
get_theta <- function(fit){
theta <- tail(fit[[17]][[1]]$history[, "theta"], 1)
theta
}
get_beta_theta <- function(coxph_fit){
coef_est = cbind(coef(coxph_fit), confint(coxph_fit), sqrt(diag(vcov(coxph_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = get_theta(coxph_fit), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit <- survival::coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
one_ph_rep(par_combo_list[[1]])
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
one_ph_rep(par_combo_list[[1]])
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3 + survival::frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
one_ph_rep(par_combo_list[[1]])
control_list_to_df <- function(control){
tibble::tibble(k = control$k,
nk = control$nk,
theta = control$theta,
param_name = c("beta_1", "beta_2", "beta_3", "theta"),
param_true = c(control$beta, control$theta))
}
stack_results <- function(results) {
stacked_results <- plyr::ldply(results, '[[', "results", .id = NULL)
control_lists <- lapply(results, '[[', "control")
control_dfs <- plyr::ldply(control_lists, control_list_to_df, .id = NULL)
dplyr::bind_cols(control_dfs, stacked_results) %>%
dplyr::as_tibble()
}
#create cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("par_combo_list", "one_dataset", "get_theta", "get_beta_theta", "one_ph_rep", "%>%"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_ph_rep(control = params)
})
#stop the cluster
parallel::stopCluster(cl)
fits_df <- stack_results(fits)
# summary of the results
summarised_results <- fits_df %>%
dplyr::group_by(k, nk, theta, param_name) %>%
dplyr::mutate(is_hit = (param_true >= lower) & (param_true <= upper)) %>%
dplyr::summarise(true_value = first(param_true),
mean = mean(param_est),
estimated_se = mean(se, na.rm = TRUE),
empirical_se = sqrt(var(param_est)),
hits = mean(is_hit) * 100, .groups = "drop")
summarised_results
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = c(1, -0.7, 0.5), theta = 1))
sample_data
source("~/.active-rstudio-document")
devtools::load_all(".")
sortAndIndex
d1 <- sortAndIndex(sample_data)
d1 <- sortAndIndex(sample_data, t)
d1
X <-
calcLinearPredictor
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = c(1, -0.7, 0.5), theta = 1))
install.packages("learnr")
