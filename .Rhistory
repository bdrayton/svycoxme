<<<<<<< Updated upstream
<<<<<<< Updated upstream
diag(solve(-reord_hessian))
diag(fit_coxme$variance)
cbind(
myvar = diag(solve(-reord_hessian)),
coxmevar =diag(fit_coxme$variance))
vcov(fit_coxme)
my_hessian[1:3, 1:3]
solve(my_hessian[1:3, 1:3])
solve(-my_hessian[1:3, 1:3])
solve(my_hessian)
solve(-my_hessian)
diag(solve(-my_hessian))
vcov(fit_coxme)
solve(-my_hessian)[1:3, 1:3]
D = 0.1 * diag(5)
D
det(D)
determinant(D)
log(det(D))
-1/2
devtools::load_all(".")
my_beta = c(1, -0.7, 0.5)
my_theta = 0.2
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
b <- attr(sample_data, "random_effects")
my_params <- c(my_beta[seq_along(my_X)], b)
bb(parms = my_params, X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = my_theta, return_matrix = TRUE)
K_ppl <- bb(parms = my_params, X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = my_theta, return_matrix = TRUE)
pl_theta(my_theta, b, K_ppl)
debugonce(pl_theta)
pl_theta(my_theta, b, K_ppl)
b %*% solve(D)
t(b) %*% solve(D)
t(b) %*% solve(D) %*% b
det(K_ppl)
log(det(K_ppl))
log(det(D))
(-1/2) * ( log(det(D)) + log(det(K_ppl)) + t(b) %*% solve(D) %*% b )
devtools::load_all(".")
pl_theta(my_theta, b, K_ppl)
optim(par = 1, fn = pl_theta, b = b, K_ppl = K_ppl)
optim(par = 1, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent")
optim(par = 1, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0)
optim(par = 1, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100)
optim(par = 1, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
optim(par = 0.5, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
optim(par = 0, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
devtools::load_all(".")
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 50
my_nk = 10
max_iter = 100
convergence_threshold = 0.00001 # same as coxme
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
nb <- dplyr::n_distinct(sample_data$M)
start_parameters = c(coef(fit), rep(0, nb))
names(start_parameters) <- c(my_X, paste0("Z", seq_len(nb)))
current_estimates <- estimate_parameters(start_parms = start_parameters, theta = 4, X = my_X, t = "t",
cluster = "M", dij = stat, data = sample_data)
estimate_history <- list(current_estimates)
estimate_history
estimate_history <- list(current_estimates)
start_time <- Sys.time()
for (i in 1:max_iter) {
current_estimates <- try(estimate_parameters(start_parms = current_estimates$new_parms,
theta = current_estimates$new_theta,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data))
if("try-error" %in% class(current_estimates)) {
cat("fit failed on iteration", i, "\n")
break
}
estimate_history[[i+1]] <- current_estimates
biggest_diff = max(abs(c(estimate_history[[i]]$new_theta - estimate_history[[i+1]]$new_theta,
estimate_history[[i]]$new_parms - estimate_history[[i+1]]$new_parms)), na.rm = TRUE)
if(biggest_diff <= convergence_threshold){
cat("converged in", i, "iterations", "\n")
break
}
}
end_time <- Sys.time()
end_time - start_time
theta_ests <- sapply(estimate_history, "[[", "new_theta")
plot(theta_ests)
nreps = 3
=======
plot(theta_ests)
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1 | M), data = sample_data)
coxme::VarCorr(coxme_fit)
coxme::VarCorr(coxme_fit)$M
algo_fit <- tail(estimate_history, 1)
data.frame(
true_vals = c(my_theta, my_beta, attr(sample_data, "random_effects")),
coxme = c(coxme::VarCorr(coxme_fit)$M,
coxme::fixef(coxme_fit),
coxme::ranef(coxme_fit)$M),
my_ests = unlist(algo_fit))
theta_ests <- sapply(estimate_history, "[[", "new_theta")
plot(theta_ests)
parm_ests <- sapply(estimate_history, "[[", "new_parms")
parm_ests %>%
as.data.frame() %>%
tibble::rownames_to_column() %>%
tidyr::pivot_longer(cols = dplyr::starts_with("V")) %>%
dplyr::filter(grepl("X", rowname)) %>%
dplyr::mutate(iteration = as.numeric(gsub("V", "", name))) %>%
ggplot(aes(iteration, value)) +
geom_line() +
facet_grid(rows = vars(rowname),
scales = "free")
coxme_fit$frail
sample_data["M"]
str(sample_data["M"])
str(sample_data[,"M"])
str(sample_data[,"M", drop = TRUE])
devtools::load_all(".")
estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.00001,
start_theta = 4,
X = c("X1", "X2", "X3"))
devtools::load_all(".")
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.00001,
start_theta = 4,
X = c("X1", "X2", "X3"))
r1$estimate_history
lapply(r1$estimate_history, "[[", "new_theta")
sapply(r1$estimate_history, "[[", "new_theta")
r1$converged
plot(theta_history)
theta_history <- sapply(r1$estimate_history, "[[", "new_theta")
plot(theta_history)
>>>>>>> Stashed changes
onerep <- function(...){
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
<<<<<<< Updated upstream
convergence_threshold = 0.0001,
start_theta = 4,
X = c("X1", "X2", "X3"))
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = r1$sample_data)
list(theta_history = sapply(r1$estimate_history, "[[", "new_theta"),
coxme_est_theta = coxme::VarCorr(coxme_fit)$M,
converged = r1$converged)
=======
convergence_threshold = 0.00001,
start_theta = 4,
X = c("X1", "X2", "X3"))
theta_history <- sapply(r1$estimate_history, "[[", "new_theta")
theta_history
>>>>>>> Stashed changes
}
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
<<<<<<< Updated upstream
parallel::clusterEvalQ(cl, {
devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
=======
fits <- parallel::parLapply(cl, list(1:3), onerep)
devtools::load_all(".")
onerep <- function(...){
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.00001,
start_theta = 4,
X = c("X1", "X2", "X3"))
theta_history <- sapply(r1$estimate_history, "[[", "new_theta")
theta_history
}
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
fits <- parallel::parLapply(cl, list(1:3), onerep)
fits
cl
list(1:3)
split(1:3, 1:3)
nreps = 3
onerep <- function(...){
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.00001,
start_theta = 4,
X = c("X1", "X2", "X3"))
theta_history <- sapply(r1$estimate_history, "[[", "new_theta")
theta_history
}
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
>>>>>>> Stashed changes
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
fits <- parallel::parLapply(cl, split(seq_len(nreps), seq_len(nreps)) , onerep)
#stop the cluster
parallel::stopCluster(cl)
<<<<<<< Updated upstream
fits
1000 * 2.5
2.5 * 64
library(tidyverse)
din <- read_rds(din_path)
din_path <- "C:/Users/bdra011/OneDrive - The University of Auckland/PhD/outputs/simulations/data/results_theta_estimation_coxme_vs_estimate_parameters_loop_v2.rds"
din <- read_rds(din_path)
lapply(din, "[[", "converged")
sapply(din, "[[", "converged") |> mean()
din[[1]]
sapply(din, "[[", "coxme_est_theta")|> mean()
theta_paths <- lapply(din, "[[", theta_history)
theta_paths <- lapply(din, "[[", "theta_history")
converged <- sapply(din, "[[", "converged")
mean(converged)
sapply(theta_paths[converged], tail, 1)
theta_ests <- sapply(theta_paths[converged], tail, 1)
mean(theta_ests)
sapply(din, "[[", "coxme_est_theta")|> mean()
theta_ests <- sapply(theta_paths, tail, 1)
mean(theta_ests)
mean(theta_ests[converged])
coxme_ests <- sapply(din, "[[", "coxme_est_theta")
mean(coxme_ests)
data.frame(my_ests = theta_ests, coxme_ests = coxme_ests)
data.frame(my_ests = theta_ests, coxme_ests = coxme_ests) %>%
pivot_longer(cols = c("my_ests", "coxme_ests"))
data.frame(my_ests = theta_ests, coxme_ests = coxme_ests) %>%
pivot_longer(cols = c("my_ests", "coxme_ests")) %>%
ggplot(aes(value, colour = name)) + geom_density()
my_beta = c(1, -0.7, 0.5)
my_theta = 0.2
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
devtools::load_all(".")
my_beta = c(1, -0.7, 0.5)
my_theta = 0.2
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
coxme::VarCorr(coxme_fit)
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
coxme::VarCorr(coxme_fit)
coxme_theta <- coxme::VarCorr(coxme_fit)$M
bb
bb(parms = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)),
X = my_X, t = t, cluster = "M", dij = dij, data = sample_data,
theta = coxme_theta, return_matrix = TRUE)
coxme::fixef(coxme_fit)
coxme::ranef(coxme_fit)
bb(parms = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M),
X = my_X, t = t, cluster = "M", dij = dij, data = sample_data,
theta = coxme_theta, return_matrix = TRUE)
K_ppl <- bb(parms = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M),
X = my_X, t = t, cluster = "M", dij = dij, data = sample_data,
theta = coxme_theta, return_matrix = TRUE)
b
b <- coxme::ranef(coxme_fit)$M
K_ppl <- bb(parms = c(coxme::fixef(coxme_fit), b),
X = my_X, t = t, cluster = "M", dij = dij, data = sample_data,
theta = coxme_theta, return_matrix = TRUE)
optim(par = 0, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
coxme_theta
coxme_fit$hmat
hmat <- coxme_fit$hmat
as.matrix(hmat)
library(bdsmatrix)
L <- as.matrix(hmat)
D <- diag(hmat)
L %*% B %*% L
L <- as.matrix(hmat)
D <- diag(hmat)
L %*% D %*% L
L %*% D %*% t(L)
L %*% D
L %*% diag(D) %*% t(L)
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 10
ds <- one_dataset(list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = ds)
coxme_est_theta <- coxme::VarCorr(fit)$M
coxme_est_parms <- c(coxme::fixef(fit), coxme::ranef(fit)$M)
parm_names <- paste0(rep(c("X", "Z"), c(3, my_k)), c(1:3, seq_len(my_k)))
names(coxme_est_parms) <- parm_names
my_loglik <- lp(parms = coxme_est_parms,
X = c("X1", "X2", "X3"),
cluster = "M",
=======
devtools::load_all(".")
nreps = 3
onerep <- function(...){
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.00001,
start_theta = 4,
X = c("X1", "X2", "X3"))
theta_history <- sapply(r1$estimate_history, "[[", "new_theta")
theta_history
}
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
fits <- parallel::parLapply(cl, split(seq_len(nreps), seq_len(nreps)) , onerep)
#stop the cluster
parallel::stopCluster(cl)
fits
onerep <- function(...){
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.0001,
start_theta = 4,
X = c("X1", "X2", "X3"))
theta_history <- sapply(r1$estimate_history, "[[", "new_theta")
r1$sample_data
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = r1$sample_data)
coxme_est_theta <- coxme::VarCorr(fit)$M
list(theta_history,
coxme_est_theta)
}
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
devtools::load_all(".")
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
#stop the cluster
parallel::stopCluster(cl)
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
fits <- parallel::parLapply(cl, split(seq_len(nreps), seq_len(nreps)) , onerep)
#stop the cluster
parallel::stopCluster(cl)
coxme_est_theta <- coxme::VarCorr(coxme_fit)$M
results_filepath <-  "/home/bdra011/data/results_theta_estimation_coxme_vs_estimate_parameters_loop.rds"
nreps = 3
onerep <- function(...){
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.0001,
start_theta = 4,
X = c("X1", "X2", "X3"))
theta_history <- sapply(r1$estimate_history, "[[", "new_theta")
r1$sample_data
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = r1$sample_data)
coxme_est_theta <- coxme::VarCorr(coxme_fit)$M
list(theta_history,
coxme_est_theta)
}
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
fits <- parallel::parLapply(cl, split(seq_len(nreps), seq_len(nreps)) , onerep)
#stop the cluster
parallel::stopCluster(cl)
fits
onerep <- function(...){
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.0001,
start_theta = 4,
X = c("X1", "X2", "X3"))
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = r1$sample_data)
list(theta_history = sapply(r1$estimate_history, "[[", "new_theta"),
coxme_est_theta = coxme::VarCorr(coxme_fit)$M)
}
nreps = 3
onerep <- function(...){
r1 <- estimate_parameters_loop(beta = c(1, -0.7, 0.5),
theta = 1,
k = 50,
nk = 10,
cluster = "M",
max_iter = 100,
convergence_threshold = 0.0001,
start_theta = 4,
X = c("X1", "X2", "X3"))
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = r1$sample_data)
list(theta_history = sapply(r1$estimate_history, "[[", "new_theta"),
coxme_est_theta = coxme::VarCorr(coxme_fit)$M)
}
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
})
fits <- parallel::parLapply(cl, split(seq_len(nreps), seq_len(nreps)) , onerep)
#stop the cluster
parallel::stopCluster(cl)
fits
user <- c("Bradley", "bdra011")[1]
results_filepath <-  glue::glue("C:/Users/{user}/OneDrive - The University of Auckland/PhD/outputs/simulations/data/results_theta_estimation_coxme_vs_estimate_parameters_loop.rds")
res <- readr::read_rds(results_filepath)
lapply(res, "[[", "theta_history")
theta_paths <- lapply(res, "[[", "theta_history")
unlist(theta_paths)
all_thetas <- unlist(theta_paths)
sapply(theta_paths, length) |> max()
range(all_thetas)
range(all_thetas, na.rm = TRUE)
plot(type = "n", ylim = range(all_thetas, na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()))
plot(x = 1, y = 1, type = "n", ylim = range(all_thetas, na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()))
plot(x = 1, y = 1, type = "n", ylim = range(all_thetas, na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
lapply(theta_paths, lines)
plot(x = 1, y = 1, type = "n", ylim = range(all_thetas, na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path))
})
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path))
}))
plot(x = 1, y = 1, type = "n",
ylim = range(c(4, all_thetas), na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path))
}))
# proportion of successful fits
res
sapply(theta_paths, function(one_path){
last_theta <- tail(one_path)
is.na(last_theta) | sign(last_theta) == -1
})
theta_paths
sapply(theta_paths, function(one_path){
last_theta <- tail(one_path, 1)
is.na(last_theta) | sign(last_theta) == -1
})
successes <- sapply(theta_paths, function(one_path){
last_theta <- tail(one_path, 1)
!(is.na(last_theta) | sign(last_theta) == -1)
})
mean(successes)
valid_theta_ests <- sapply(theta_paths[successes], tail, 1)
valid_theta_ests
mean(valid_theta_ests)
res
coxme_theta_ests <- sapply(res, "[[", "coxme_est_theta")
coxme_theta_ests
mean(coxme_theta_ests)
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 10
ds <- one_dataset(list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = ds)
coxme_est_theta <- coxme::VarCorr(fit)$M
coxme_est_parms <- c(coxme::fixef(fit), coxme::ranef(fit)$M)
parm_names <- paste0(rep(c("X", "Z"), c(3, my_k)), c(1:3, seq_len(my_k)))
names(coxme_est_parms) <- parm_names
my_loglik <- lp(parms = coxme_est_parms,
X = c("X1", "X2", "X3"),
cluster = "M",
>>>>>>> Stashed changes
t = t, dij = stat,
theta = coxme_est_theta,
data = ds)
fit$loglik["Penalized"] - my_loglik
<<<<<<< Updated upstream
fit$penalty - attr(my_loglik, "penalty")
# and penalties?
=======
>>>>>>> Stashed changes
fit$penalty - attr(my_loglik, "penalty")
my_u <- lp_grd(parms = coxme_est_parms,
X = c("X1", "X2", "X3"),
cluster = "M",
t = t,
dij = stat,
theta = coxme_est_theta,
data = ds)
ordered_coxme_u <-
tibble::tibble(coxme_u = fit$u,
coxme_u_order = seq_along(coxme_u)) %>%
dplyr::arrange(coxme_u)
ordered_my_u <-
tibble::tibble(parm = parm_names,
my_u = my_u) %>%
dplyr::arrange(my_u)
# it looks like the only reordering is to put the fixed effects after the random effects.
dplyr::bind_cols(
ordered_coxme_u,
ordered_my_u) %>%
dplyr::arrange( coxme_u_order) %>%
=======
>>>>>>> Stashed changes
dplyr::pull(parm)
user <- c("Bradley", "bdra011")[1]
results_filepath <-  glue::glue("C:/Users/{user}/OneDrive - The University of Auckland/PhD/outputs/simulations/data/results_theta_estimation_coxme_vs_estimate_parameters_loop.rds")
res <- readr::read_rds(results_filepath)
theta_paths <- lapply(res, "[[", "theta_history")
all_thetas <- unlist(theta_paths)
plot(x = 1, y = 1, type = "n",
ylim = range(c(4, all_thetas), na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path))
}))
plot(x = 1, y = 1, type = "n",
ylim = range(c(4, all_thetas), na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path), alpha = 0.5)
}))
plot(x = 1, y = 1, type = "n",
ylim = range(c(4, all_thetas), na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path), par = par(col = rgb(1, 1, 1, 0.1)))
}))
warnings()
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path), col = rgb(1, 1, 1, 0.1))
}))
plot(x = 1, y = 1, type = "n",
ylim = range(c(4, all_thetas), na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path), col = rgb(1, 1, 1, 0.1))
}))
plot(x = 1, y = 1, type = "n",
ylim = range(c(4, all_thetas), na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path), col = rgb(1, 1, 1, 0.5))
}))
my_hessian <- svycoxme::ppl_hessian(parms = coxme_est_parms,
X = c("X1", "X2", "X3"),
cluster = "M",
t = t,
dij = stat,
theta = coxme_est_theta,
data = ds)
reordered_names <- colnames(my_hessian)[c(seq_len(my_k) + 3, 1:3)]
reord_hessian <- my_hessian[reordered_names, reordered_names]
# decompose my hessian
gchol_reord_hessian <- gchol(reord_hessian)
<<<<<<< Updated upstream
=======
library(bdsmatrix)
gchol_reord_hessian <- gchol(reord_hessian)
>>>>>>> Stashed changes
gchol_my_hessian <- gchol(my_hessian)
L <- as.matrix(gchol_reord_hessian)
D <- diag(gchol_reord_hessian)
(L %*% diag(D) %*% t(L) - reord_hessian) <(.Machine$double.neg.eps*100)
<<<<<<< Updated upstream
(L %*% diag(D) %*% t(L) - reord_hessian)
max(L %*% diag(D) %*% t(L) - reord_hessian)
L <- as.matrix(fit_coxme$hmat)
=======
L <- as.matrix(fit_coxme$hmat)
D <- diag(fit_coxme$hmat)
>>>>>>> Stashed changes
L <- as.matrix(fit$hmat)
D <- diag(fit$hmat)
back_trans_hmat <- L %*% diag(D) %*% t(L)
back_trans_hmat - (-1 * reord_hessian)
# for the fixed effects, estimates are of the same magnitude, but not the same.
vcov(fit_coxme)
# for the fixed effects, estimates are of the same magnitude, but not the same.
vcov(fit)
<<<<<<< Updated upstream
solve(-my_hessian)[1:3, 1:3]
# looking at the variances and ignoring non-diagonal terms, they are not the same.
cbind(
myvar = diag(solve(-reord_hessian)),
coxmevar = diag(fit_coxme$variance))
# looking at the variances and ignoring non-diagonal terms, they are not the same.
cbind(
myvar = diag(solve(-reord_hessian)),
coxmevar = diag(fit$variance))
# solve(hmat) == coxme$variance
# More precisely, the inverse of coxme$hmat differs from coxme$variance by less
# than machine error.
hmat_inv <- solve(fit_coxme$hmat, full = TRUE)
# solve(hmat) == coxme$variance
# More precisely, the inverse of coxme$hmat differs from coxme$variance by less
# than machine error.
hmat_inv <- solve(fit$hmat, full = TRUE)
all.equal(fit_coxme$variance, hmat_inv)
all.equal(fit$variance, hmat_inv)
hmat <- coxme_fit$hmat
L <- as.matrix(hmat)
D <- diag(hmat)
L %*% diag(D) %*% t(L)
back_trans_hmat
K_ppl <- bb(parms = c(coxme::fixef(coxme_fit), b),
X = my_X, t = t, cluster = "M", dij = dij, data = sample_data,
theta = coxme_theta, return_matrix = TRUE)
K_ppl
L %*% diag(D) %*% t(L)
(L %*% diag(D) %*% t(L)) - (-1 * K_ppl)
seq_along(nk)
(L %*% diag(D) %*% t(L))[seq_along(my_nk), seq_along(my_nk)]
seq_along(my_nk)
my_nk
(L %*% diag(D) %*% t(L))[seq_len(my_nk), seq_len(my_nk)] - (-1 * K_ppl)
coxme_K_ppl <- L %*% diag(D) %*% t(L)
coxme_K_ppl <- -1 * L %*% diag(D) %*% t(L)
optim(par = 0, fn = pl_theta, b = b, K_ppl = coxme_K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
warnings()
coxme_K_ppl
coxme_K_ppl <- L %*% diag(D) %*% t(L)
optim(par = 0, fn = pl_theta, b = b, K_ppl = coxme_K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
pl_theta
b
theta <- seq(0, 0.5, by = 0.001)
likes <- sapply(theta, pl_theta, b = b, K_ppl = coxme_K_ppl)
likes <- sapply(theta, pl_theta, b = b, K_ppl = -coxme_K_ppl)
theta <- seq(0.001, 0.5, by = 0.001)
likes <- sapply(theta, pl_theta, b = b, K_ppl = -coxme_K_ppl)
warnings()
likes <- sapply(theta, pl_theta, b = b, K_ppl = coxme_K_ppl)
plot(theta, likes, type = "l")
my_beta = c(1, -0.7, 0.5)
my_theta = 0.2
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
b <- attr(sample_data, "random_effects")
my_params <- c(my_beta[seq_along(my_X)], b)
K_ppl <- bb(parms = my_params, X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = my_theta, return_matrix = TRUE)
debugonce(pl_theta)
pl_theta(my_theta, b, K_ppl)
optim(par = 0, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
coxme_theta <- coxme::VarCorr(coxme_fit)$M
(coxme_theta <- coxme::VarCorr(coxme_fit)$M)
b <- coxme::ranef(coxme_fit)$M
hmat <- coxme_fit$hmat
L <- as.matrix(hmat)
D <- diag(hmat)
(L %*% diag(D) %*% t(L))[seq_len(my_nk), seq_len(my_nk)] - (-1 * K_ppl)
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
b <- attr(sample_data, "random_effects")
my_params <- c(my_beta[seq_along(my_X)], b)
K_ppl <- bb(parms = my_params, X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = my_theta, return_matrix = TRUE)
debugonce(pl_theta)
pl_theta(my_theta, b, K_ppl)
optim(par = 0, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
# compare with theta from coxme
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
(coxme_theta <- coxme::VarCorr(coxme_fit)$M)
b <- coxme::ranef(coxme_fit)$M
hmat <- coxme_fit$hmat
L <- as.matrix(hmat)
D <- diag(hmat)
(L %*% diag(D) %*% t(L))[seq_len(my_nk), seq_len(my_nk)] - (-1 * K_ppl)
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
b <- attr(sample_data, "random_effects")
my_params <- c(my_beta[seq_along(my_X)], b)
K_ppl <- bb(parms = my_params, X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = my_theta, return_matrix = TRUE)
debugonce(pl_theta)
pl_theta(my_theta, b, K_ppl)
optim(par = 0, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
# compare with theta from coxme
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
(coxme_theta <- coxme::VarCorr(coxme_fit)$M)
b <- coxme::ranef(coxme_fit)$M
hmat <- coxme_fit$hmat
L <- as.matrix(hmat)
D <- diag(hmat)
(L %*% diag(D) %*% t(L))[seq_len(my_nk), seq_len(my_nk)] - (-1 * K_ppl)
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
b <- attr(sample_data, "random_effects")
my_params <- c(my_beta[seq_along(my_X)], b)
K_ppl <- bb(parms = my_params, X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = my_theta, return_matrix = TRUE)
debugonce(pl_theta)
pl_theta(my_theta, b, K_ppl)
optim(par = 0, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
# compare with theta from coxme
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
(coxme_theta <- coxme::VarCorr(coxme_fit)$M)
b <- coxme::ranef(coxme_fit)$M
hmat <- coxme_fit$hmat
L <- as.matrix(hmat)
D <- diag(hmat)
(L %*% diag(D) %*% t(L))[seq_len(my_nk), seq_len(my_nk)] - (-1 * K_ppl)
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
(coxme_theta <- coxme::VarCorr(coxme_fit)$M)
b <- coxme::ranef(coxme_fit)$M
K_ppl <- bb(parms = c(coxme::fixef(coxme_fit), b), X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = coxme_theta, return_matrix = TRUE)
K_ppl
hmat <- coxme_fit$hmat
L <- as.matrix(hmat)
D <- diag(hmat)
(L %*% diag(D) %*% t(L))[seq_len(my_nk), seq_len(my_nk)] - (-1 * K_ppl)
coxme_K_ppl <- L %*% diag(D) %*% t(L)
optim(par = 0, fn = pl_theta, b = b, K_ppl = coxme_K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
theta <- seq(0.001, 0.5, by = 0.001)
likes <- sapply(theta, pl_theta, b = b, K_ppl = coxme_K_ppl)
plot(theta, likes, type = "l")
which(x = theta == max(theta))
which(x = likes == max(likes))
likes[10]
theta[10]
coxme_theta
coxme_fit$iter
coxme_fit$control
coxme_K_ppl <- L %*% diag(D) %*% t(L)
optim(par = 0, fn = pl_theta, b = b, K_ppl = coxme_K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
my_beta = c(1, -0.7, 0.5)
my_theta = 0.2
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
b <- attr(sample_data, "random_effects")
my_params <- c(my_beta[seq_along(my_X)], b)
K_ppl <- bb(parms = my_params, X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = my_theta, return_matrix = TRUE)
debugonce(pl_theta)
pl_theta(my_theta, b, K_ppl)
optim(par = 0, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
# compare with theta from coxme
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
(coxme_theta <- coxme::VarCorr(coxme_fit)$M)
b <- coxme::ranef(coxme_fit)$M
K_ppl <- bb(parms = c(coxme::fixef(coxme_fit), b), X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = coxme_theta, return_matrix = TRUE)
hmat <- coxme_fit$hmat
L <- as.matrix(hmat)
D <- diag(hmat)
# check that they're the same(ish)
(L %*% diag(D) %*% t(L))[seq_len(my_nk), seq_len(my_nk)] - (-1 * K_ppl)
coxme_K_ppl <- L %*% diag(D) %*% t(L)
optim(par = 0, fn = pl_theta, b = b, K_ppl = coxme_K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
theta <- seq(0.001, 0.5, by = 0.00001)
likes <- sapply(theta, pl_theta, b = b, K_ppl = coxme_K_ppl)
plot(theta, likes, type = "l")
theta[which(theta == max(theta))]
theta[which(likes == max(likes))]
optim(par = 0, fn = pl_theta, b = b, K_ppl = coxme_K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
optim(par = 0, fn = pl_theta, b = b, K_ppl = coxme_K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))$par
coxme_theta
log(0.034)
exp(0.034)
library(tidyverse)
din_path <- "C:/Users/bdra011/OneDrive - The University of Auckland/PhD/outputs/simulations/data/results_theta_estimation_coxme_vs_estimate_parameters_loop_v2.rds"
din <- read_rds(din_path)
converged <- sapply(din, "[[", "converged")
mean(converged)
din[[1]]
coxme_ests <- sapply(din, "[[", "coxme_est_theta")
mean(coxme_ests)
theta_paths <- lapply(din, "[[", "theta_history")
theta_ests <- sapply(theta_paths, tail, 1)
mean(theta_ests)
mean(theta_ests[converged])
mean(exp(theta_ests))
b
theta
my_theta
D <- my_theta * diag(length(b))
det(D)
log(det(D))
log(det(K_ppl))
t(b) %*% solve(D) %*% b
log(det(K_ppl)) + t(b) %*% solve(D) %*% b
c((-1/2) * ( log(det(D)) + log(det(K_ppl)) + t(b) %*% solve(D) %*% b ))
devtools::load_all(".")
my_beta = c(1, -0.7, 0.5)
my_theta = 0.2
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
b <- attr(sample_data, "random_effects")
my_params <- c(my_beta[seq_along(my_X)], b)
K_ppl <- bb(parms = my_params, X = my_X, t = t, cluster = "M", dij = stat,
data = sample_data, theta = my_theta, return_matrix = TRUE)
debugonce(pl_theta)
pl_theta(my_theta, b, K_ppl)
optim(par = 0, fn = pl_theta, b = b, K_ppl = K_ppl, method = "Brent", lower = 0, upper = 100,
control = list(fnscale = -1))
<<<<<<< Updated upstream
=======
solve(-my_hessian)[1:3, 1:3]
# looking at the variances and ignoring non-diagonal terms, they are not the same.
cbind(
myvar = diag(solve(-reord_hessian)),
coxmevar = diag(fit_coxme$variance))
# looking at the variances and ignoring non-diagonal terms, they are not the same.
cbind(
myvar = diag(solve(-reord_hessian)),
coxmevar = diag(fit$variance))
# solve(hmat) == coxme$variance
# More precisely, the inverse of coxme$hmat differs from coxme$variance by less
# than machine error.
hmat_inv <- solve(fit_coxme$hmat, full = TRUE)
# solve(hmat) == coxme$variance
# More precisely, the inverse of coxme$hmat differs from coxme$variance by less
# than machine error.
hmat_inv <- solve(fit$hmat, full = TRUE)
all.equal(fit_coxme$variance, hmat_inv)
all.equal(fit$variance, hmat_inv)
# looking at the variances and ignoring non-diagonal terms, they are not the same.
cbind(
myvar = diag(solve(-reord_hessian)),
coxmevar = diag(fit$variance))
# for the fixed effects, estimates are of the same magnitude, but not the same.
vcov(fit)
solve(-my_hessian)[1:3, 1:3]
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path), col = rgb(0, 0, 0, 0.5))
}))
successes <- sapply(theta_paths, function(one_path){
last_theta <- tail(one_path, 1)
!(is.na(last_theta) | sign(last_theta) == -1)
})
mean(successes)
valid_theta_ests <- sapply(theta_paths[successes], tail, 1)
mean(valid_theta_ests)
coxme_theta_ests <- sapply(res, "[[", "coxme_est_theta")
mean(coxme_theta_ests)
plot(x = 1, y = 1, type = "n",
ylim = range(c(4, all_thetas), na.rm = TRUE),
xlim = c(0, sapply(theta_paths, length) |> max()),
xlab = "Iteration", ylab = expression(widehat(theta)))
invisible(lapply(theta_paths, function(one_path){
lines(x = 0:length(one_path),
y = c(4, one_path), col = rgb(0.5, 0.5, 0.5, 0.3))
}))
>>>>>>> Stashed changes
=======
vignette("coxme", package = "coxme")
vignette("laplace", package = "coxme")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
optim_ipl(theta = 0.5,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 50
my_nk = 10
max_iter = 100
convergence_threshold = 0.00001 # same as coxme
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
nb <- dplyr::n_distinct(sample_data$M)
start_parameters = c(coef(fit), rep(0, nb))
names(start_parameters) <- c(my_X, paste0("Z", seq_len(nb)))
optim_ipl(theta = 0.5,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
optim_ipl(theta = 1,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
optim(par = c(1),
fn = optim_ipl,
gr = NULL,
method = "BGFS",
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
optim(par = c(1),
fn = optim_ipl,
gr = NULL,
method = "BFGS",
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
optim(par = c(1),
fn = optim_ipl,
gr = NULL,
method = "BFGS",
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data,
control = list(fnscale = -1))
optim(par = c(1),
fn = optim_ipl,
gr = NULL,
method = "Brent",
lower = 0, upper = 1000,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data,
control = list(fnscale = -1))
optim(par = c(1),
fn = optim_ipl,
gr = NULL,
method = "Brent",
lower = 0.01, upper = 100,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data,
control = list(fnscale = -1))
coxme_fit <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = sample_data)
coxme::VarCorr(coxme_fit)$M
sapply(c(0.01, 0.5, 1), optim_ipl,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
optim_ipl
sapply(c(0.01, 0.5, 1), optim_ipl,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
c(0.01, 0.5, 1)
sapply(list(0.01, 0.5, 1), optim_ipl, start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
lapply(list(0.01, 0.5, 1), optim_ipl, start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
list(0.01, 0.5, 1)
lapply(X = list(0.01, 0.5, 1), function(val){
optim_ipl(theta = val,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
})
my_beta = c(1, -0.7, 0.5)
my_theta = 3
my_k = 50
my_nk = 10
max_iter = 100
convergence_threshold = 0.00001 # same as coxme
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
nb <- dplyr::n_distinct(sample_data$M)
start_parameters = c(coef(fit), rep(0, nb))
names(start_parameters) <- c(my_X, paste0("Z", seq_len(nb)))
lapply(X = list(0.01, 0.5, 1), function(val){
optim_ipl(theta = val,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
})
devtools::load_all(".")
my_beta = c(1, -0.7, 0.5)
my_theta = 3
my_k = 50
my_nk = 10
max_iter = 100
convergence_threshold = 0.00001 # same as coxme
my_X = c("X1", "X2", "X3")
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
nb <- dplyr::n_distinct(sample_data$M)
start_parameters = c(coef(fit), rep(0, nb))
names(start_parameters) <- c(my_X, paste0("Z", seq_len(nb)))
debugonce(optim_ipl)
optim_ipl(theta = 1,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
debugonce(optim_ipl)
optim_ipl(theta = 1,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
devtools::load_all(".")
debugonce(optim_ipl)
optim_ipl(theta = 1,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
lp_hat
lp_hat
lp_hat
fit_optim$value
devtools::load_all(".")
optim_ipl(theta = 1,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
lapply(X = list(0.01, 0.5, 1), function(val){
optim_ipl(theta = val,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
})
lapply(X = list(0.01, 0.5, 1, 10, 50), function(val){
optim_ipl(theta = val,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
})
debugonce(optim_ipl)
optim_ipl(theta = 1,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
debugonce(optim_ipl)
optim_ipl(theta = 1,
start_parms = start_parameters,
X = my_X,
t = "t",
cluster = "M",
dij = stat,
data = sample_data)
det(K_ppl_hat)
log(det(K_ppl_hat))
log(det(-K_ppl_hat))
log(det(-1 * K_ppl_hat))
determinant(K_ppl_hat)
determinant(- K_ppl_hat)
fit_optim
lp(parms = fit$par, X = X, t = t, dij = stat, theta = theta, cluster = "M", data = data)
lp(parms = fit_optim$par, X = X, t = t, dij = stat, theta = theta, cluster = "M", data = data)
devtools::load_all(".")
?coxph
source('~/PhD_local/svycoxme/R/ripatti_likelihoods.R')
devtools::load_all(".")
devtools::load_all(".")
>>>>>>> Stashed changes
