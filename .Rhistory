Z1_mean = tapply(Z1, group_id, FUN = mean)
Z2_mean = tapply(Z2, group_id, FUN = mean)
mu_X1 = 0.5 * Z1
mu_X2 = 0.5 * (Z1_mean + Z2_mean)
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.5), each = nk)
rate = baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk))
event_time = rexp(N, rate)
dset = data.frame(event_time, stat = 1, X1, X2, Z1, Z2, group_id)
one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
debugonce(one_rep)
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
debugonce(svycoxme)
resid(if_full_model, data = pop_data, type = "dfbeta")
class(if_full_model)
debugonce(residuals)
resid
residuals
survey:::residuals.svycoxph
survival:::residuals.coxph
devtools::load_all(".")
one_rep = function(pop_data, n, k, pop_model = "coxph", sample_model = "svycoxph", ...){
# library(svycoxme)
sample_clusters = sample.int(n = k, size = n)
dsamp = pop_data[which(pop_data$group_id %in% sample_clusters), ]
# fit imputation model
impmodel1 <- glm(X1~Z1+Z2, data = dsamp, family = gaussian)
impmodel2 <- glm(X2~Z1+Z2, data = dsamp, family = gaussian)
pop_data$impX1 <- predict(impmodel1, newdata = pop_data, type = "response")
pop_data$impX2 <- predict(impmodel2, newdata = pop_data, type = "response")
# fit a model to the population data supplemented with the imputed histology
if(pop_model == "coxph"){
if_full_model <- coxph(Surv(event_time, stat) ~ impX1 + impX2, data = pop_data)
} else if(pop_model == "coxme"){
if_full_model <- coxme::coxme(Surv(event_time, stat) ~ impX1 + impX2 + (1 | group_id),
data = pop_data)
}
# append influence functions to the pop data
# if coxme was used, need to load svycoxme for the residual function coxme.residuals
inffun_full <- resid(if_full_model, data = pop_data, type = "dfbeta") |> as.matrix()
colnames(inffun_full) <- paste0("iff", seq(ncol(inffun_full)))
pop_data_if <- cbind(pop_data, inffun_full)
# design with sample data
if_design <- svydesign(~group_id, ~1, data = pop_data_if[which(pop_data$group_id %in% sample_clusters), ])
if_design_svrep <- as.svrepdesign(if_design)
# calibrate with IF from model fully imputed histol
cal_form_full <- ~ iff1 + iff2 - 1
pop_totals_full <- colSums(model.matrix(cal_form_full,
data = pop_data_if))
if_design_cal <- calibrate(if_design, calfun = "raking",
formula = cal_form_full,
population = pop_totals_full)
if_design_svrep_cal <- calibrate(if_design_svrep, calfun = "raking",
formula = cal_form_full,
population = pop_totals_full)
if(sample_model == "svycoxph"){
f1 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design)
f2 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_svrep)
f3 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_cal)
f4 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_svrep_cal)
}
if(sample_model == "svycoxme"){
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
f2 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_svrep)
f3 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_cal)
f4 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_svrep_cal)
}
data.frame(design = rep(c("survey.design", "svyrep.design",
"survey.design", "svyrep.design"),
each = 2),
calibrated = rep(c("no", "yes"), each = 4),
covariate = c(names(coef(f1)),
names(coef(f2)),
names(coef(f3)),
names(coef(f4))),
est = c(coef(f1),
coef(f2),
coef(f3),
coef(f4)),
var = c(diag(vcov(f1)),
diag(vcov(f2)),
diag(vcov(f3)),
diag(vcov(f4))))
}
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
devtools::load_all(".")
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
devtools::load_all(".")
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
survey:::svycoxph.survey.design
devtools::load_all(".")
devtools::load_all(".")
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
library(svycoxme)
one_rep = function(pop_data, n, k, pop_model = "coxph", sample_model = "svycoxph", ...){
sample_clusters = sample.int(n = k, size = n)
dsamp = pop_data[which(pop_data$group_id %in% sample_clusters), ]
# fit imputation model
impmodel1 <- glm(X1~Z1+Z2, data = dsamp, family = gaussian)
impmodel2 <- glm(X2~Z1+Z2, data = dsamp, family = gaussian)
pop_data$impX1 <- predict(impmodel1, newdata = pop_data, type = "response")
pop_data$impX2 <- predict(impmodel2, newdata = pop_data, type = "response")
# fit a model to the population data supplemented with the imputed histology
if(pop_model == "coxph"){
if_full_model <- coxph(Surv(event_time, stat) ~ impX1 + impX2, data = pop_data)
} else if(pop_model == "coxme"){
if_full_model <- coxme::coxme(Surv(event_time, stat) ~ impX1 + impX2 + (1 | group_id),
data = pop_data)
}
# append influence functions to the pop data
# if coxme was used, need to load svycoxme for the residual function coxme.residuals
inffun_full <- resid(if_full_model, data = pop_data, type = "dfbeta") |> as.matrix()
colnames(inffun_full) <- paste0("iff", seq(ncol(inffun_full)))
pop_data_if <- cbind(pop_data, inffun_full)
# design with sample data
if_design <- svydesign(~group_id, ~1, data = pop_data_if[which(pop_data$group_id %in% sample_clusters), ])
if_design_svrep <- as.svrepdesign(if_design)
# calibrate with IF from model fully imputed histol
cal_form_full <- ~ iff1 + iff2 - 1
pop_totals_full <- colSums(model.matrix(cal_form_full,
data = pop_data_if))
if_design_cal <- calibrate(if_design, calfun = "raking",
formula = cal_form_full,
population = pop_totals_full)
if_design_svrep_cal <- calibrate(if_design_svrep, calfun = "raking",
formula = cal_form_full,
population = pop_totals_full)
if(sample_model == "svycoxph"){
f1 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design)
f2 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_svrep)
f3 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_cal)
f4 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_svrep_cal)
}
if(sample_model == "svycoxme"){
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
f2 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_svrep)
f3 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_cal)
f4 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_svrep_cal)
}
data.frame(design = rep(c("survey.design", "svyrep.design",
"survey.design", "svyrep.design"),
each = 2),
calibrated = rep(c("no", "yes"), each = 4),
covariate = c(names(coef(f1)),
names(coef(f2)),
names(coef(f3)),
names(coef(f4))),
est = c(coef(f1),
coef(f2),
coef(f3),
coef(f4)),
var = c(diag(vcov(f1)),
diag(vcov(f2)),
diag(vcov(f3)),
diag(vcov(f4))))
}
set.seed(987)
k = 2000 # clusters
nk = 5 # cluster size
N = nk * k # total obs
# clusters sampled
n = 100
# theta = 0 means a regular cox model without random effects would do fine here.
baserate = 0.5
beta = c(0.5, -0.25)
theta = 1
b = rnorm(k, sd = theta)
Z1 = rnorm(N) # obs level
Z2 = rep(rnorm(k), each = nk)  # cluster level
group_id = rep(1:k, each = nk)
Z1_mean = tapply(Z1, group_id, FUN = mean)
Z2_mean = tapply(Z2, group_id, FUN = mean)
mu_X1 = 0.5 * Z1
mu_X2 = 0.5 * (Z1_mean + Z2_mean)
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.5), each = nk)
rate = baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk))
event_time = rexp(N, rate)
dset = data.frame(event_time, stat = 1, X1, X2, Z1, Z2, group_id)
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
set.seed(9867)
k = 2000 # clusters
nk = 5 # cluster size
N = nk * k # total obs
# clusters sampled
n = 100
# theta = 0 means a regular cox model without random effects would do fine here.
baserate = 0.5
beta = c(0.5, -0.25)
theta = 1
b = rnorm(k, sd = theta)
Z1 = rnorm(N) # obs level
Z2 = rep(rnorm(k), each = nk)  # cluster level
group_id = rep(1:k, each = nk)
Z1_mean = tapply(Z1, group_id, FUN = mean)
Z2_mean = tapply(Z2, group_id, FUN = mean)
mu_X1 = 0.5 * Z1
mu_X2 = 0.5 * (Z1_mean + Z2_mean)
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.5), each = nk)
rate = baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk))
event_time = rexp(N, rate)
dset = data.frame(event_time, stat = 1, X1, X2, Z1, Z2, group_id)
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
set.seed(9867)
k = 2000 # clusters
nk = 5 # cluster size
N = nk * k # total obs
# clusters sampled
n = 100
# theta = 0 means a regular cox model without random effects would do fine here.
baserate = 0.5
beta = c(0.5, -0.25)
theta = 1
b = rnorm(k, sd = theta)
Z1 = rnorm(N) # obs level
Z2 = rep(rnorm(k), each = nk)  # cluster level
group_id = rep(1:k, each = nk)
Z1_mean = tapply(Z1, group_id, FUN = mean)
Z2_mean = tapply(Z2, group_id, FUN = mean)
mu_X1 = 0.5 * Z1
mu_X2 = 0.5 * (Z1_mean + Z2_mean)
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.25), each = nk)
rate = baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk))
event_time = rexp(N, rate)
dset = data.frame(event_time, stat = 1, X1, X2, Z1, Z2, group_id)
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
citation("survey")
citation("survey")
citation("survey")
citation("coxme")
citation("Matrix")
citation("Rcpp")
citation("survival")
citation("survey", bibtex = TRUE)
citation("coxme", bibtex = TRUE)
citation("coxme")
citation("Matrix", bibtex = TRUE)
citation("Matrix")
citation("Rcpp")
print(citation("Rcpp"), bibtex = TRUE)
citation("survey")
citation("coxme")
citation("Matrix")
print(citation("Rcpp"), bibtex = TRUE)
print(citation("survival"), bibtex = TRUE)
citation("survey")
citation("coxme")
citation("Matrix")
print(citation("Rcpp"), bibtex = TRUE)
print(citation("survival"), bibtex = TRUE)
print(citation("survey"), bibtex = TRUE)
vignette("programming")
the_data <- one_dataset(
~ X1 + X2 + X3 + (1 | M),
dists = list(
X1 = ~ rnorm(n),
X2 = ~ rep(rnorm(k), each = nk),
X3 = ~ rep(rbinom(k, 1, 0.5), each = nk),
M = ~ rep(1:k, each = nk)
),
error = ~ rexp(n, 10),
censoring_time = ~ runif(n, max = 0.8),
dist_args = list(k = 20000, nk = 10, n = 200000),
coefficients = c(X1 = 1, X2 = -0.7, X3 = 0.5),
random_effect_variance = c(M = 1)
)
devtools::load_all(".")
the_data <- one_dataset(
~ X1 + X2 + X3 + (1 | M),
dists = list(
X1 = ~ rnorm(n),
X2 = ~ rep(rnorm(k), each = nk),
X3 = ~ rep(rbinom(k, 1, 0.5), each = nk),
M = ~ rep(1:k, each = nk)
),
error = ~ rexp(n, 10),
censoring_time = ~ runif(n, max = 0.8),
dist_args = list(k = 20000, nk = 10, n = 200000),
coefficients = c(X1 = 1, X2 = -0.7, X3 = 0.5),
random_effect_variance = c(M = 1)
)
head(the_data)
head(the_data) |> print(digits = 2)
head(the_data) |> print(digits = 1)
head(the_data) |> print(digits = 2)
head(the_data) |> class()
head(the_data) |> print(digits = 2)
head(the_data) |> sapply(class)
head(the_data) |> print.data.frame(digits = 2)
residuals.coxme
svycoxme:::residuals.coxme
survival:::residuals.coxph
library(svycoxme)
# returns a data.frame with
# X1, X2, X3, Z1, Z2, Z3, event_time, stat
make_dset <- function(theta) {
k = 2000 # clusters
nk = 5 # cluster size
N = nk * k # total obs
# stratified cluster sampling. 20/stratum
n = 100
# theta = 0 means a regular cox model without random effects would do fine here.
baserate = 0.5
# beta = c(0.5, -0.5, 0.5)
beta = c(0.5, -0.5)
b = rnorm(k, sd = theta)
Z1 = rep(rep(1:5, c(700, 600, 400, 200, 100)), each = nk) # strata. observation level
Z2 = rnorm(k)  # cluster level
Z3 = runif(k) # cluster level
group_id = rep(1:k, each = nk)
obs_id = seq(N)
mu_X1 = 0.5 * (Z1 + 1)
mu_X2 = 0.5 * Z2
mu_X3 = Z3
# these all need to be length N
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.25), each = nk)
X3 = rep(rbinom(k, 1, mu_X3), each = nk)
rate = as.vector(baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk)))
event_time = - (log(runif(N)) / rate)
dset = data.frame(event_time, stat = 1,
X1, X2, X3,
Z1,
Z2 = rep(Z2, each = nk),
Z3 = rep(Z3, each = nk),
group_id,
obs_id)
dset
}
dset = make_dset(theta = 0)
dset = make_dset(theta = 0)
dsamp = dset |>
dplyr::group_by(Z1) |>
dplyr::mutate(sampled = group_id %in% sample(unique(group_id), size = 20),
weight = dplyr::n_distinct(group_id)/20,
fpc = dplyr::n_distinct(group_id),
start = 0) |>
dplyr::filter(sampled) |>
dplyr::ungroup() |>
dplyr::mutate(X3 = factor(X3),
rweight = weight/mean(weight))
# fit models, no weights
coxph_fit <- coxph(Surv(event_time, stat) ~ X1 + X2 + X3, data = dsamp, model = TRUE)
coxme_fit <- coxme::coxme(Surv(event_time, stat) ~ X1 + X2 + X3 + (1 | group_id),
data = dsamp,
control = coxme::coxme.control(sparse = c(0, 0)), x = TRUE)
coxph_resid = residuals(coxph_fit, type = "dfbeta")
coxme_resid = residuals(coxme_fit, data = dsamp, type = "dfbeta")
summary(lm(coxph_resid ~ coxme_resid))
# they are almost identical.
plot(coxph_resid[,1], coxme_resid[,1])
plot(coxph_resid[,2], coxme_resid[,2])
plot(coxph_resid[,3], coxme_resid[,3])
colMeans(coxph_resid)
colMeans(coxme_resid)
# However, the linear predictors will be different due to centering in coxph.
plot(coxph_fit$linear.predictors, coxme_fit$linear.predictor)
coxph_fit$means
coxme_fit$means
# if i center the data, and then fit, does that change things?
# these are the same as coxph_fit$means
colMeans(dsamp[, c("X1", "X2")])
dsampc = dplyr::mutate(
.data = dsamp,
X1 = X1 - mean(X1),
X2 = X2 - mean(X2)
)
# fit models, no weights
coxph_fitc <- coxph(Surv(event_time, stat) ~ X1 + X2 + X3, data = dsampc, model = TRUE)
coxme_fitc <- coxme::coxme(Surv(event_time, stat) ~ X1 + X2 + X3 + (1 | group_id),
data = dsampc,
control = coxme::coxme.control(sparse = c(0, 0)), x = TRUE)
coxph_residc = residuals(coxph_fitc, type = "dfbeta")
coxme_residc = residuals(coxme_fitc, data = dsamp, type = "dfbeta")
# the dfbetas don't change with centering.
all.equal(coxph_residc, coxph_resid)
all.equal(coxme_residc, coxme_resid)
# there is still a difference in means for X3, unsurprisingly.
coxph_fitc$means
coxme_fitc$means
# The linear predictors now have close to the same center. Must be some
# impact from the random effects
plot(coxph_fitc$linear.predictors, coxme_fitc$linear.predictor)
summary(lm(coxph_fitc$linear.predictors ~ coxme_fitc$linear.predictor))
mean(coxph_fitc$linear.predictors)
mean(coxme_fitc$linear.predictor)
### Now how does this all change with the addition of weights?
# fit models, with weights
coxph_fitw <- coxph(Surv(event_time, stat) ~ X1 + X2 + X3, data = dsamp, model = TRUE,
weights = rweight)
coxme_fitw <- coxme::coxme(Surv(event_time, stat) ~ X1 + X2 + X3 + (1 | group_id),
data = dsamp, weights = rweight,
control = coxme::coxme.control(sparse = c(0, 0)), x = TRUE)
coxph_residw = residuals(coxph_fitw, type = "dfbeta")
coxme_residw = residuals(coxme_fitw, data = dsamp, type = "dfbeta")
# the dfbetas change, as expected.
all.equal(coxph_residw, coxph_resid)
all.equal(coxme_residw, coxme_resid)
# are they still highly correlated? less so. R-squared of 0.79, down from ~1.
summary(lm(coxph_residw ~ coxme_residw))
library(svycoxme)
one_rep = function(pop_data, n, k, pop_model = "coxph", sample_model = "svycoxph", ...){
sample_clusters = sample.int(n = k, size = n)
dsamp = pop_data[which(pop_data$group_id %in% sample_clusters), ]
# fit imputation model
impmodel1 <- glm(X1~Z1+Z2, data = dsamp, family = gaussian)
impmodel2 <- glm(X2~Z1+Z2, data = dsamp, family = gaussian)
pop_data$impX1 <- predict(impmodel1, newdata = pop_data, type = "response")
pop_data$impX2 <- predict(impmodel2, newdata = pop_data, type = "response")
# fit a model to the population data supplemented with the imputed histology
if(pop_model == "coxph"){
if_full_model <- coxph(Surv(event_time, stat) ~ impX1 + impX2, data = pop_data)
} else if(pop_model == "coxme"){
if_full_model <- coxme::coxme(Surv(event_time, stat) ~ impX1 + impX2 + (1 | group_id),
data = pop_data)
}
# append influence functions to the pop data
# if coxme was used, need to load svycoxme for the residual function coxme.residuals
inffun_full <- resid(if_full_model, data = pop_data, type = "dfbeta") |> as.matrix()
colnames(inffun_full) <- paste0("iff", seq(ncol(inffun_full)))
pop_data_if <- cbind(pop_data, inffun_full)
# design with sample data
if_design <- svydesign(~group_id, ~1, data = pop_data_if[which(pop_data$group_id %in% sample_clusters), ])
if_design_svrep <- as.svrepdesign(if_design)
# calibrate with IF from model fully imputed histol
cal_form_full <- ~ iff1 + iff2 - 1
pop_totals_full <- colSums(model.matrix(cal_form_full,
data = pop_data_if))
if_design_cal <- calibrate(if_design, calfun = "raking",
formula = cal_form_full,
population = pop_totals_full)
if_design_svrep_cal <- calibrate(if_design_svrep, calfun = "raking",
formula = cal_form_full,
population = pop_totals_full)
if(sample_model == "svycoxph"){
f1 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design)
f2 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_svrep)
f3 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_cal)
f4 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_svrep_cal)
}
if(sample_model == "svycoxme"){
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design,
control = coxme::coxme.control(sparse = c(0,0)))
f2 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_svrep,
control = coxme::coxme.control(sparse = c(0,0)))
f3 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_cal,
control = coxme::coxme.control(sparse = c(0,0)))
f4 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id),
design = if_design_svrep_cal,control = coxme::coxme.control(sparse = c(0,0)))
}
data.frame(design = rep(c("survey.design", "svyrep.design",
"survey.design", "svyrep.design"),
each = 2),
calibrated = rep(c("no", "yes"), each = 4),
covariate = c(names(coef(f1)),
names(coef(f2)),
names(coef(f3)),
names(coef(f4))),
est = c(coef(f1),
coef(f2),
coef(f3),
coef(f4)),
var = c(diag(vcov(f1)),
diag(vcov(f2)),
diag(vcov(f3)),
diag(vcov(f4))))
}
set.seed(9867)
k = 2000 # clusters
nk = 5 # cluster size
N = nk * k # total obs
# clusters sampled
n = 100
# theta = 0 means a regular cox model without random effects would do fine here.
baserate = 0.5
beta = c(0.5, -0.25)
theta = 1
b = rnorm(k, sd = theta)
Z1 = rnorm(N) # obs level
Z2 = rep(rnorm(k), each = nk)  # cluster level
group_id = rep(1:k, each = nk)
Z1_mean = tapply(Z1, group_id, FUN = mean)
Z2_mean = tapply(Z2, group_id, FUN = mean)
mu_X1 = 0.5 * Z1
mu_X2 = 0.5 * (Z1_mean + Z2_mean)
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.25), each = nk)
rate = baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk))
event_time = rexp(N, rate)
dset = data.frame(event_time, stat = 1, X1, X2, Z1, Z2, group_id)
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
res = one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
res |>
dplyr::arrange(covariate, design, calibrated) |>
dplyr::select(-est) |>
tidyr::pivot_wider(names_from = "calibrated", values_from = "var") |>
dplyr::mutate(var_change = yes - no)
