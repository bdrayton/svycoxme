residuals.coxme(coxmefit, data = dset),
times = 10
)
# test timing of new function.
n = 100000
X = data.frame(X1 = rnorm(n),
X2 = rnorm(n),
M = rep(c(0,1), each = n/2),
id = seq_len(n))
dset = draw_event_times(formula = Surv(start_time, stop_time, status) ~ X1 + X2 + (1 | M),
data = X,
coefficients = c(X1 = 1, X2 = 0.5),
random_effect_variance = c(M = 0),
id = id,
baseline_hazard = 1,
event = "single")
dset = dplyr::left_join(dset, dplyr::select(X, id, M), by = dplyr::join_by(id))
coxmefit = coxme::coxme(Surv(start_time, stop_time, status) ~ X1 + X2 + (1 | M),
data = dset, x = TRUE, y = TRUE, ties = "breslow")
microbenchmark::microbenchmark(
residuals.coxme(coxmefit, data = dset),
times = 10
)
microbenchmark::microbenchmark(
residuals.coxme(coxmefit, data = dset),
times = 10
)
devtools::load_all(".")
library(survey)
library(svycoxme)
devtools::load_all(".")
library(survey)
k = 2000 # clusters
nk = 5 # cluster size
N = nk * k # total obs
# clusters sampled
n = 100
baserate = 0.5
beta = c(0.5, -0.25)
theta = 0
b = rnorm(k, sd = theta)
Z1 = rnorm(N) # obs level
Z2 = rep(rnorm(k), each = nk)  # cluster level
group_id = rep(1:k, each = nk)
Z1_mean = tapply(Z1, group_id, FUN = mean)
Z2_mean = tapply(Z2, group_id, FUN = mean)
mu_X1 = 0.5 * Z1
mu_X2 = 0.5 * (Z1_mean + Z2_mean)
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.5), each = nk)
rate = baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk))
event_time = rexp(N, rate)
dset = data.frame(event_time, stat = 1, X1, X2, Z1, Z2, group_id)
sample_clusters = sample.int(n = k, size = n)
dsamp = pop_data[which(pop_data$group_id %in% sample_clusters), ]
dsamp = dset[which(dset$group_id %in% sample_clusters), ]
if_design <- svydesign(~group_id, ~1, data = dsamp)
if_design <- svydesign(~group_id, ~1, data = dsamp)
if_design_svrep <- as.svrepdesign(if_design)
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
debugonce(svycoxme)
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
debugonce(residuals.coxme)
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
debugonce(residuals.coxme)
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
form
response
Zt
t(Zt)
Matrix::t(Zt)
devtools::load_all(".")
exit
devtools::load_all(".")
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
f1
class(f1)
summary(f1)
if_design_svrep <- as.svrepdesign(if_design)
f2 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_svrep)
f2
summary(f2)
summary(f1)
getwd()
devtools::install()
getwd
getwd()
devtools::install()
load("C:/Users/bdra011/OneDrive - The University of Auckland/PhD/outputs/scratchpads and notes/.RData")
devtools::load_all(".")
inffun_full2 <- resid(if_full_model2, data = dset2, type = "dfbeta") |> as.matrix()
library(survival)
inffun_full2 <- resid(if_full_model2, data = dset2, type = "dfbeta") |> as.matrix()
dim(inffun_full2)
# that aint right.
plot(inffun_full1[,1], inffun_full2[,1])
library(survey)
myTryCatch <- function(expr) {
warn <- err <- NULL
value <- withCallingHandlers(
tryCatch(expr, error=function(e) {
err <<- e
NULL
}), warning=function(w) {
warn <<- w
invokeRestart("muffleWarning")
})
#drop call from error
err$call <- NULL
list(value=value, warning=warn, error=err)
}
try_one_rep <- function(...){
if(!exists(".Random.seed")) invisible(rnorm(1))
stream <- .Random.seed
r <- myTryCatch(one_rep(... = ...))
attr(r, "stream") <- stream
r
}
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxph")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
cores = parallel::detectCores() - 1
cl <- parallel::makeCluster(cores)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("one_rep", "try_one_rep", "myTryCatch"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl, iseed = 10)
all_fits <- parallel::parLapply(cl, 1:500, try_one_rep, pop_data = dset, n = n, k = k,
pop_model = "coxme", sample_model = "svycoxph")
#stop the cluster
parallel::stopCluster(cl)
values = lapply(all_fits, "[[", "value")
all_fits[[1]]$error
# would need to exclude any nulls (they're fits with errors)
table(sapply(values, is.null))
# make the list of results a data.frame
res_df = plyr::ldply(values, function(df){df})
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
library(tidyverse)
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
# that aint right.
plot(inffun_full1[,1], inffun_full2[,1])
plot(inffun_full1[,2], inffun_full2[,2])
# is this a sort issue? Yes.
plot(sort(inffun_full1[,1]), sort(inffun_full2[,1]))
if_full_model1 <- coxph(Surv(event_time, stat) ~ impX1 + impX2, data = dset2)
if_full_model2 <- coxme(Surv(event_time, stat) ~ impX1 + impX2 + (1 | group_id),
data = dset2)
# centered!
lp1 = if_full_model1$linear.predictors
# centered? Yes.
lp2 = if_full_model2$linear.predictor
plot(lp1, lp2)
lm(lp1 ~ lp2) |> summary()
# compare the estimated coefs. Close, but different.
cbind(coxph = coef(if_full_model1),
coxme = coef(if_full_model2))
inffun_full1 <- resid(if_full_model1, data = pop_data, type = "dfbeta") |> as.matrix()
inffun_full1 <- resid(if_full_model1, data = dset2, type = "dfbeta") |> as.matrix()
inffun_full2 <- resid(if_full_model2, data = dset2, type = "dfbeta") |> as.matrix()
dim(inffun_full2)
# that aint right.
plot(inffun_full1[,1], inffun_full2[,1])
lm(inffun_full1[,1] ~ inffun_full2[,1]) |> summary()
# is this a sort issue? not anymore.
plot(sort(inffun_full1[,1]), sort(inffun_full2[,1]))
lm(inffun_full1[,1] ~ inffun_full2[,1]) |> summary()
# is this a sort issue? not anymore.
plot(sort(inffun_full1[,1]), sort(inffun_full2[,1]))
library(svycoxme)
library(survey)
library(svycoxme)
myTryCatch <- function(expr) {
warn <- err <- NULL
value <- withCallingHandlers(
tryCatch(expr, error=function(e) {
err <<- e
NULL
}), warning=function(w) {
warn <<- w
invokeRestart("muffleWarning")
})
#drop call from error
err$call <- NULL
list(value=value, warning=warn, error=err)
}
try_one_rep <- function(...){
if(!exists(".Random.seed")) invisible(rnorm(1))
stream <- .Random.seed
r <- myTryCatch(one_rep(... = ...))
attr(r, "stream") <- stream
r
}
set.seed(987)
k = 2000 # clusters
nk = 5 # cluster size
N = nk * k # total obs
# clusters sampled
n = 100
# theta = 0 means a regular cox model without random effects would do fine here.
baserate = 0.5
beta = c(0.5, -0.25)
theta = 0
b = rnorm(k, sd = theta)
Z1 = rnorm(N) # obs level
Z2 = rep(rnorm(k), each = nk)  # cluster level
group_id = rep(1:k, each = nk)
Z1_mean = tapply(Z1, group_id, FUN = mean)
Z2_mean = tapply(Z2, group_id, FUN = mean)
mu_X1 = 0.5 * Z1
mu_X2 = 0.5 * (Z1_mean + Z2_mean)
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.5), each = nk)
rate = baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk))
event_time = rexp(N, rate)
dset = data.frame(event_time, stat = 1, X1, X2, Z1, Z2, group_id)
one_rep = function(pop_data, n, k, pop_model = "coxph", sample_model = "svycoxph", ...){
require(survey)
require(svycoxme)
require(coxme)
sample_clusters = sample.int(n = k, size = n)
dsamp = pop_data[which(pop_data$group_id %in% sample_clusters), ]
# fit imputation model
impmodel1 <- glm(X1~Z1+Z2, data = dsamp, family = gaussian)
impmodel2 <- glm(X2~Z1+Z2, data = dsamp, family = gaussian)
pop_data$impX1 <- predict(impmodel1, newdata = pop_data, type = "response")
pop_data$impX2 <- predict(impmodel2, newdata = pop_data, type = "response")
# fit a model to the population data supplemented with the imputed histology
if(pop_model == "coxph"){
if_full_model <- coxph(Surv(event_time, stat) ~ impX1 + impX2, data = pop_data)
} else if(pop_model == "coxme"){
if_full_model <- coxme(Surv(event_time, stat) ~ impX1 + impX2 + (1 | group_id),
data = pop_data)
}
# append influence functions to the pop data
# if coxme was used, need to load svycoxme for the residual function coxme.residuals
inffun_full <- resid(if_full_model, data = pop_data, type = "dfbeta") |> as.matrix()
colnames(inffun_full) <- paste0("iff", seq(ncol(inffun_full)))
pop_data_if <- cbind(pop_data, inffun_full)
# design with sample data
if_design <- svydesign(~group_id, ~1, data = pop_data_if[which(pop_data$group_id %in% sample_clusters), ])
if_design_svrep <- as.svrepdesign(if_design)
# calibrate with IF from model fully imputed histol
cal_form_full <- ~ iff1 + iff2 - 1
pop_totals_full <- colSums(model.matrix(cal_form_full,
data = pop_data_if))
if_design_cal <- calibrate(if_design, calfun = "raking",
formula = cal_form_full,
population = pop_totals_full)
if_design_svrep_cal <- calibrate(if_design_svrep, calfun = "raking",
formula = cal_form_full,
population = pop_totals_full)
if(sample_model == "svycoxph"){
f1 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design)
f2 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_svrep)
f3 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_cal)
f4 <- svycoxph(Surv(event_time, stat) ~ X1 + X2, design = if_design_svrep_cal)
}
if(sample_model == "svycoxme"){
f1 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design)
f2 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_svrep)
f3 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_cal)
f4 <- svycoxme(Surv(event_time, stat) ~ X1 + X2 + (1 | group_id), design = if_design_svrep_cal)
}
data.frame(design = rep(c("survey.design", "svyrep.design",
"survey.design", "svyrep.design"),
each = 2),
calibrated = rep(c("no", "yes"), each = 4),
covariate = c(names(coef(f1)),
names(coef(f2)),
names(coef(f3)),
names(coef(f4))),
est = c(coef(f1),
coef(f2),
coef(f3),
coef(f4)),
var = c(diag(vcov(f1)),
diag(vcov(f2)),
diag(vcov(f3)),
diag(vcov(f4))))
}
one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxph")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
cores = parallel::detectCores() - 1
cl <- parallel::makeCluster(cores)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("one_rep", "try_one_rep", "myTryCatch"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl, iseed = 10)
all_fits <- parallel::parLapply(cl, 1:500, try_one_rep, pop_data = dset, n = n, k = k,
pop_model = "coxme", sample_model = "svycoxph")
#stop the cluster
parallel::stopCluster(cl)
values = lapply(all_fits, "[[", "value")
all_fits[[1]]$error
# would need to exclude any nulls (they're fits with errors)
table(sapply(values, is.null))
# make the list of results a data.frame
res_df = plyr::ldply(values, function(df){df})
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
library(tidyverse)
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
cairo_pdf(file = "C:/Users/bdra011/Dropbox (Uni of Auckland)/Apps/Overleaf/Thesis/images/cal_var_2.pdf")
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
dev.off()
cores = parallel::detectCores() - 1
cl <- parallel::makeCluster(cores)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("one_rep", "try_one_rep", "myTryCatch"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl, iseed = 10)
all_fits <- parallel::parLapply(cl, 1:500, try_one_rep, pop_data = dset, n = n, k = k,
pop_model = "coxph", sample_model = "svycoxph")
#stop the cluster
parallel::stopCluster(cl)
values = lapply(all_fits, "[[", "value")
all_fits[[1]]$error
# would need to exclude any nulls (they're fits with errors)
table(sapply(values, is.null))
# make the list of results a data.frame
res_df = plyr::ldply(values, function(df){df})
library(tidyverse)
cairo_pdf(file = "C:/Users/bdra011/Dropbox (Uni of Auckland)/Apps/Overleaf/Thesis/images/cal_var_1.pdf")
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
dev.off()
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
cores = parallel::detectCores() - 1
cl <- parallel::makeCluster(cores)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("one_rep", "try_one_rep", "myTryCatch"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl, iseed = 10)
all_fits <- parallel::parLapply(cl, 1:500, try_one_rep, pop_data = dset, n = n, k = k,
pop_model = "coxme", sample_model = "svycoxme")
#stop the cluster
parallel::stopCluster(cl)
values = lapply(all_fits, "[[", "value")
all_fits[[1]]$error
# would need to exclude any nulls (they're fits with errors)
table(sapply(values, is.null))
# make the list of results a data.frame
res_df = plyr::ldply(values, function(df){df})
library(tidyverse)
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
cairo_pdf(file = "C:/Users/bdra011/Dropbox (Uni of Auckland)/Apps/Overleaf/Thesis/images/cal_var_3.pdf")
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
dev.off()
set.seed(987)
k = 2000 # clusters
nk = 5 # cluster size
N = nk * k # total obs
# clusters sampled
n = 100
# theta = 0 means a regular cox model without random effects would do fine here.
baserate = 0.5
beta = c(0.5, -0.25)
theta = 1
b = rnorm(k, sd = theta)
Z1 = rnorm(N) # obs level
Z2 = rep(rnorm(k), each = nk)  # cluster level
group_id = rep(1:k, each = nk)
Z1_mean = tapply(Z1, group_id, FUN = mean)
Z2_mean = tapply(Z2, group_id, FUN = mean)
mu_X1 = 0.5 * Z1
mu_X2 = 0.5 * (Z1_mean + Z2_mean)
X1 = rnorm(N, mean = mu_X1, sd = 0.25)
X2 = rep(rnorm(k, mean = mu_X2, sd = 0.5), each = nk)
rate = baserate * exp(cbind(X1, X2)%*% matrix(beta) + rep(b, each = nk))
event_time = rexp(N, rate)
dset = data.frame(event_time, stat = 1, X1, X2, Z1, Z2, group_id)
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
cores = parallel::detectCores() - 1
cl <- parallel::makeCluster(cores)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("one_rep", "try_one_rep", "myTryCatch"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl, iseed = 10)
all_fits <- parallel::parLapply(cl, 1:500, try_one_rep, pop_data = dset, n = n, k = k,
pop_model = "coxme", sample_model = "svycoxme")
#stop the cluster
parallel::stopCluster(cl)
values = lapply(all_fits, "[[", "value")
all_fits[[1]]$error
# would need to exclude any nulls (they're fits with errors)
table(sapply(values, is.null))
# make the list of results a data.frame
res_df = plyr::ldply(values, function(df){df})
library(tidyverse)
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
cairo_pdf(file = "C:/Users/bdra011/Dropbox (Uni of Auckland)/Apps/Overleaf/Thesis/images/cal_var_4.pdf")
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed) +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
dev.off()
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed, scales = "free") +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
cairo_pdf(file = "C:/Users/bdra011/Dropbox (Uni of Auckland)/Apps/Overleaf/Thesis/images/cal_var_4.pdf")
res_df %>%
mutate(covariate = factor(covariate, levels = c("X1", "X2"),
labels = c(bquote(beta[1]), bquote(beta[2])))) %>%
ggplot(aes(var, colour = design, linetype = calibrated)) +
facet_grid(cols = vars(covariate), labeller = label_parsed, scales = "free") +
labs(x = "Estimated variance", colour = "Design", linetype = "Calibrated") +
geom_density() + theme_bw()
dev.off()
debugonce(one_rep)
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxph")
# one_rep(dset, n = n, k = k, pop_model = "coxph", sample_model = "svycoxme")
one_rep(dset, n = n, k = k, pop_model = "coxme", sample_model = "svycoxme")
coxme::ranef(if_full_model)
coxme::ranef(if_full_model) |> unlist()
coxme::ranef(f1) |> unlist()
coxme::VarCorr(f1)
coxme::VarCorr(f1)|> unlist()
vignette("rd-other")
?svycoxme
devtools::load_all(".")
devtools::load_all(".")
library(svycoxme)
?svyc
?svycoxme
?svycoxme:::svycontrast.svycoxme
survival:::Cagscore3
?survival:::Cagscore3
library(svycoxme)
library(svycoxme)
?print
?survey:::print
?survey:::print.anova.svyloglin
library(svycoxme)
library(svycoxme)
library(svycoxme)
usethis::use_vignette("svycoxme")
library(svycoxme)
