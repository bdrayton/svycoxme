shape_res(non_error_fits[[1]])
shape_res <- function(one_fit){
tibble::tibble(
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
sample_size = one_fit$specs$sample_size,
timing = difftime(one_fit$timings$end, one_fit$timings$start, units = "secs")
)
}
shape_res(non_error_fits[[1]])
non_error_fits[[1]]
shape_res <- function(one_fit){
tibble::tibble(
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
sample_size = one_fit$specs$sample_size,
timing = difftime(one_fit$timings$end, one_fit$timings$start, units = "secs")
)
}
shape_res(non_error_fits[[1]])
non_error_fits[[1]]
debug(shape_res)
shape_res(non_error_fits[[1]])
one_fit$specs$n_clusters_in_sample
one_fit$specs$cluster_size
shape_res <- function(one_fit){
r <- tibble::tibble(
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
sample_size = one_fit$specs$sample_size,
timing = difftime(one_fit$timings$end, one_fit$timings$start, units = "secs")
)
return(r)
}
shape_res(non_error_fits[[1]])
debug(shape_res)
shape_res(non_error_fits[[1]])
timing = difftime(one_fit$timings$end, one_fit$timings$start, units = "secs")
difftime(one_fit$timings$end, one_fit$timings$start, units = "secs")
one_fit$timings$start
one_fit$timings
one_fit
shape_res <- function(one_fit){
r <- tibble::tibble(
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
sample_size = one_fit$specs$sample_size,
timing = difftime(one_fit$timing$end, one_fit$timing$start, units = "secs")
)
return(r)
}
shape_res(non_error_fits[[1]])
df <- plyr::ldply(non_error_fits, shape_res)
plot(density(df$timing))
plot(density(as.numeric(df$timing)))
hist(as.numeric(df$timing))
df %>% ggplot(aes(n_clusters_in_sample, timing)) + geom_histogram() +
facet_grid(rows = vars(sample_size), cols = vars(theta))
df %>% ggplot(aes(n_clusters_in_sample, as.numeric(timing))) + geom_histogram() +
facet_grid(rows = vars(sample_size), cols = vars(theta))
df %>% ggplot(aes(as.numeric(timing))) + geom_histogram() +
facet_grid(rows = vars(n_clusters_in_sample, sample_size), cols = vars(theta))
error_messages
res[[4]]
error_fits <- res[is.error]
error_fits
plyr::ldply(error_fits, function(one_fit){
attr(one_fit, "specs")
})
error_spects <- plyr::ldply(error_fits, function(one_fit){
attr(one_fit, "specs")
})
table(error_specs$n_clusters_in_sample)
error_specs <- plyr::ldply(error_fits, function(one_fit){
attr(one_fit, "specs")
})
table(error_specs$n_clusters_in_sample)
total_time
# about 55 minutes per rep.
# average of 12.2 seconds per rep, because of parallel processing.
total_time*100
# about 55 minutes per rep.
# average of 12.2 seconds per rep, because of parallel processing.
total_time*100/60
results_path <- file.path(Sys.getenv("OneDriveCommercial"), "PhD/outputs/simulations/data/svycoxme_variances_10.rds")
res <- readr::read_rds(results_path)
attributes(res)
timings <- attr(res, "times")
(total_time = difftime(timings$end, timings$start, units = "min"))
results_path <- file.path(Sys.getenv("OneDriveCommercial"), "PhD/outputs/simulations/data/svycoxme_variances_10.rds")
res <- readr::read_rds(results_path)
attributes(res)
timings <- attr(res, "times")
(total_time = difftime(timings$end, timings$start, units = "min"))
# about 55 minutes per rep.
# average of 12.2 seconds per rep, because of parallel processing.
total_time
error_messages <- lapply(res, "[[", "error")
warning_messages <- lapply(res, "[[", "warning")
returned_values <- lapply(res, "[[", "value")
is.error <- sapply(error_messages, inherits, "error")
is.warning <- sapply(warning_messages, inherits, "warning")
table(is.error) |> prop.table()
table(is.warning)
results_with_warnings <- res[is.warning]
non_error_fits <- returned_values[!is.error]
non_error_fits[[1]]
shape_res <- function(one_fit){
r <- tibble::tibble(
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
sample_size = one_fit$specs$sample_size,
timing = difftime(one_fit$timing$end, one_fit$timing$start, units = "secs")
)
return(r)
}
shape_res(non_error_fits[[1]])
df <- plyr::ldply(non_error_fits, shape_res)
df %>% ggplot(aes(as.numeric(timing))) + geom_histogram() +
facet_grid(rows = vars(n_clusters_in_sample, sample_size), cols = vars(theta))
library(tidyverse)
df %>% ggplot(aes(as.numeric(timing))) + geom_histogram() +
facet_grid(rows = vars(n_clusters_in_sample, sample_size), cols = vars(theta))
df %>%
group_by(theta, sample_size, n_clusters_in_sample) %>%
summarise(summary(timing))
df %>%
group_by(theta, sample_size, n_clusters_in_sample) %>%
summarise(mean(timing),
min(timing),
max(timing),
median(timing),
quantile(timing, 0.25),
quantile(timing, 0.75))
df %>%
group_by(theta, sample_size, n_clusters_in_sample) %>%
summarise(mean = mean(timing),
min = min(timing),
max = max(timing),
median = median(timing),
q25 = quantile(timing, 0.25),
q75 = quantile(timing, 0.75)) %>%
mutate(across(vars(mean, min, max, median, q25, q75), ~round(.x, 2)))
df %>%
group_by(theta, sample_size, n_clusters_in_sample) %>%
summarise(mean = mean(timing),
min = min(timing),
max = max(timing),
median = median(timing),
q25 = quantile(timing, 0.25),
q75 = quantile(timing, 0.75)) %>%
mutate(across(c(mean, min, max, median, q25, q75), ~round(.x, 2)))
error_messages
unlist(error_messages)
error_messages_vec <- unlist(error_messages)
table(error_messages_vec)
error_messages_vec <- gsub("(system_is_computationally singular).*", "\\1", error_messages_vec)
table(error_messages_vec)
error_messages_vec <- unlist(error_messages)
error_messages_vec <- gsub("(system_is_computationally singular).*", "\\1", error_messages_vec)
table(error_messages_vec)
error_messages_vec <- gsub("(system is computationally singular).*", "\\1", error_messages_vec)
table(error_messages_vec)
error_fits <- res[is.error]
error_specs <- plyr::ldply(error_fits, function(one_fit){
attr(one_fit, "specs")
})
table(error_specs$n_clusters_in_sample)
table(error_specs$n_clusters_in_sample, error_specs$cluster_size)
table(error_specs$n_clusters_in_sample, error_specs$cluster_size, error_specs$theta)
table(error_specs$n_clusters_in_sample, error_specs$sample_size, error_specs$theta)
nrow(error_specs)
length(error_messages_vec)
error_specs$message = error_messages_vec
error_specs %>%
group_by(theta, n_clusters_in_sample, sample_size) %>%
count(message)
error_specs %>%
group_by(n_clusters_in_sample, sample_size, theta) %>%
count(message) %>%
print(rows = 1000)
error_specs %>%
group_by(n_clusters_in_sample, sample_size, theta) %>%
count(message) %>%
print(n = 1000)
head(error_messages_vec)
res[[5]]
devtools::load_all(".")
# set to and 20 for the real run.
# run just a few for each parameter combination.
# sim_combos_n <- 30000
cores <- 20
sims_per_combo <- 500
# these are the parameter combinations
true_coefs = c(X1 = 1, X2 = -0.7, X3 = 0.5, Z1 = 1)
param_combos <-
expand.grid(sample_size = c(500, 2000),
n_clusters_in_sample = c(20, 100, 250),
n_clusters = 5000,
theta = c(0.0001, 0.5, 1)) %>%
dplyr::mutate(cluster_size = sample_size/n_clusters_in_sample,
int_part = as.integer(cluster_size),
decimal_part = cluster_size - int_part) %>%
dplyr::arrange(theta, int_part, decimal_part) %>%
dplyr::group_by(theta, sample_size, int_part) %>%
dplyr::filter(dplyr::row_number() == 1) %>%
dplyr::select(n_clusters, theta, n_clusters_in_sample, cluster_size = int_part, sample_size) %>%
dplyr::ungroup() %>% data.frame()
param_combos_list <- split(param_combos, f = seq(nrow(param_combos)))
param_combos_list <- rep(param_combos_list,sims_per_combo)
# define one rep
one_rep <- function(specs){
one_rep_start <- Sys.time()
# generate a population, sample from it, calculate the things.
# generate population
k <- specs$n_clusters
nk <- specs$cluster_size
the_data <- one_dataset(~X1 + X2 + X3 + Z1 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
Z1 = ~rep(rbinom(k, 1, 0.25), each = nk),
M = ~rep(1:k, each = nk)),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = true_coefs,
random_effect_variance = c(M=specs$theta)
)
pop <- dplyr::mutate(the_data, id = M)
# sample clusters based on Z
# take half from Z = 0 and half from Z = 1
Z1pop = pop[pop$Z1 == 1, ]
Z0pop = pop[pop$Z1 == 0, ]
samp_cluster_ids = c(unique(Z1pop$id)[sample.int(nrow(Z1pop), specs$n_clusters_in_samp/2)],
unique(Z0pop$id)[sample.int(nrow(Z0pop), specs$n_clusters_in_samp/2)])
my_samp <- pop[pop$id %in% samp_cluster_ids, ]
my_samp$prob = double(nrow(my_samp))
my_samp[my_samp$Z1 == 1, "prob"] =   (specs$n_clusters_in_samp/2)/nrow(Z1pop)
my_samp[my_samp$Z1 == 0, "prob"] =   (specs$n_clusters_in_samp/2)/nrow(Z0pop)
my_samp$weights <- my_samp$prob^-1
# rescale_weights
my_samp$rweights <- (1/my_samp$prob)/mean(1/my_samp$prob)
my_samp <- my_samp[order(my_samp$stat_time), ]
# for memory reasons
rm(list = c('pop', 'Z1pop', 'Z0pop', 'the_data'))
coxme_fit <- coxme::coxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
data = my_samp, weights = rweights, control = coxme::coxme.control(sparse = c(0, 0)))
# define design, add ui
my_des <- svydesign(~id, weights = ~weights, data = my_samp, strata = ~Z1)
my_des_jackknife <- as.svrepdesign(my_des, type = "JKn")
my_des_bootstrap <- as.svrepdesign(my_des, type = "bootstrap", replicates = 50)
svycoxme_fit <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des,
control = coxme::coxme.control(sparse = c(0, 0)))
svycoxme_fit_jackknife <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des_jackknife,
control = coxme::coxme.control(sparse = c(0, 0)))
svycoxme_fit_bootstrap <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des_bootstrap,
control = coxme::coxme.control(sparse = c(0, 0)))
list(
specs = specs,
svycoxme_var = diag(vcov(svycoxme_fit)),
svycoxme_var_jackknife = diag(vcov(svycoxme_fit_jackknife)),
svycoxme_var_bootstrap = diag(vcov(svycoxme_fit_bootstrap)),
fisher_var_unweighted = diag(vcov(coxme_fit)),
coefs = coef(coxme_fit),
timing = list(start = one_rep_start, end = Sys.time()))
}
# see: https://stackoverflow.com/questions/4948361/how-do-i-save-warnings-and-errors-as-output-from-a-function
myTryCatch <- function(expr) {
warn <- err <- NULL
value <- withCallingHandlers(
tryCatch(expr, error=function(e) {
err <<- e
NULL
}), warning=function(w) {
warn <<- w
invokeRestart("muffleWarning")
})
#drop call from error
err$call <- NULL
list(value=value, warning=warn, error=err)
}
try_one_rep <- function(specs){
stream <- .Random.seed
r <- myTryCatch(one_rep(specs))
attr(r, "stream") <- stream
attr(r, "specs") <- specs
r
}
results_path <- file.path(Sys.getenv("OneDriveCommercial"), "PhD/outputs/simulations/data/svycoxme_variances_10.rds")
res <- readr::read_rds(results_path)
rnorm(1)
assign_streams
attr(res[5], "stream")
attr(res[[5]], "stream")
assign(".Random.seed", attr(res[[5]], "stream"), envir = .GlobalEnv)
debugonce(one_rep)
try_one_rep(specs = param_combos_list[[5]])
samp_cluster_ids = c(unique(Z1pop$id)[sample.int(nrow(Z1pop), specs$n_clusters_in_samp/2)],
unique(Z0pop$id)[sample.int(nrow(Z0pop), specs$n_clusters_in_samp/2)])
my_samp <- pop[pop$id %in% samp_cluster_ids, ]
double(nrow(my_samp))
my_samp
my_samp$prob = double(nrow(my_samp))
my_samp[my_samp$Z1 == 1, "prob"] =   (specs$n_clusters_in_samp/2)/nrow(Z1pop)
my_samp[my_samp$Z1 == 0, "prob"] =   (specs$n_clusters_in_samp/2)/nrow(Z0pop)
my_samp$weights <- my_samp$prob^-1
# rescale_weights
my_samp$rweights <- (1/my_samp$prob)/mean(1/my_samp$prob)
my_samp <- my_samp[order(my_samp$stat_time), ]
# for memory reasons
rm(list = c('pop', 'Z1pop', 'Z0pop', 'the_data'))
coxme_fit <- coxme::coxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
data = my_samp, weights = rweights, control = coxme::coxme.control(sparse = c(0, 0)))
assign(".Random.seed", attr(res[[5]], "stream"), envir = .GlobalEnv)
debugonce(one_rep)
try_one_rep(specs = param_combos_list[[5]])
specs
20 * 25
sample.int(nrow(Z1pop), specs$n_clusters_in_samp/2)
sample.int(nrow(Z0pop), specs$n_clusters_in_samp/2)
# define one rep
one_rep <- function(specs){
one_rep_start <- Sys.time()
# generate a population, sample from it, calculate the things.
# generate population
k <- specs$n_clusters
nk <- specs$cluster_size
the_data <- one_dataset(~X1 + X2 + X3 + Z1 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
Z1 = ~rep(rbinom(k, 1, 0.25), each = nk),
M = ~rep(1:k, each = nk)),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = true_coefs,
random_effect_variance = c(M=specs$theta)
)
pop <- dplyr::mutate(the_data, id = M)
# sample clusters based on Z
# take half from Z = 0 and half from Z = 1
Z1pop_ids = unique(Z1pop$id)
Z0pop_ids = unique(Z0pop$id)
samp_cluster_ids = c(Z1pop_ids[sample.int(length(Z1pop_ids), specs$n_clusters_in_samp/2)],
Z0pop_ids[sample.int(length(Z0pop_ids), specs$n_clusters_in_samp/2)])
my_samp <- pop[pop$id %in% samp_cluster_ids, ]
my_samp$prob = double(nrow(my_samp))
my_samp[my_samp$Z1 == 1, "prob"] =   (specs$n_clusters_in_samp/2)/nrow(Z1pop)
my_samp[my_samp$Z1 == 0, "prob"] =   (specs$n_clusters_in_samp/2)/nrow(Z0pop)
my_samp$weights <- my_samp$prob^-1
# rescale_weights
my_samp$rweights <- (1/my_samp$prob)/mean(1/my_samp$prob)
my_samp <- my_samp[order(my_samp$stat_time), ]
# for memory reasons
rm(list = c('pop', 'Z1pop', 'Z0pop', 'the_data'))
coxme_fit <- coxme::coxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
data = my_samp, weights = rweights, control = coxme::coxme.control(sparse = c(0, 0)))
# define design, add ui
my_des <- svydesign(~id, weights = ~weights, data = my_samp, strata = ~Z1)
my_des_jackknife <- as.svrepdesign(my_des, type = "JKn")
my_des_bootstrap <- as.svrepdesign(my_des, type = "bootstrap", replicates = 50)
svycoxme_fit <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des,
control = coxme::coxme.control(sparse = c(0, 0)))
svycoxme_fit_jackknife <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des_jackknife,
control = coxme::coxme.control(sparse = c(0, 0)))
svycoxme_fit_bootstrap <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des_bootstrap,
control = coxme::coxme.control(sparse = c(0, 0)))
list(
specs = specs,
svycoxme_var = diag(vcov(svycoxme_fit)),
svycoxme_var_jackknife = diag(vcov(svycoxme_fit_jackknife)),
svycoxme_var_bootstrap = diag(vcov(svycoxme_fit_bootstrap)),
fisher_var_unweighted = diag(vcov(coxme_fit)),
coefs = coef(coxme_fit),
timing = list(start = one_rep_start, end = Sys.time()))
}
# see: https://stackoverflow.com/questions/4948361/how-do-i-save-warnings-and-errors-as-output-from-a-function
myTryCatch <- function(expr) {
warn <- err <- NULL
value <- withCallingHandlers(
tryCatch(expr, error=function(e) {
err <<- e
NULL
}), warning=function(w) {
warn <<- w
invokeRestart("muffleWarning")
})
#drop call from error
err$call <- NULL
list(value=value, warning=warn, error=err)
}
try_one_rep <- function(specs){
stream <- .Random.seed
r <- myTryCatch(one_rep(specs))
attr(r, "stream") <- stream
attr(r, "specs") <- specs
r
}
results_path <- file.path(Sys.getenv("OneDriveCommercial"), "PhD/outputs/simulations/data/svycoxme_variances_10.rds")
res <- readr::read_rds(results_path)
rnorm(1)
assign(".Random.seed", attr(res[[5]], "stream"), envir = .GlobalEnv)
try_one_rep(specs = param_combos_list[[5]])
# define one rep
one_rep <- function(specs){
one_rep_start <- Sys.time()
# generate a population, sample from it, calculate the things.
# generate population
k <- specs$n_clusters
nk <- specs$cluster_size
the_data <- one_dataset(~X1 + X2 + X3 + Z1 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
Z1 = ~rep(rbinom(k, 1, 0.25), each = nk),
M = ~rep(1:k, each = nk)),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = true_coefs,
random_effect_variance = c(M=specs$theta)
)
pop <- dplyr::mutate(the_data, id = M)
# sample clusters based on Z
# take half from Z = 0 and half from Z = 1
Z1pop = pop[pop$Z1 == 1, ]
Z0pop = pop[pop$Z1 == 0, ]
Z1pop_ids = unique(Z1pop$id)
Z0pop_ids = unique(Z0pop$id)
samp_cluster_ids = c(Z1pop_ids[sample.int(length(Z1pop_ids), specs$n_clusters_in_samp/2)],
Z0pop_ids[sample.int(length(Z0pop_ids), specs$n_clusters_in_samp/2)])
my_samp <- pop[pop$id %in% samp_cluster_ids, ]
my_samp$prob = double(nrow(my_samp))
my_samp[my_samp$Z1 == 1, "prob"] =   (specs$n_clusters_in_samp/2)/nrow(Z1pop)
my_samp[my_samp$Z1 == 0, "prob"] =   (specs$n_clusters_in_samp/2)/nrow(Z0pop)
my_samp$weights <- my_samp$prob^-1
# rescale_weights
my_samp$rweights <- (1/my_samp$prob)/mean(1/my_samp$prob)
my_samp <- my_samp[order(my_samp$stat_time), ]
# for memory reasons
rm(list = c('pop', 'Z1pop', 'Z0pop', 'the_data'))
coxme_fit <- coxme::coxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
data = my_samp, weights = rweights, control = coxme::coxme.control(sparse = c(0, 0)))
# define design, add ui
my_des <- svydesign(~id, weights = ~weights, data = my_samp, strata = ~Z1)
my_des_jackknife <- as.svrepdesign(my_des, type = "JKn")
my_des_bootstrap <- as.svrepdesign(my_des, type = "bootstrap", replicates = 50)
svycoxme_fit <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des,
control = coxme::coxme.control(sparse = c(0, 0)))
svycoxme_fit_jackknife <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des_jackknife,
control = coxme::coxme.control(sparse = c(0, 0)))
svycoxme_fit_bootstrap <- svycoxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id),
des = my_des_bootstrap,
control = coxme::coxme.control(sparse = c(0, 0)))
list(
specs = specs,
svycoxme_var = diag(vcov(svycoxme_fit)),
svycoxme_var_jackknife = diag(vcov(svycoxme_fit_jackknife)),
svycoxme_var_bootstrap = diag(vcov(svycoxme_fit_bootstrap)),
fisher_var_unweighted = diag(vcov(coxme_fit)),
coefs = coef(coxme_fit),
timing = list(start = one_rep_start, end = Sys.time()))
}
# see: https://stackoverflow.com/questions/4948361/how-do-i-save-warnings-and-errors-as-output-from-a-function
myTryCatch <- function(expr) {
warn <- err <- NULL
value <- withCallingHandlers(
tryCatch(expr, error=function(e) {
err <<- e
NULL
}), warning=function(w) {
warn <<- w
invokeRestart("muffleWarning")
})
#drop call from error
err$call <- NULL
list(value=value, warning=warn, error=err)
}
try_one_rep <- function(specs){
stream <- .Random.seed
r <- myTryCatch(one_rep(specs))
attr(r, "stream") <- stream
attr(r, "specs") <- specs
r
}
assign(".Random.seed", attr(res[[5]], "stream"), envir = .GlobalEnv)
try_one_rep(specs = param_combos_list[[5]])
param_combos <-
expand.grid(cluster_size = 10,
n_clusters_in_sample = c(50, 100, 250),
n_clusters = 5000,
theta = c(0.0001, 0.5, 1)) %>%
dplyr::mutate(sample_size = n_clusters_in_sample * cluster_size) %>%
data.frame()
