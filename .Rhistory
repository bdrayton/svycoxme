upper = one_fit$coefs + qnorm(0.975) * sqrt(c(v1, v2, v3, v6)),
hit = lower < true_coefs & upper > true_coefs
)
}
shape_res(non_error_fits[[1]])
df <- plyr::ldply(non_error_fits, shape_res)
library(tidyverse)
coverage_summary <- df %>%
group_by(method, covariate) %>%
mutate(theta_binned = cut(theta, breaks = seq(0, 2, by = 0.1),
labels = seq(0.05, 1.95, by = 0.1)) |>
as.character() |> as.numeric()) %>%
group_by(theta_binned, .add = TRUE) %>%
summarise(coverage = mean(hit, na.rm = TRUE),
prop_nas = sum(is.na(hit))/n(),
.groups = "drop")
coverage_summary %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() + facet_grid(rows = vars(covariate)) +
geom_hline(yintercept = 0.95)
results_path <- file.path(Sys.getenv("OneDriveCommercial"), "PhD/outputs/simulations/data/variances_8.rds")
res <- readr::read_rds(results_path)
error_messages <- lapply(res, "[[", "error")
warning_messages <- lapply(res, "[[", "warning")
returned_values <- lapply(res, "[[", "value")
is.error <- sapply(error_messages, inherits, "error")
is.warning <- sapply(warning_messages, inherits, "warning")
table(is.error) |> prop.table()
table(is.warning)
results_with_warnings <- res[is.warning]
non_error_fits <- returned_values[!is.error]
non_error_fits[[1]]
shape_res <- function(one_fit){
covars <- names(one_fit$coefs)
v1 <- one_fit$sandwich_finite_pop
v2 <- one_fit$sandwich_infinite_pop
v3 <- one_fit$svycoxme_var_jackknife
# v4 <- one_fit$svycoxme_var_bootstrap
# v5 <- one_fit$svycoxme_var_subbootstrap
v6 <- one_fit$fisher_var
tibble::tibble(
method = rep(c("sandwich_finite_pop", "sandwich_inf_pop", "cluster_jackknife", "fisher_info"), each = 3),
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
covariate = rep(covars, 4),
coefs = rep(one_fit$coefs, 4),
true_coefs = rep(c(1, -0.7, 0.5), 4),
variance = c(v1, v2, v3, v6),
lower = one_fit$coefs + qnorm(0.025) * sqrt(c(v1, v2, v3, v6)),
upper = one_fit$coefs + qnorm(0.975) * sqrt(c(v1, v2, v3, v6)),
hit = lower < true_coefs & upper > true_coefs
)
}
shape_res(non_error_fits[[1]])
df <- plyr::ldply(non_error_fits, shape_res)
head(df)
file.path(Sys.getenv("OneDriveCommercial"), "Documents/PhD_local/svycoxme")
devtools::load_all(svycoxme_path)
initial_seed = 14523434
cluster_seed = 18976534
set.seed(initial_seed)
file.path(Sys.getenv("OneDriveCommercial"), "Documents/PhD_local/svycoxme")
svycoxme_path <- file.path(Sys.getenv("OneDriveCommercial"), "Documents/PhD_local/svycoxme")
devtools::load_all(svycoxme_path)
initial_seed = 14523434
cluster_seed = 18976534
set.seed(initial_seed)
# set to and 20 for the real run.
# run just a few for each parameter combination.
sim_combos_n <- 10000
cores <- 20
# these are the parameter combinations
true_coefs = c(X1 = 1, X2 = -0.7, X3 = 0.5)
param_combos <- data.frame(n_clusters = 5000,
cluster_size = ceiling(runif(sim_combos_n, 2, 50)),
theta = runif(sim_combos_n, 0, 2),
n_clusters_in_sample = ceiling(runif(sim_combos_n, 9, 100)))
# need rows as list
param_combos_list <- split(param_combos, f = seq_len(nrow(param_combos)))
# define one rep
one_rep <- function(specs){
# generate a population, sample from it, calculate the things.
# generate population
k <- specs$n_clusters
nk <- specs$cluster_size
the_data <- one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = true_coefs,
random_effect_variance = c(M=specs$theta)
)
pop <- dplyr::mutate(the_data, id = M)
# sample from it
# one cluster sample
samp_cluster_ids <- unique(pop$id)[sample.int(specs$n_clusters, specs$n_clusters_in_samp)]
my_samp <- pop[pop$id %in% samp_cluster_ids, ]
# for memory reasons
rm(list = c('pop', 'the_data'))
my_samp$prob <- (specs$n_clusters_in_samp/specs$n_clusters)
my_samp$weights <- my_samp$prob^-1
# rescale_weights
my_samp$rweights <- (1/my_samp$prob)/mean(1/my_samp$prob)
my_samp <- my_samp[order(my_samp$stat_time), ]
# the regular fit.
coxme_fit <- coxme::coxme(survival::Surv(stat_time, stat)~ X1 + X2 + X3 + (1|id), data = my_samp, weights = rweights)
# calculate ui and get information
parts <- make_parts(coxme_fit, my_samp, weights = my_samp$weights)
ui <- calc_ui(parts)
vv <- get_information(coxme_fit)
uivv <- ui %*% vv
# define design, add ui
my_des <- svydesign(~id, weights = ~weights, data = my_samp)
my_des_jackknife <- as.svrepdesign(my_des, type = "JK1")
# my_des_bootstrap <- as.svrepdesign(my_des, type = "bootstrap")
# my_des_subbootstrap <- as.svrepdesign(my_des, type = "subbootstrap")
svycoxme_fit_jackknife <- svycoxme(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | id), des = my_des_jackknife)
# svycoxme_fit_bootstrap <- svycoxme(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | id), des = my_des_bootstrap)
# svycoxme_fit_subbootstrap <- svycoxme(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | id), des = my_des_subbootstrap)
# calculate sandwich variance
sandwich <- svyrecvar(uivv, my_des$cluster, my_des$strata, my_des$fpc, postStrata = my_des$postStrata)
sandwich2 <- vv + sandwich
list(
specs = specs,
sandwich_finite_pop  = diag(sandwich)[1:3],
sandwich_infinite_pop = diag(sandwich2)[1:3],
svycoxme_var_jackknife = diag(vcov(svycoxme_fit_jackknife)),
# svycoxme_var_bootstrap = diag(vcov(svycoxme_fit_bootstrap)),
# svycoxme_var_subbootstrap = diag(vcov(svycoxme_fit_subbootstrap)),
fisher_var = diag(vcov(coxme_fit)),
coefs = coef(svycoxme_fit_jackknife))
}
# see: https://stackoverflow.com/questions/4948361/how-do-i-save-warnings-and-errors-as-output-from-a-function
myTryCatch <- function(expr) {
warn <- err <- NULL
value <- withCallingHandlers(
tryCatch(expr, error=function(e) {
err <<- e
NULL
}), warning=function(w) {
warn <<- w
invokeRestart("muffleWarning")
})
#drop call from error
err$call <- NULL
list(value=value, warning=warn, error=err)
}
try_one_rep <- function(specs){
stream <- .Random.seed
r <- myTryCatch(one_rep(specs))
attr(r, "stream") <- stream
attr(r, "specs") <- specs
r
}
debugonce(one_rep)
try_one_rep(specs = param_combos_list[[1]])
names(parts)
debugonce(one_rep)
try_one_rep(specs = param_combos_list[[1]])
try_one_rep(specs = param_combos_list[[1]])
devtools::load_all(".")
try_one_rep(specs = param_combos_list[[1]])
results_path <- file.path(Sys.getenv("OneDriveCommercial"), "PhD/outputs/simulations/data/variances_8.rds")
res <- readr::read_rds(results_path)
error_messages <- lapply(res, "[[", "error")
warning_messages <- lapply(res, "[[", "warning")
returned_values <- lapply(res, "[[", "value")
is.error <- sapply(error_messages, inherits, "error")
is.warning <- sapply(warning_messages, inherits, "warning")
table(is.error) |> prop.table()
table(is.warning)
results_with_warnings <- res[is.warning]
non_error_fits <- returned_values[!is.error]
non_error_fits[[1]]
shape_res <- function(one_fit){
covars <- names(one_fit$coefs)
v1 <- one_fit$sandwich_finite_pop
v2 <- one_fit$sandwich_infinite_pop
v3 <- one_fit$svycoxme_var_jackknife
# v4 <- one_fit$svycoxme_var_bootstrap
# v5 <- one_fit$svycoxme_var_subbootstrap
v6 <- one_fit$fisher_var
tibble::tibble(
method = rep(c("sandwich_finite_pop", "sandwich_inf_pop", "cluster_jackknife", "fisher_info"), each = 3),
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
covariate = rep(covars, 4),
coefs = rep(one_fit$coefs, 4),
true_coefs = rep(c(1, -0.7, 0.5), 4),
variance = c(v1, v2, v3, v6),
lower = one_fit$coefs + qnorm(0.025) * sqrt(c(v1, v2, v3, v6)),
upper = one_fit$coefs + qnorm(0.975) * sqrt(c(v1, v2, v3, v6)),
hit = lower < true_coefs & upper > true_coefs
)
}
shape_res(non_error_fits[[1]])
df <- plyr::ldply(non_error_fits, shape_res)
library(tidyverse)
coverage_summary <- df %>%
group_by(method, covariate) %>%
mutate(theta_binned = cut(theta, breaks = seq(0, 2, by = 0.1),
labels = seq(0.05, 1.95, by = 0.1)) |>
as.character() |> as.numeric()) %>%
group_by(theta_binned, .add = TRUE) %>%
summarise(coverage = mean(hit, na.rm = TRUE),
prop_nas = sum(is.na(hit))/n(),
.groups = "drop")
coverage_summary %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() + facet_grid(rows = vars(covariate)) +
geom_hline(yintercept = 0.95)
coverage_summary %>%
filter(covariate == "X1") %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
geom_hline(yintercept = 0.95)
coverage_summary %>%
filter(covariate == "X2") %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
geom_hline(yintercept = 0.95)
coverage_summary %>%
filter(covariate == "X3") %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
geom_hline(yintercept = 0.95)
# look at that first plot again, but split by number of clusters.
coverage_summary_2 <- df %>%
mutate(
n_clusters_in_sample_binned = cut(n_clusters_in_sample, breaks = seq(10, 100, by = 10),
include.lowest = TRUE, right = TRUE),
theta_binned = cut(theta, breaks = seq(0, 2, by = 0.1),
labels = seq(0.05, 1.95, by = 0.1)) |>
as.character() |> as.numeric()) %>%
group_by(method, covariate, n_clusters_in_sample_binned, theta_binned) %>%
summarise(coverage = mean(hit, na.rm = TRUE),
prop_nas = sum(is.na(hit))/n(),
.groups = "drop")
coverage_summary_2 %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
facet_grid(rows = vars(covariate),
cols = vars(n_clusters_in_sample_binned)) +
geom_hline(yintercept = 0.95)
results_path <- file.path(Sys.getenv("OneDriveCommercial"), "PhD/outputs/simulations/data/variances_9.rds")
res <- readr::read_rds(results_path)
error_messages <- lapply(res, "[[", "error")
warning_messages <- lapply(res, "[[", "warning")
returned_values <- lapply(res, "[[", "value")
is.error <- sapply(error_messages, inherits, "error")
is.warning <- sapply(warning_messages, inherits, "warning")
table(is.error) |> prop.table()
table(is.warning)
results_with_warnings <- res[is.warning]
non_error_fits <- returned_values[!is.error]
non_error_fits[[1]]
shape_res <- function(one_fit){
covars <- names(one_fit$coefs)
v1 <- one_fit$sandwich_finite_pop
v2 <- one_fit$sandwich_infinite_pop
v3 <- one_fit$svycoxme_var_jackknife
# v4 <- one_fit$svycoxme_var_bootstrap
# v5 <- one_fit$svycoxme_var_subbootstrap
v6 <- one_fit$fisher_var
tibble::tibble(
method = rep(c("sandwich_finite_pop", "sandwich_inf_pop", "cluster_jackknife", "fisher_info"), each = 3),
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
covariate = rep(covars, 4),
coefs = rep(one_fit$coefs, 4),
true_coefs = rep(c(1, -0.7, 0.5), 4),
variance = c(v1, v2, v3, v6),
lower = one_fit$coefs + qnorm(0.025) * sqrt(c(v1, v2, v3, v6)),
upper = one_fit$coefs + qnorm(0.975) * sqrt(c(v1, v2, v3, v6)),
hit = lower < true_coefs & upper > true_coefs
)
}
shape_res(non_error_fits[[1]])
df <- plyr::ldply(non_error_fits, shape_res)
library(tidyverse)
coverage_summary <- df %>%
group_by(method, covariate) %>%
mutate(theta_binned = cut(theta, breaks = seq(0, 2, by = 0.1),
labels = seq(0.05, 1.95, by = 0.1)) |>
as.character() |> as.numeric()) %>%
group_by(theta_binned, .add = TRUE) %>%
summarise(coverage = mean(hit, na.rm = TRUE),
prop_nas = sum(is.na(hit))/n(),
.groups = "drop")
coverage_summary %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() + facet_grid(rows = vars(covariate)) +
geom_hline(yintercept = 0.95)
coverage_summary %>%
filter(covariate == "X1") %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
geom_hline(yintercept = 0.95)
coverage_summary %>%
filter(covariate == "X2") %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
geom_hline(yintercept = 0.95)
coverage_summary %>%
filter(covariate == "X3") %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
geom_hline(yintercept = 0.95)
# look at that first plot again, but split by number of clusters.
coverage_summary_2 <- df %>%
mutate(
n_clusters_in_sample_binned = cut(n_clusters_in_sample, breaks = seq(10, 100, by = 10),
include.lowest = TRUE, right = TRUE),
theta_binned = cut(theta, breaks = seq(0, 2, by = 0.1),
labels = seq(0.05, 1.95, by = 0.1)) |>
as.character() |> as.numeric()) %>%
group_by(method, covariate, n_clusters_in_sample_binned, theta_binned) %>%
summarise(coverage = mean(hit, na.rm = TRUE),
prop_nas = sum(is.na(hit))/n(),
.groups = "drop")
coverage_summary_2 %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
facet_grid(rows = vars(covariate),
cols = vars(n_clusters_in_sample_binned)) +
geom_hline(yintercept = 0.95)
# larger cluster sizes
coverage_summary_3 <- df %>%
filter(between(cluster_size, 40, 50)) %>%
mutate(
n_clusters_in_sample_binned = cut(n_clusters_in_sample, breaks = seq(10, 100, by = 10),
include.lowest = TRUE, right = TRUE),
theta_binned = cut(theta, breaks = seq(0, 2, by = 0.1),
labels = seq(0.05, 1.95, by = 0.1)) |>
as.character() |> as.numeric()) %>%
group_by(method, covariate, n_clusters_in_sample_binned, theta_binned) %>%
summarise(coverage = mean(hit, na.rm = TRUE),
prop_nas = sum(is.na(hit))/n(),
.groups = "drop")
coverage_summary_3 %>%
ggplot(aes(theta_binned, coverage, colour = method)) +
geom_line() +
facet_grid(rows = vars(covariate),
cols = vars(n_clusters_in_sample_binned)) +
geom_hline(yintercept = 0.95)
# bias
bias <- function(theta, true_theta){
sum(theta - true_theta)/length(theta)
}
EmpSE <- function(theta){
theta_bar = mean(theta)
sqrt( sum((theta-mean(theta))^2)/(length(theta)-1) )
}
# look at each method separately, and colour by cluster size
df %>%
filter(method == "jackknife") %>%
mutate(theta_binned = cut(theta, breaks = seq(0, 2, by = 0.1),
labels = seq(0.05, 1.95, by = 0.1)) |>
as.character() |> as.numeric(),
cluster_size_binned = cut(cluster_size,
breaks = seq(0, 50, by = 10), include.lowest = TRUE, right = TRUE)) %>%
group_by(covariate, theta_binned, cluster_size_binned) %>%
summarise(coverage = mean(hit), n(), .groups = "drop") %>%
ggplot(aes(theta_binned, coverage, colour = cluster_size_binned, group = cluster_size_binned)) +
geom_line() + facet_grid(rows = vars(covariate)) +
geom_hline(yintercept = 0.95)
devtools::load_all(".")
library(survey)
pbc$randomized<-with(pbc, !is.na(trt) & trt>0)
biasmodel<-glm(randomized~age*edema,data=pbc,family=binomial)
pbc$randprob<-fitted(biasmodel)
if (is.null(pbc$albumin)) pbc$albumin<-pbc$alb ##pre2.9.0
dset <- subset(pbc,randomized)
dset <- dset[order(dset$time),]
dpbc<-svydesign(id=~1, prob=~randprob, strata=NULL, data=dset)
dset$weights <- 1/dset$randprob
dset$rweights <- (1/dset$randprob)/mean(1/dset$randprob)
(svymodel<-svycoxph(Surv(time,status>0)~log(bili)+protime+albumin,design=dpbc))
model <- coxph(Surv(time,status>0)~log(bili)+protime+albumin,data = dset, weights = rweights, ties = "breslow")
parts <- make_parts(model, data = dset)
new_parts <- make_parts(model, data = dset)
parts <- make_parts(model, data = dset)
my_ui <- calc_ui(parts)
vv <- vcov(model)
my_dfbeta <- my_ui %*% vv
tt_dfbeta <- resid(model, type = 'dfbeta', weighted = TRUE)
all.equal(as.matrix(my_ui), resid(model, type = 'score', weighted = TRUE) |> as.matrix())
weights(model)
cbind(weights(model), dset$rweights, dset$weights)
model <- coxph(Surv(time,status>0)~log(bili)+protime+albumin,data = dset, ties = "breslow")
parts <- make_parts(model, data = dset)
my_ui <- calc_ui(parts)
all.equal(as.matrix(my_ui), resid(model, type = 'score', weighted = TRUE) |> as.matrix())
all.equal(as.matrix(my_ui), resid(model, type = 'score') |> as.matrix())
my_ui <- calc_ui(parts)
calc_ui
devtools::load_all(".")
my_ui <- calc_ui(parts)
all.equal(as.matrix(my_ui), resid(model, type = 'score', weighted = TRUE) |> as.matrix())
model <- coxph(Surv(time,status>0)~log(bili)+protime+albumin,data = dset, weights = rweights, ties = "breslow")
parts <- make_parts(model, data = dset)
my_ui <- calc_ui(parts)
all.equal(as.matrix(my_ui), resid(model, type = 'score', weighted = TRUE) |> as.matrix())
vv <- vcov(model)
my_dfbeta <- my_ui %*% vv
all.equal(as.matrix(my_dfbeta), tt_dfbeta)
tt_score <- resid(model, type = 'score', weighted = TRUE) |> as.matrix()
all.equal(tt_score %*% vv, tt_dfbeta)
tt_score <- resid(model, type = 'score')
all.equal(tt_score %*% vv, tt_dfbeta)
all.equal(weights(model) * tt_score %*% vv, tt_dfbeta)
debugonce(residuals.coxph)
debugonce(survival:::residuals.coxph)
tt_dfbeta <- resid(model, type = 'dfbeta', weighted = TRUE)
object$residuals
Terms
vv
vcov(object)
object$naive.var
vv <- model$naive.var
my_dfbeta <- my_ui %*% vv
all.equal(as.matrix(my_dfbeta), tt_dfbeta)
all.equal(weights(model) * tt_score %*% vv, tt_dfbeta)
all.equal(as.matrix(my_dfbeta), tt_dfbeta)
devtools::load_all(".")
devtools::load_all(".")
#### coxme
fit2 <- coxme(Surv(time, status) ~ ph.ecog + age + (1|inst), lung)
library(coxme)
fit2 <- coxme(Surv(time, status) ~ ph.ecog + age + (1|inst), lung)
parts <- make_parts(fit2)
parts <- make_parts(fit2, data = lung)
lung_complete <- complete.cases(lung[, c("time", "status", "ph.ecog", "age", "inst")])
lung_complete <- lung[complete.cases(lung[, c("time", "status", "ph.ecog", "age", "inst")]), ]
lung_complete <- lung[complete.cases(lung[, c("time", "status", "ph.ecog", "age", "inst")]), ]
fit2 <- coxme(Surv(time, status) ~ ph.ecog + age + (1|inst), lung_complete)
parts <- make_parts(fit2, data = lung_complete)
calc_ui(fit2)
calc_ui(parts)
devtools::load_all(".")
calc_ui(parts)
lung_complete <- lung[complete.cases(lung[, c("time", "status", "ph.ecog", "age", "inst")]), ]
lung_complete <- lung_complete[order(lung_complete$time), ]
fit2 <- coxme(Surv(time, status) ~ ph.ecog + age + (1|inst), lung_complete)
parts <- make_parts(fit2, data = lung_complete)
my_score <- calc_ui(parts)
des <- svydesign(ids ~inst, weights = 1, data = lung_complete)
des <- svydesign(ids = ~inst, weights = 1, data = lung_complete)
svyfit <- svycoxme(Surv(time, status) ~ ph.ecog + age + (1|inst), design = des)
debug(residuals.coxme)
resid(fit2, type = "score")
vv
object$variance
class(object)
object$variance
get_information(object)
is.null(vv)
debug(residuals.coxme)
resid(fit2, type = "score")
devtools::load_all(".")
debug(residuals.coxme)
resid(fit2, type = "score")
resid(fit2, data = lung_complete, type = "score")
devtools::load_all(".")
# debug(residuals.coxme)
resid_score <- resid(fit2, data = lung_complete, type = "score")
my_score <- calc_ui(parts)
all.equal(my_score, resid_score)
svyfit <- svycoxme(Surv(time, status) ~ ph.ecog + age + (1|inst), design = des)
svyfit$var
repdes <- as.svrepdesign(des)
repdes <- as.svrepdesign(des, type = "JK1")
svyfit2 <- svycoxme(Surv(time, status) ~ ph.ecog + age + (1|inst), design = repdes)
debugonce(svycoxme.svyrep.design)
svyfit2 <- svycoxme(Surv(time, status) ~ ph.ecog + age + (1|inst), design = repdes)
g$weights
pwts
des <- svydesign(ids = ~inst, weights = ~1, data = lung_complete)
repdes <- as.svrepdesign(des, type = "JK1")
svyfit <- svycoxme(Surv(time, status) ~ ph.ecog + age + (1|inst), design = des)
svyfit2 <- svycoxme(Surv(time, status) ~ ph.ecog + age + (1|inst), design = repdes)
svyfit$var
svyfit2$var
library(survey)
# svycoxme_path <- file.path(Sys.getenv("OneDriveCommercial"), "Documents/PhD_local/svycoxme")
# devtools::load_all(svycoxme_path)
pbc$randomized<-with(pbc, !is.na(trt) & trt>0)
biasmodel<-glm(randomized~age*edema,data=pbc,family=binomial)
pbc$randprob<-fitted(biasmodel)
if (is.null(pbc$albumin)) pbc$albumin<-pbc$alb ##pre2.9.0
dset <- subset(pbc,randomized)
dset <- dset[order(dset$time),]
dpbc<-svydesign(id=~1, prob=~randprob, strata=NULL, data=dset)
rpbc<-as.svrepdesign(dpbc)
dset$weights <- 1/dset$randprob
dset$rweights <- (1/dset$randprob)/mean(1/dset$randprob)
(svymodel<-svycoxph(Surv(time,status>0)~log(bili)+protime+albumin,design=dpbc))
model <- coxph(Surv(time,status>0)~log(bili)+protime+albumin,data = dset, weights = rweights, ties = "breslow")
svyrepmodel <- svycoxph(Surv(time,status>0)~log(bili)+protime+albumin,design=rpbc)
vcov(svymodel)
vcov(svyrepmodel)
vcov(svymodel) - vcov(svyrepmodel)
svyfit$var - svyfit2$var
parts <- make_parts(fit2, data = lung_complete)
