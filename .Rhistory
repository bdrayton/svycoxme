sqrt(diag(-solve(attr(ests, "theta_est")$hessian))),
sqrt(diag(-solve(attr(ests2, "theta_est")$hessian))),
sqrt(diag(-solve(attr(ests3, "theta_est")$hessian))))
devtools::load_all(".")
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M1) + (1 | M2)
my_k = 50
my_nk = 10
my_theta = c(M1 = 2, M2 = 1)
my_beta = c(1, -0.7, 0.5)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = my_theta
)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
theta_ipl(ests$theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
ests <- est_parameters(my_formula, ds)
theta_ipl(ests$theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
theta_ipl_gr(ests$theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
debugonce(theta_ipl_gr)
theta_ipl_gr(ests$theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
d_D_d_theta
theta
grads
unlist(grads)
unclass(grads)
grads <- lapply(d_D_d_theta, function(dD){
c(-0.5 * ( sum(diag(D_inv %*% dD))
- sum(diag(Kbb_inv %*% D_inv %*%dD%*%D_inv))
- t(b)%*%D_inv%*%dD%*%D_inv%*%b ))
})
grads
grads <- lapply(d_D_d_theta, function(dD){
unclass(-0.5 * ( sum(diag(D_inv %*% dD))
- sum(diag(Kbb_inv %*% D_inv %*%dD%*%D_inv))
- t(b)%*%D_inv%*%dD%*%D_inv%*%b ))
})
grads
grads <- lapply(d_D_d_theta, function(dD){
grad <- -0.5 * ( sum(diag(D_inv %*% dD))
- sum(diag(Kbb_inv %*% D_inv %*%dD%*%D_inv))
- t(b)%*%D_inv%*%dD%*%D_inv%*%b )
grad$x
})
grads <- lapply(d_D_d_theta, function(dD){
grad <- -0.5 * ( sum(diag(D_inv %*% dD))
- sum(diag(Kbb_inv %*% D_inv %*%dD%*%D_inv))
- t(b)%*%D_inv%*%dD%*%D_inv%*%b )
grad@x
})
grads
unlist(grads)
devtools::load_all(".")
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = my_theta
)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme::VarCorr(coxme_fit)
ests <- est_parameters(my_formula, ds)
theta_ipl(ests$theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
# debugonce(theta_ipl_gr)
numDeriv::grad(theta_ipl, x = ests$theta, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
theta_ipl_gr(ests$theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
seq(from = 1.5, to = 3.5, length_out = 20)
seq(from = 1.5, to = 3.5, length.out = 20)
seq(from = 1.5, to = 3.5, length.out = 21)
test_thetas <- expand.grid(seq(from = 1.5, to = 3.5, length.out = 21),
seq(from = 3.4, to = 4.4, length.out = 21))
test_thetas[1:2,]
apply(test_thetas[1:2,], 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
theta_likelihoods <- apply(test_thetas[1:2,], 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
str(theta_likelihoods)
theta_likelihoods <- apply(test_thetas, 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
fig <- plotly::plot_ly(x = test_thetas[,1], y = test_thetas[,2], z = theta_likelihoods) |>
plotly::add_surface()
fig
MASS::geyser
MASS::kde2d(duration, waiting, n = 50)
with(MASS::geyser, MASS::kde2d(duration, waiting, n = 50))
?kde2d
install.packages("threejs")
threejs::scatterplot3js(
x = test_thetas[,1], y = test_thetas[,2], z = theta_likelihoods
)
max(theta_likelihoods)
test_thetas[max(theta_likelihoods) == theta_likelihoods,1]
test_thetas[max(theta_likelihoods) == theta_likelihoods,]
coxme_fit$vcoef
test_thetas[max(theta_likelihoods) == theta_likelihoods,]
coxme_fit$loglik
theta_ipl(unlist(coxme_fit$vcoef), formula = my_formula, parsed_data = make_ppl(parsed_data),
)
theta_ipl(unlist(coxme_fit$vcoef), formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
coxme_fit$vcoef
ests$theta
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M1) + (1 | M2)
my_k = 50
my_nk = 10
my_theta = c(M1 = 2, M2 = 1)
my_beta = c(1, -0.7, 0.5)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = my_theta
)
coxme_fit <- coxme::coxme(my_formula, data = ds)
ests <- est_parameters(my_formula, ds)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
test_thetas <- expand.grid(seq(from = ests$theta[1]-1, to = ests$theta[1]-1, length.out = 21),
seq(from = ests$theta[2]-1, to = ests$theta[2]-1, length.out = 21))
ests$theta
theta_likelihoods <- apply(test_thetas, 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
threejs::scatterplot3js(
x = test_thetas[,1], y = test_thetas[,2], z = theta_likelihoods
)
theta_likelihoods
ests$theta
test_thetas
test_thetas <- expand.grid(seq(from = ests$theta[1]-1, to = ests$theta[1]+1, length.out = 21),
seq(from = ests$theta[2]-1, to = ests$theta[2]+1, length.out = 21))
test_thetas
theta_likelihoods <- apply(test_thetas, 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
threejs::scatterplot3js(
x = test_thetas[,1], y = test_thetas[,2], z = theta_likelihoods
)
theta_likelihoods
cbind(test_thetas, theta_likelihoods)
plot_data <- cbind(test_thetas, theta_likelihoods)
dplyr::filter(plot_data, Var1 > 0, Var2 > 0)
plot_data <- dplyr::filter(cbind(test_thetas, theta_likelihoods), Var1 > 0, Var2 > 0)
threejs::scatterplot3js(
plot_data
)
plot_data <- dplyr::filter(cbind(test_thetas, theta_likelihoods), Var1 > 0, Var2 > 0)
plot_data
str(plot_data)
plot_data <- dplyr::filter(cbind(test_thetas, theta_likelihoods), Var1 > 0, Var2 > 0) |> as.matrix()
threejs::scatterplot3js(
plot_data
)
min(-1, 0)
ests$theta[1]
max(ests$theta[1]-1, 0)
max(ests$theta[2]-1, 0)
test_thetas <- expand.grid(seq(from = max(ests$theta[1]-1, 0.001), to = ests$theta[1]+1, length.out = 21),
seq(from = max(ests$theta[2]-1, 0.001), to = ests$theta[2]+1, length.out = 21))
theta_likelihoods <- apply(test_thetas, 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
plot_data <- dplyr::filter(cbind(test_thetas, theta_likelihoods), Var1 > 0, Var2 > 0) |> as.matrix()
threejs::scatterplot3js(
plot_data
)
fig <- plotly::plot_ly(x = test_thetas[,1], y = test_thetas[,2], z = theta_likelihoods, type = 'mesh3d')
fig
test_thetas <- expand.grid(c(ests$theta[1], seq(from = max(ests$theta[1]-1, 0.001), to = ests$theta[1]+0.5, length.out = 21)),
c(ests$theta[2], seq(from = max(ests$theta[2]-0.5, 0.001), to = ests$theta[2]+0.5, length.out = 21)))
theta_likelihoods <- apply(test_thetas, 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
theta_gradients <- apply(test_thetas, 1, function(theta){
theta_ipl_gr(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
plot_data <- dplyr::filter(cbind(test_thetas, theta_likelihoods), Var1 > 0, Var2 > 0) |> as.matrix()
threejs::scatterplot3js(
plot_data
)
threejs::scatterplot3js(
plot_data
)
fig <- plotly::plot_ly(x = test_thetas[,1], y = test_thetas[,2], z = theta_likelihoods, type = 'mesh3d')
fig
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,2])
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,3])
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,3], color = "red")
theta_likelihoods == max(theta_likelihoods)
theta_likelihoods == max(theta_likelihoods) + 1
c("blue", "red")[(theta_likelihoods == max(theta_likelihoods)) + 1]
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,3],
color = c("blue", "red")[(theta_likelihoods == max(theta_likelihoods)) + 1])
plot_data <- dplyr::filter(cbind(test_thetas, theta_likelihoods), Var1 > 0, Var2 > 0) |>
dplyr::arrange(theta_likelihoods) |>
as.matrix()
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,3],
color = c("blue", "red")[(theta_likelihoods == max(theta_likelihoods)) + 1])
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,3],
color = c("blue", "red")[(plot_data$theta_likelihoods == max(plot_data$theta_likelihoods)) + 1])
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,3],
color = c("blue", "red")[(plot_data[,3] == max(plot_data[,3])) + 1])
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,3],
color = c("blue", "red")[(plot_data[,3] == max(plot_data[,3])) + 1],
size = 0.01)
threejs::scatterplot3js(plot_data[,1], plot_data[,2], plot_data[,3],
color = c("blue", "red")[(plot_data[,3] == max(plot_data[,3])) + 1],
size = 0.1)
theta_gradients
t(theta_gradients)
cbind(test_thetas, theta_gradients)
cbind(test_thetas, t(theta_gradients))
grad_data <- cbind(test_thetas, t(theta_gradients))
grad_data <- cbind(test_thetas, t(theta_gradients), theta_likelihoods)
names(grad_data)
threejs::scatterplot3js(grad_data[,3], grad_data[,4], plot_data[,5],
color = c("blue", "red")[(grad_data[,5] == max(grad_data[,5])) + 1],
size = 0.1)
threejs::scatterplot3js(grad_data[,3], grad_data[,4], grad_data[,5],
color = c("blue", "red")[(grad_data[,5] == max(grad_data[,5])) + 1],
size = 0.1)
grad_data <- cbind(test_thetas, t(theta_gradients), theta_likelihoods)
threejs::scatterplot3js(grad_data[,3], grad_data[,4], grad_data[,5],
color = c("blue", "red")[(grad_data[,5] == max(grad_data[,5])) + 1],
size = 0.1)
ests$theta[1]
ests$theta[1] + seq(-0.5, 0.5, by = 0.01)
test_thetas2 <- data.frame(changing = ests$theta[1] + seq(-0.5, 0.5, by = 0.01),
constant = ests$theta[2])
test_thetas2 <- data.frame(changing = ests$theta[1] + seq(-0.5, 0.5, by = 0.5),
constant = ests$theta[2])
test_thetas2
test_thetas2 <- data.frame(changing = ests$theta[1] + seq(-0.5, 0.5, by = 0.1),
constant = ests$theta[2])
test_thetas2
likelihoods <- apply(test_thetas2, 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
plot(test_thetas2$changing, likelihoods)
# gradients at each point
gradients <- apply(test_thetas2, 1, function(theta){
theta_ipl_gr(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
gradients
gradients[1,]
text(test_thetas2$changing, likelihoods, round(gradients[1,], 2))
coxme_fit$vcoef
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit$vcoef
ests$theta
# analytical hessian for theta
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M1) + (1 | M2)
my_k = 50
my_nk = 10
my_theta = c(M1 = 2, M2 = 1)
my_beta = c(1, -0.7, 0.5)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = my_theta
)
coxme_fit <- coxme::coxme(my_formula, data = ds)
ests <- est_parameters(my_formula, ds)
# thetas
cbind(
unlist(coxme::VarCorr(coxme_fit)),
ests$theta
# ests2$theta,
# ests3$theta
)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
numDeriv::grad(theta_ipl, x = ests$theta, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
theta_ipl_gr(ests$theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
test_thetas2 <- data.frame(changing = ests$theta[1] + seq(-0.5, 0.5, by = 0.1),
constant = ests$theta[2])
likelihoods <- apply(test_thetas2, 1, function(theta){
theta_ipl(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
# gradients at each point
gradients <- apply(test_thetas2, 1, function(theta){
theta_ipl_gr(theta, formula = my_formula, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
plot(test_thetas2$changing, likelihoods)
text(test_thetas2$changing, likelihoods, round(gradients[1,], 2), adj = c(1, 1))
plot(test_thetas2$changing, likelihoods)
plot(test_thetas2$changing, likelihoods)
text(test_thetas2$changing, likelihoods, round(gradients[1,], 2), adj = c(0, 0))
gradients2 <- apply(test_thetas2, 1, function(theta){
numDeriv::grad(theta_ipl, x = ests$theta, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
text(test_thetas2$changing, likelihoods, round(gradients2[1,], 2), adj = c(0, 1))
gradients2 <- apply(test_thetas2, 1, function(theta){
numDeriv::grad(theta_ipl, x = theta, parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
})
plot(test_thetas2$changing, likelihoods)
text(test_thetas2$changing, likelihoods, round(gradients[1,], 2), adj = c(0, 0))
text(test_thetas2$changing, likelihoods, round(gradients2[1,], 2), adj = c(0, 1))
gradients
gradients[1,] - gradients2[1,]
theta_ipl
theta_ipl_gr_num <- function(theta, formula, parsed_data, other_args){
numDeriv::grad(theta_ipl, x = theta,
formula = formula, parsed_data = make_ppl(parsed_data),
other_args = other_args)
}
ests$theta
theta_ipl_gr_num(ests$theta,
formula = my_formula,
parsed_data = make_ppl(parsed_data),
other_args = list(start_params = attr(ests, "beta_b_est")$par,
re_only = TRUE,
n_fixed = 3,
stat = stat))
theta_ipl_gr
gradients
gradients[1,]
gradients[1,] - gradients[1, 6]
gradients2[1, ]
devtools::load_all(".")
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M1) + (1 | M2)
my_k = 50
my_nk = 10
my_theta = c(M1 = 2, M2 = 1)
my_beta = c(1, -0.7, 0.5)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = my_theta
)
coxme_fit <- coxme::coxme(my_formula, data = ds)
ests <- est_parameters(my_formula, ds, control = control.list(grad = TRUE))
ests_w_gr  <- est_parameters(my_formula, ds, control = control.list(grad = FALSE))
devtools::load_all(".")
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M1) + (1 | M2)
my_k = 50
my_nk = 10
my_theta = c(M1 = 2, M2 = 1)
my_beta = c(1, -0.7, 0.5)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = my_theta
)
coxme_fit <- coxme::coxme(my_formula, data = ds)
ests <- est_parameters(my_formula, ds, control = control.list(grad = TRUE))
ests_w_gr  <- est_parameters(my_formula, ds, control = control.list(grad = FALSE))
ests_w_gr  <- est_parameters(my_formula, ds, control = control.list(grad = TRUE))
devtools::load_all(".")
# analytical hessian for theta
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M1) + (1 | M2)
my_k = 50
my_nk = 10
my_theta = c(M1 = 2, M2 = 1)
my_beta = c(1, -0.7, 0.5)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = my_theta
)
coxme_fit <- coxme::coxme(my_formula, data = ds)
ests <- est_parameters(my_formula, ds, control = control.list(grad = FALSE))
ests_w_gr  <- est_parameters(my_formula, ds, control = control.list(grad = TRUE))
