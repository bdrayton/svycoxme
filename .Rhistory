k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits)
nk_id <- formatC(nk, width = max_cluster_digits)
the_data <- one_dataset(~X1 + X2 + X3 + stratum + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
stratum = ~rep(c(0, 1), c(floor(2/3 * k) * nk, ceiling(1/3 * k) * nk))),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(1, -0.7, 0.5, -0.5),
random_effect_variance = list(M = 2)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M, sep = "_" ))
})
names(lp_random_effects_list)
seq(0)
v <- vector("list")
length(v)
seq_along(v)
my_df <- data.frame(char = character())
my_df[1,"char"] <- "hi"
my_df
my_name <- as.symbol("hi")
my_name
data.frame(my_name = 1)
bquote(data.frame(.(my_name) = 1))
bquote(data.frame(.(my_name = 1)))
data.frame(bquote(.(my_name = 1)))
data.frame(bquote(.(my_name) = 1))
setNames
dtemp <- data.frame(`M1:M2` = "1:2")
dtemp
tidyr::separate(dtemp, col = `M1:M2`, sep = ":")
tidyr::separate(dtemp, col = "M1:M2", sep = ":")
dtemp <- data.frame(`M1:M2` = "1:2")
names(dtemp)
dtemp <- data.frame(`M1:M2` = "1:2", check.names = FALSE)
names(dtemp)
tidyr::separate(dtemp, col = "M1:M2", sep = ":")
grepl("\.|:|/", c(".", "/", ":"))
grepl("\\.|:|/", c(".", "/", ":"))
strsplit("M1:M2",split = ":")
unlist(strsplit("M1:M2",split = ":"))
tidyr::separate(dtemp, col = "M1:M2", sep = ":")
tidyr::separate(dtemp, col = "M1:M2", into = c('a', "b"), sep = ":")
tidyr::separate(dtemp, col = "M1:M2", into = c('a', "b"))
dtemp
dtemp <- data.frame(`M1:M2` = "1.2", check.names = FALSE)
tidyr::separate(dtemp, col = "M1:M2", into = c('a', 'b'))
dtemp <- data.frame(`M1:M2` = "1.2", check.names = FALSE)
tidyr::separate(dtemp, col = "M1:M2", into = c('a', 'b'))
dtemp <- data.frame(`M1:M2` = "1/2", check.names = FALSE)
names(dtemp)
tidyr::separate(dtemp, col = "M1:M2", into = c('a', 'b'))
devtools::load_all(".")
one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M = 1)
)
# test with three fixed and one random effects
debugonce(one_dataset)
one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M = 1)
)
var_name
var_re
# test with three fixed and one random effects
debugonce(one_dataset)
one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M = 1)
)
random_effects
lp_random_effects
lp_random_effects_list
devtools::load_all(".")
one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M = 1)
)
devtools::load_all(".")
one_dataset(~X1 + X2 + X3 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M = 1)
)
# test with three fixed and two random effects
test <- one_dataset(~X1 + X2 + X3 + (1 | M1) + (1| M2),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, M2 = 2)
)
View(test)
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits)
nk_id <- formatC(nk, width = max_cluster_digits)
the_data <- one_dataset(~X1 + X2 + X3 + stratum + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
stratum = ~rep(c(0, 1), c(floor(2/3 * k) * nk, ceiling(1/3 * k) * nk))),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(1, -0.7, 0.5, -0.5),
random_effect_variance = list(M = 2)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M, sep = "_" ))
})
pop <- Reduce(rbind.data.frame, pop_list)
pop |> dplyr::distinct(id, .keep_all = TRUE)
pop |> dplyr::distinct(id, .keep_all = TRUE) |>
dplyr::summarise(mean(M_re),
var(M_re))
sample <- dplyr::slice_sample(pop, n = 10000)
lm_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + error,
X3 = as.factor(X3))
lm_fit <- lm(y ~ X1 + X2 + X3, data = lm_data)
summary(lm_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lm_data$error, lm_res)
abline(0, 1, col = "green")
res_fit <- lm(lm_data$error ~ lm_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
sample <- dplyr::slice_sample(pop, n = 1000)
# calculate a outcome, y, that is linearly dependent on X, plus a specified amount of error
lm_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + error,
X3 = as.factor(X3))
lm_fit <- lm(y ~ X1 + X2 + X3, data = lm_data)
summary(lm_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lm_data$error, lm_res)
abline(0, 1, col = "green")
res_fit <- lm(lm_data$error ~ lm_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
sample <- dplyr::slice_sample(pop, n = 1000)
# calculate a outcome, y, that is linearly dependent on X, plus a specified amount of error
lm_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + error,
X3 = as.factor(X3))
lm_fit <- lm(y ~ X1 + X2 + X3, data = lm_data)
summary(lm_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lm_data$error, lm_res)
abline(0, 1, col = "green")
res_fit <- lm(lm_data$error ~ lm_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
sample <- dplyr::slice_sample(pop, n = 1000)
# calculate a outcome, y, that is linearly dependent on X, plus a specified amount of error
lm_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + error,
X3 = as.factor(X3))
lm_fit <- lm(y ~ X1 + X2 + X3, data = lm_data)
summary(lm_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lm_data$error, lm_res)
abline(0, 1, col = "green")
res_fit <- lm(lm_data$error ~ lm_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
sample <- dplyr::slice_sample(pop, n = 1000)
# calculate a outcome, y, that is linearly dependent on X, plus a specified amount of error
lm_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + error,
X3 = as.factor(X3))
lm_fit <- lm(y ~ X1 + X2 + X3, data = lm_data)
summary(lm_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lm_data$error, lm_res)
abline(0, 1, col = "green")
res_fit <- lm(lm_data$error ~ lm_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
sample <- dplyr::slice_sample(pop, n = 1000)
# calculate a outcome, y, that is linearly dependent on X, plus a specified amount of error
lm_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + error,
X3 = as.factor(X3))
lm_fit <- lm(y ~ X1 + X2 + X3, data = lm_data)
summary(lm_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lm_data$error, lm_res)
abline(0, 1, col = "green")
res_fit <- lm(lm_data$error ~ lm_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
error_res_diff <- lm_data$error - lm_res
mean(error_res_diff)
hist(error_res_diff)
# what do residuals behave with lme?
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
library(lme4)
lme_fit <- lm(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
summary(lme_fit)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
summary(lme_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lme_fit, which = 1)
lme_res <- residuals(lme_fit)
mean(lme_res)
sum(lme_res)
plot(lme_res)
hist(lme_res)
var(lme_res)
plot(lme_data$error, lme_res)
abline(0, 1, col = "green")
res_fit <- lm(lme_data$error ~ lme_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
summary(res_fit)
# what do residuals behave with lme?
# added M_re into the linear term
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
library(lme4)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
summary(lme_fit)
plot(lme_fit, which = 1)
lme_res <- residuals(lme_fit)
mean(lme_res)
sum(lme_res)
plot(lme_res)
hist(lme_res)
var(lme_res)
plot(lme_data$error, lme_res)
abline(0, 1, col = "green")
res_fit <- lm(lme_data$error ~ lme_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
# what do residuals behave with lme?
# added M_re into the linear term
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
library(lme4)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
summary(lme_fit)
plot(lme_fit, which = 1)
lme_res <- residuals(lme_fit)
mean(lme_res)
sum(lme_res)
plot(lme_res)
hist(lme_res)
var(lme_res)
plot(lme_data$error, lme_res)
abline(0, 1, col = "green")
res_fit <- lm(lme_data$error ~ lme_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
# what do residuals behave with lme?
# added M_re into the linear term
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
library(lme4)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
summary(lme_fit)
plot(lme_fit, which = 1)
lme_res <- residuals(lme_fit)
mean(lme_res)
sum(lme_res)
plot(lme_res)
hist(lme_res)
var(lme_res)
plot(lme_data$error, lme_res)
abline(0, 1, col = "green")
res_fit <- lm(lme_data$error ~ lme_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits)
nk_id <- formatC(nk, width = max_cluster_digits)
the_data <- one_dataset(~X1 + X2 + X3 + stratum + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
stratum = ~rep(c(0, 1), c(floor(2/3 * k) * nk, ceiling(1/3 * k) * nk))),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(1, -0.7, 0.5, -0.5),
random_effect_variance = list(M = 1)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M, sep = "_" ))
})
pop <- Reduce(rbind.data.frame, pop_list)
# I expect the random effects to have mean = 0 and var = 2.
pop |> dplyr::distinct(id, .keep_all = TRUE) |>
dplyr::summarise(mean(M_re),
var(M_re))
sample <- dplyr::slice_sample(pop, n = 1000)
lm_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + error,
X3 = as.factor(X3))
lm_fit <- lm(y ~ X1 + X2 + X3, data = lm_data)
summary(lm_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lm_data$error, lm_res)
abline(0, 1, col = "green")
res_fit <- lm(lm_data$error ~ lm_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
error_res_diff <- lm_data$error - lm_res
mean(error_res_diff)
hist(error_res_diff)
# what do residuals behave with lme?
# added M_re into the linear term
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
library(lme4)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
# what do residuals behave with lme?
# added M_re into the linear term
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
sample <- dplyr::slice_sample(pop, n = 1000)
# what do residuals behave with lme?
# added M_re into the linear term
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
# what do residuals behave with lme?
# added M_re into the linear term
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
library(lme4)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
summary(lme_fit)
plot(lme_fit, which = 1)
lme_res <- residuals(lme_fit)
mean(lme_res)
sum(lme_res)
plot(lme_res)
hist(lme_res)
var(lme_res)
plot(lme_data$error, lme_res)
abline(0, 1, col = "green")
res_fit <- lm(lme_data$error ~ lme_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
error_res_diff <- lm_data$error - lm_res
mean(error_res_diff)
hist(error_res_diff)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
summary(lme_fit)
plot(lme_fit, which = 1)
lme_res <- residuals(lme_fit)
mean(lme_res)
sample <- dplyr::slice_sample(pop, n = 1000)
lm_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + error,
X3 = as.factor(X3))
lm_fit <- lm(y ~ X1 + X2 + X3, data = lm_data)
summary(lm_fit)
plot(lm_fit, which = 1)
lm_res <- residuals(lm_fit)
mean(lm_res)
sum(lm_res)
plot(lm_res)
hist(lm_res)
var(lm_res)
plot(lm_data$error, lm_res)
abline(0, 1, col = "green")
res_fit <- lm(lm_data$error ~ lm_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
error_res_diff <- lm_data$error - lm_res
mean(error_res_diff)
hist(error_res_diff)
# what do residuals behave with lme?
# added M_re into the linear term
lme_data <- sample |> dplyr::mutate(error = rnorm(dplyr::n(), 0, sqrt(1.5)),
y = X1 * 1 + X2 * -0.7 + X3 * 0.5 + M_re + error,
X3 = as.factor(X3))
library(lme4)
lme_fit <- lmer(y ~ X1 + X2 + X3 + (1 | M), data = lme_data)
summary(lme_fit)
plot(lme_fit, which = 1)
lme_res <- residuals(lme_fit)
mean(lme_res)
sum(lme_res)
plot(lme_res)
hist(lme_res)
var(lme_res)
plot(lme_data$error, lme_res)
abline(0, 1, col = "green")
res_fit <- lm(lme_data$error ~ lme_res)
summary(res_fit)
abline(coef(res_fit), col = "red")
error_res_diff <- lm_data$error - lm_res
mean(error_res_diff)
hist(error_res_diff)
install.packages("redres")
# Installs redres from GitHub
devtools::install_github("goodekat/redres")
