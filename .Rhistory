onerep(control = parCombos[[1]])
onerep <- function(control){
beta = control$beta
theta = control$theta
k = control$k
nk = control$nk
sample_data <- one_dataset(control = list(k = k, nk = nk, beta = beta, theta = theta))
D = my_theta * diag(k)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
start_parameters = c(coef(fit), rep(0, k))
names(start_parameters) <- c(paste0("X", 1:3), paste0("Z", seq_len(k)))
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1))
fit_coxme <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1 | M), data = sample_data,
vfixed = list(M = theta))
data.frame(svycoxme = fit_optim$par[1:3],
coxme = coxme::fixef(fit_coxme))
}
onerep(control = parCombos[[1]])
lapply(parCombos, onerep)
cl <- parallel::makeCluster(parallel::detectCores()-1)
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
fits <- parallel::parLapply(cl, parCombos)
fits <- parallel::parLapply(cl, parCombos, onerep)
parallel::clusterEvalQ(cl, {
devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
})
fits <- parallel::parLapply(cl, parCombos, onerep)
parCombos <- rep(list(list(
beta = c(X1 = 1, X2 = -0.7, X3 = 0.5),
theta = 0.2,
k = 100,
nk = 10)),
2)
onerep <- function(control){
beta = control$beta
theta = control$theta
k = control$k
nk = control$nk
sample_data <- one_dataset(control = list(k = k, nk = nk, beta = beta, theta = theta))
D = theta * diag(k)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
start_parameters = c(coef(fit), rep(0, k))
names(start_parameters) <- c(paste0("X", 1:3), paste0("Z", seq_len(k)))
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1))
fit_coxme <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1 | M), data = sample_data,
vfixed = list(M = theta))
data.frame(svycoxme = fit_optim$par[1:3],
coxme = coxme::fixef(fit_coxme))
}
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
fits <- parallel::parLapply(cl, parCombos, onerep)
#stop the cluster
parallel::stopCluster(cl)
fits
parCombos <- rep(list(list(
beta = c(X1 = 1, X2 = -0.7, X3 = 0.5),
theta = 0.2,
k = 100,
nk = 10)),
1000)
onerep <- function(control){
beta = control$beta
theta = control$theta
k = control$k
nk = control$nk
sample_data <- one_dataset(control = list(k = k, nk = nk, beta = beta, theta = theta))
D = theta * diag(k)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
start_parameters = c(coef(fit), rep(0, k))
names(start_parameters) <- c(paste0("X", 1:3), paste0("Z", seq_len(k)))
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1))
fit_coxme <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1 | M), data = sample_data,
vfixed = list(M = theta))
data.frame(svycoxme = fit_optim$par[1:3],
coxme = coxme::fixef(fit_coxme))
}
onerep(control = parCombos[[1]])
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
})
fits <- parallel::parLapply(cl, parCombos, onerep)
#stop the cluster
parallel::stopCluster(cl)
parCombos <- rep(list(list(
beta = c(X1 = 1, X2 = -0.7, X3 = 0.5),
theta = 0.2,
k = 100,
nk = 10)),
10)
onerep <- function(control){
beta = control$beta
theta = control$theta
k = control$k
nk = control$nk
sample_data <- one_dataset(control = list(k = k, nk = nk, beta = beta, theta = theta))
D = theta * diag(k)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
start_parameters = c(coef(fit), rep(0, k))
names(start_parameters) <- c(paste0("X", 1:3), paste0("Z", seq_len(k)))
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1))
fit_coxme <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1 | M), data = sample_data,
vfixed = list(M = theta))
data.frame(svycoxme = fit_optim$par[1:3],
coxme = coxme::fixef(fit_coxme))
}
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("onerep"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
parallel::clusterEvalQ(cl, {
devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
})
fits <- parallel::parLapply(cl, parCombos, onerep)
#stop the cluster
parallel::stopCluster(cl)
fits_df = purrr::reduce(fits, dplyr::bind_rows)
fits_df
res <- readr::read_rds(file = "C://Users/bdra011/OneDrive - The University of Auckland/PhD/outputs/simulations/data/results_optim_vs_coxph.rds")
res
library(tidyverse)
res %>%
pivot_longer()
res %>%
pivot_longer(cols = everything())
res %>%
rownames_to_column()
res %>%
rownames_to_column() %>%
mutate(coef = substr(rowname, 1, 2))
res %>%
res %>%
rownames_to_column() %>%
mutate(coef = substr(rowname, 1, 2), .before = everything()) %>%
select(-rowname) %>%
pivot_longer(cols = c("svycoxme", "coxme"))
tidyres <- res %>%
rownames_to_column() %>%
mutate(coef = substr(rowname, 1, 2), .before = everything()) %>%
select(-rowname) %>%
pivot_longer(cols = c("svycoxme", "coxme"))
ggplot(tidyres, aes(value, colour = name)) + facet_grid(cols = vars(coef))
ggplot(tidyres, aes(value, colour = name)) + geom_density() + facet_grid(cols = vars(coef))
ggplot(tidyres, aes(value, colour = name)) + geom_boxplot() + facet_grid(cols = vars(coef))
res <- readr::read_rds(file = "C://Users/bdra011/OneDrive - The University of Auckland/PhD/outputs/simulations/data/results_optim_vs_coxph.rds")
library(tidyverse)
tidyres <- res %>%
rownames_to_column() %>%
mutate(coef = substr(rowname, 1, 2), .before = everything()) %>%
select(-rowname) %>%
pivot_longer(cols = c("svycoxme", "coxme"))
ggplot(tidyres, aes(value, colour = name)) + geom_density() + facet_grid(cols = vars(coef))
ggplot(tidyres, aes(value, colour = name)) + geom_boxplot() + facet_grid(cols = vars(coef))
tidyres
tidyres %>%
group_by(coef, name) %>%
summarise(mean(value))
tidyres %>%
group_by(coef, name) %>%
summarise(mean = mean(value)) %>%
pivot_wider(names_from = name, values_from = mean)
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 50
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
my_parms <- c(my_beta, b <- attr(sample_data, "random_effects"))
D = my_theta * diag(length(b))
devtools::load_all(".")
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 50
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
my_parms <- c(my_beta, b <- attr(sample_data, "random_effects"))
D = my_theta * diag(length(b))
Z_matrix <- model.matrix( ~ as.factor(M) - 1, data = sample_data)
colnames(Z_matrix) <- paste0("Z", seq(ncol(Z_matrix)))
data_with_Z <- dplyr::bind_cols(sample_data, data.frame(Z_matrix))
d2 <- sortAndIndex(data_with_Z, t)
d3 <- calcLinearPredictor(data = d2, X = c("X1", "X2", "X3"), Z = colnames(Z_matrix), parms = my_parms)
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 50
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
my_parms <- c(my_beta, b <- attr(sample_data, "random_effects"))
D = my_theta * diag(length(b))
Z_matrix <- model.matrix( ~ as.factor(M) - 1, data = sample_data)
colnames(Z_matrix) <- paste0("Z", seq(ncol(Z_matrix)))
data_with_Z <- dplyr::bind_cols(sample_data, data.frame(Z_matrix))
d2 <- sortAndIndex(data_with_Z, t)
d3 <- calcLinearPredictor(data = d2, X = c("X1"), Z = colnames(Z_matrix), parms = my_parms)
d3 <- calcLinearPredictor(data = d2, X = c("X1"), Z = colnames(Z_matrix), parms = my_parms[c(-2, -3)])
d4 <- calcRiskSets(d3)
d4 <- calcRiskSets(d3, vars = "X1", varCol = "Xr")
d4
d5 <-
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3, data = sample_data)
d5 <- calcCrossProducts(d2, "X1", "X1", "Xr", "Xs")
d5
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 20
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
my_parms <- c(my_beta, b <- attr(sample_data, "random_effects"))
D = my_theta * diag(length(b))
Z_matrix <- model.matrix( ~ as.factor(M) - 1, data = sample_data)
colnames(Z_matrix) <- paste0("Z", seq(ncol(Z_matrix)))
data_with_Z <- dplyr::bind_cols(sample_data, data.frame(Z_matrix))
d2 <- sortAndIndex(data_with_Z, t)
d3 <- calcLinearPredictor(data = d2, X = c("X1"), Z = colnames(Z_matrix), parms = my_parms[c(-2, -3)])
d4 <- calcRiskSets(d3, vars = "X1", varCol = "Xr")
d5 <- calcCrossProducts(d2, "X1", "X1", "Xr", "Xs")
d5
left_join(d4, d5, by = "index")
library(tidyverse)
d6 <- left_join(d4, d5, by = "index")
d6
419^2
d6$cumsum_A[1]
(d6$cumsum_A[1])^2
d6 %>%
arrange(desc(index)) %>%
mutate(XrXs_A = XrXs * A)
d6 %>%
arrange(desc(index)) %>%
mutate(XrXs_A = XrXs * A,
cumsum_XrXs_A = cumsum(XrXs_A))
d6 %>%
arrange(desc(index)) %>%
mutate(XrXs_A = XrXs * A,
cumsum_XrXs_A = cumsum(XrXs_A)) %>%
arrange(index)
d7 <- d6 %>%
arrange(desc(index)) %>%
mutate(XrXs_A = XrXs * A,
cumsum_XrXs_A = cumsum(XrXs_A)) %>%
arrange(index)
d7 %>%
mutate(
ll_parts = (cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/ cumsum_A
)
d7 %>%
mutate(
ll_parts = (cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/ cumsum_A
) %>%
summarise(sum(ll_parts))
coxme::coxme(survival::Surv(t, stat) ~ X1 + (1|M))
coxme::coxme(survival::Surv(t, stat) ~ X1 + (1|M), data = sample_data)
fit_coxme <- coxme::coxme(survival::Surv(t, stat) ~ X1 + (1|M), data = sample_data)
fit_coxme$hmat
fit <- survival::coxph(survival::Surv(t, stat) ~ X1, data = sample_data)
start_parameters = c(coef(fit), rep(0, length(b)))
names(start_parameters) <- c("X1", paste0("Z", seq_len(length(b))))
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1))
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1),
hessian = TRUE)
fit_optim$hessian
fit_coxme$hmat
solve(fit_optim$hessian)
d7 %>%
mutate(
ll_parts = (cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/ cumsum_A
) %>%
summarise(sum(ll_parts))
d7 %>%
mutate(
ll_parts = (cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/ cumsum_A
) %>%
summarise(1/sum(ll_parts))
d7 %>%
mutate(
ll_parts = stat * ((cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/cumsum_A)
) %>%
summarise(1/sum(ll_parts))
d7 %>%
mutate(
ll_parts = stat * ((cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/cumsum_A)
) %>%
summarise(sum(ll_parts))
solve(fit_optim$hessian)
fit_optim$hessian
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1),
hessian = TRUE)
fit_optim$hessian
my_beta = c(1, -0.7, 0.5)
my_theta = 0.2
my_k = 10
my_nk = 20
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
my_parms <- c(my_beta, b <- attr(sample_data, "random_effects"))
D = my_theta * diag(length(b))
Z_matrix <- model.matrix( ~ as.factor(M) - 1, data = sample_data)
colnames(Z_matrix) <- paste0("Z", seq(ncol(Z_matrix)))
data_with_Z <- dplyr::bind_cols(sample_data, data.frame(Z_matrix))
d2 <- sortAndIndex(data_with_Z, t)
d3 <- calcLinearPredictor(data = d2, X = c("X1"), Z = colnames(Z_matrix), parms = my_parms[c(-2, -3)])
d4 <- calcRiskSets(d3, vars = "X1", varCol = "Xr")
d5 <- calcCrossProducts(d2, "X1", "X1", "Xr", "Xs")
d6 <- left_join(d4, d5, by = "index")
d7 <- d6 %>%
arrange(desc(index)) %>%
mutate(XrXs_A = XrXs * A,
cumsum_XrXs_A = cumsum(XrXs_A)) %>%
arrange(index)
d7 %>%
mutate(
ll_parts = stat * ((cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/cumsum_A)
) %>%
summarise(sum(ll_parts))
fit_coxme <- coxme::coxme(survival::Surv(t, stat) ~ X1 + (1|M), data = sample_data)
fit_coxme$hmat
fit <- survival::coxph(survival::Surv(t, stat) ~ X1, data = sample_data)
start_parameters = c(coef(fit), rep(0, length(b)))
names(start_parameters) <- c("X1", paste0("Z", seq_len(length(b))))
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1),
hessian = TRUE)
fit_optim$hessian
fit_optim$hessian["X1", "X1"]
d7 %>%
mutate(
ll_parts = stat * ((cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/cumsum_A)
) %>%
summarise(sum(ll_parts))
d7 %>%
mutate(
ll_parts = stat * ((cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/cumsum_A)
) %>%
summarise(ll = sum(ll_parts)) %>%
pull(ll)
fit_optim$hessian["X1", "X1"]
one_rep <- function(){
sample_data <- one_dataset(control = list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
my_parms <- c(my_beta, b <- attr(sample_data, "random_effects"))
D = my_theta * diag(length(b))
Z_matrix <- model.matrix( ~ as.factor(M) - 1, data = sample_data)
colnames(Z_matrix) <- paste0("Z", seq(ncol(Z_matrix)))
data_with_Z <- dplyr::bind_cols(sample_data, data.frame(Z_matrix))
d2 <- sortAndIndex(data_with_Z, t)
d3 <- calcLinearPredictor(data = d2, X = c("X1"), Z = colnames(Z_matrix), parms = my_parms[c(-2, -3)])
d4 <- calcRiskSets(d3, vars = "X1", varCol = "Xr")
d5 <- calcCrossProducts(d2, "X1", "X1", "Xr", "Xs")
d6 <- left_join(d4, d5, by = "index")
d7 <- d6 %>%
arrange(desc(index)) %>%
mutate(XrXs_A = XrXs * A,
cumsum_XrXs_A = cumsum(XrXs_A)) %>%
arrange(index)
by_hand_hess_X1 <- d7 %>%
mutate(
ll_parts = stat * ((cumsum_Xr_A^2)/(cumsum_A)^2 - cumsum_XrXs_A/cumsum_A)
) %>%
summarise(ll = sum(ll_parts)) %>%
pull(ll)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1, data = sample_data)
start_parameters = c(coef(fit), rep(0, length(b)))
names(start_parameters) <- c("X1", paste0("Z", seq_len(length(b))))
fit_optim <- optim(par = start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1"),
t = t,
cluster = "M",
dij = stat,
D = D,
data = sample_data,
method = "BFGS",
control = list(fnscale = -1),
hessian = TRUE)
data.frame(analytical = by_hand_hess_X1,
numerical = fit_optim$hessian["X1", "X1"])
}
one_rep()
replicate(2, one_rep(), simplify = "matrix")
tests <- replicate(100, one_rep(), simplify = "matrix")
t(tests) %>%
data.frame() %>%
mutate(diff = analytical - numerical)
t(tests) %>%
data.frame()
t(tests) %>%
data.frame() %>% str()
t(tests) %>%
mutate(diff = analytical - numerical)
t(tests)
t(tests) %>% as_tibble()
tests
str(tests)
unlist(tests)
tests
matrix(unlist(tests),nc = 2, byrow = TRUE)
matrix(unlist(tests),nc = 2, byrow = TRUE) %>%
as.data.frame(colnames = c("analytical", "numerical"))
matrix(unlist(tests),nc = 2, byrow = TRUE) %>%
data.frame(colnames = c("analytical", "numerical"))
matrix(unlist(tests),nc = 2, byrow = TRUE) %>%
as.data.frame(col.names = c("analytical", "numerical"))
matrix(unlist(tests),nc = 2, byrow = TRUE) %>%
as.data.frame(col.names = c("analytical", "numerical"))
matrix(unlist(tests),nc = 2, byrow = TRUE) %>%
data.frame(col.names = c("analytical", "numerical"))
test_df <- matrix(unlist(tests),nc = 2, byrow = TRUE) %>%
as.data.frame(col.names = c("analytical", "numerical"))
colnames(test_df)
test_df <- matrix(unlist(tests),nc = 2, byrow = TRUE) %>% as.data.frame()
colnames(test_df)  <- c("analytical", "numerical")
tests_df <- matrix(unlist(tests),nc = 2, byrow = TRUE) %>% as.data.frame()
colnames(tests_df)  <- c("analytical", "numerical")
tests_df
tests_df %>%
mutate(diff = analytical - numerical)
tests_df %>%
mutate(diff = analytical - numerical) %>%
ggplot(aes(x = diff)) + geom_density()
tests_df %>%
mutate(diff = analytical - numerical) %>%
summarise(mean(diff))
chol(fit_optim$hessian)
diag(fit_optim$hessian)
diag(diag(fit_optim$hessian))
chol(diag(diag(fit_optim$hessian)))
chol(diag(diag(-fit_optim$hessian)))
fit_coxme$hmat
