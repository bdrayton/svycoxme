upper = 1000,
hessian = TRUE)
fit_theta$hessian
kbb <- bb(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
theta = ests$new_theta,
cluster = M,
data = ds,
return_matrix = TRUE)
kbb <- bb(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
theta = ests$new_theta,
cluster = "M",
data = ds,
return_matrix = TRUE)
kbb
solve(kbb)
sum(diag(solve(kbb)))
ests$new_beta_b[-seq_along(my_X)]
inner(ests$new_beta_b[-seq_along(my_X)])
inner(ests$new_beta_b[-seq_along(my_X)]) + sum(diag(solve(kbb)))
t(ests$new_beta_b[-seq_along(my_X)]) %*% ests$new_beta_b[-seq_along(my_X)]
sum(diag(solve(kbb)))
the <- ests$new_theta
the
inner(ests$new_beta_b[-seq_along(my_X)]) + sum(diag(solve(kbb)))
(inner(ests$new_beta_b[-seq_along(my_X)]) + sum(diag(solve(kbb))))/length(my_k)
length(my_k)
(inner(ests$new_beta_b[-seq_along(my_X)]) + sum(diag(solve(kbb))))/my_k
(inner(ests$new_beta_b[-seq_along(my_X)]) - sum(diag(solve(kbb))))/my_k
# closed form for theta
(inner(ests$new_beta_b[-seq_along(my_X)]) - sum(diag(solve(kbb))))/my_k
2 * the^@
theta_ipl_gr(one_theta = ests$new_theta,
parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = "M",
data = ds)
2 * the^2
q <- my_k
q
kbb_inv <- solve(kbb)
2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv * kbb_inv)) - (2/the) * sum(diag(kbb_inv)) )^(-1)
2 * the^2 * (q - (1/the^2) * sum(diag(kbb_inv * kbb_inv)) + (2/the) * sum(diag(kbb_inv)) )^(-1)
# should i change the sign here too?
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv * kbb_inv)) - (2/the) * sum(diag(kbb_inv)) )^(-1)
1/the_var
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
ds <- one_dataset(list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit0 <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2 + X3, data = ds)
my_start_parameters <- c(coef(fit0), rep(0, my_k))
names(my_start_parameters) <- c(my_X, paste0("Z", seq_len(my_k)))
test_loop <- estimate_parameters_loop(start_theta = 0.5,
start_parms = my_start_parameters,
X = my_X,
stat_time = stat_time,
cluster = "M",
dij = stat,
data = ds, max_iter = 200)
ests <- tail(test_loop$estimate_history, 1)[[1]]
fit_theta <- optim(par = ests$new_theta,
fn = theta_ipl,
gr = theta_ipl_gr,
parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = 'M',
data = ds,
method = "L-BFGS-B",
control = list(fnscale = -1),
lower = 0.00001,
upper = 1000,
hessian = TRUE)
fit_theta$hessian
solve(fit_theta$hessian)
solve(-fit_theta$hessian)
fit_theta
ests
solve(-fit_theta$hessian)
kbb <- bb(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
theta = ests$new_theta,
cluster = "M",
data = ds,
return_matrix = TRUE)
# closed form for theta
(inner(ests$new_beta_b[-seq_along(my_X)]) - sum(diag(solve(kbb))))/my_k
the <- ests$new_theta
q <- my_k
kbb_inv <- solve(kbb)
# should i change the sign here too?
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv * kbb_inv)) - (2/the) * sum(diag(kbb_inv)) )^(-1)
the_var
solve(-fit_theta$hessian)
# should i change the sign here too?
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)) )^(-1)
the_va
the_var
the^2
2 * the^2
q
(1/the^2) * sum(diag(kbb_inv %*% kbb_inv))
(2/the) * sum(diag(kbb_inv))
2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)) )
-fit_theta$hessian
(q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)) )^(-1)
2 * the^2 *
# should i change the sign here too?
the_var <- 2 * the^2 * ((q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)) )^(-1))
the_var
# should i change the sign here too?
the_var <- (2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)) ))^(-1)
the_var
# should i change the sign here too?
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)))^(-1)
the_var
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
ds <- one_dataset(list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit0 <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2 + X3, data = ds)
devtools::load_all(".")
ds <- one_dataset(list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit0 <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2 + X3, data = ds)
my_start_parameters <- c(coef(fit0), rep(0, my_k))
names(my_start_parameters) <- c(my_X, paste0("Z", seq_len(my_k)))
test_loop <- estimate_parameters_loop(start_theta = 0.5,
start_parms = my_start_parameters,
X = my_X,
stat_time = stat_time,
cluster = "M",
dij = stat,
data = ds, max_iter = 200)
ests <- tail(test_loop$estimate_history, 1)[[1]]
fit_theta <- optim(par = ests$new_theta,
fn = theta_ipl,
gr = theta_ipl_gr,
parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = 'M',
data = ds,
method = "L-BFGS-B",
control = list(fnscale = -1),
lower = 0.00001,
upper = 1000,
hessian = TRUE)
solve(-fit_theta$hessian)
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
ds <- one_dataset(list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit <- coxme::coxme(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1|M), data = ds)
coxme_est_theta <- coxme::VarCorr(fit)$M
coxme_est_parms <- c(coxme::fixef(fit), coxme::ranef(fit)$M)
parm_names <- c(my_X, paste0("Z", seq_len(my_k)))
names(coxme_est_parms) <- parm_names
my_loglik <- lp(parms = coxme_est_parms,
X = my_X,
cluster = "M",
stat_time = stat_time,
dij = stat,
theta = coxme_est_theta,
data = ds)
# what is the difference between our log likelihoods?
fit$loglik["Penalized"] - my_loglik
# and penalties?
fit$penalty - attr(my_loglik, "penalty")
my_u <- lp_grd(parms = coxme_est_parms,
X = c("X1", "X2", "X3"),
cluster = "M",
stat_time = stat_time,
dij = stat,
theta = coxme_est_theta,
data = ds)
ordered_coxme_u <-
tibble::tibble(coxme_u = fit$u,
coxme_u_order = seq_along(coxme_u)) %>%
dplyr::arrange(coxme_u)
ordered_my_u <-
tibble::tibble(parm = parm_names,
my_u = my_u) %>%
dplyr::arrange(my_u)
# it looks like the only reordering is to put the fixed effects after the random effects.
dplyr::bind_cols(
ordered_coxme_u,
ordered_my_u) %>%
dplyr::arrange( coxme_u_order) %>%
dplyr::pull(parm)
my_hessian <- svycoxme::ppl_hessian(parms = coxme_est_parms,
X = c("X1", "X2", "X3"),
cluster = "M",
stat_time = stat_time,
dij = stat,
theta = coxme_est_theta,
data = ds)
reordered_names <- colnames(my_hessian)[c(seq_len(my_k) + 3, 1:3)]
reord_hessian <- my_hessian[reordered_names, reordered_names]
# decompose my hessian
library(bdsmatrix)
gchol_reord_hessian <- gchol(reord_hessian)
gchol_my_hessian <- gchol(my_hessian)
L <- as.matrix(gchol_reord_hessian)
D <- diag(gchol_reord_hessian)
# maximum error
max(L %*% diag(D) %*% t(L) - reord_hessian)
L <- as.matrix(fit$hmat)
D <- diag(fit$hmat)
back_trans_hmat <- L %*% diag(D) %*% t(L)
back_trans_hmat - (-1 * reord_hessian)
max(back_trans_hmat - (-1 * reord_hessian))
vcov(fit)
solve(-my_hessian)[1:3, 1:3]
# some calculations require the random effects part of the hessian, so
# I need to be able to recover that part.
back_trans_hmat
# this is the back-transformed hmat.
solve(back_trans_hmat)
# this is the back-transformed hmat.
solve(-back_trans_hmat)
solve(-back_trans_hmat)
solve(-back_trans_hmat)[seq_len(my_k), seq_len(my_k)]
# can I do this with my hessian?
solve(-my_hessian)
# can I do this with my hessian?
solve(-my_hessian)[-seq_along(my_X), -seq_along(my_X)]
solve(-back_trans_hmat)[seq_len(my_k), seq_len(my_k)]
# can I do this with my hessian?
solve(-my_hessian)[-seq_along(my_X), -seq_along(my_X)]
solve(-back_trans_hmat)[seq_len(my_k), seq_len(my_k)]
# can I do this with my hessian? Yes, e rua, e rua
solve(-my_hessian)[-seq_along(my_X), -seq_along(my_X)]
# can I do this with my hessian? Yes, e rua, e rua, aside from the signs.
solve(-my_hessian)[-seq_along(my_X), -seq_along(my_X)]
# what happens if you subset then invert?
solve(-my_hessian[-seq_along(my_X), -seq_along(my_X)])
# can I do this with my hessian? Yes, e rua, e rua, aside from the signs.
h22_a <- solve(-my_hessian)[-seq_along(my_X), -seq_along(my_X)]
# what happens if you subset then invert?
h22_b <- solve(-my_hessian[-seq_along(my_X), -seq_along(my_X)])
# can I do this with my hessian? Yes, e rua, e rua, aside from the signs.
h22_a <- solve(-my_hessian)[-seq_along(my_X), -seq_along(my_X)]
# what happens if you subset then invert?
h22_b <- solve(-my_hessian[-seq_along(my_X), -seq_along(my_X)])
sum(diag(h22_a))
sum(diag(h22_b))
kbb <- bb(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
theta = ests$new_theta,
cluster = "M",
data = ds,
return_matrix = TRUE)
kbb
# closed form for theta
(inner(ests$new_beta_b[-seq_along(my_X)]) - sum(diag(solve(kbb))))/my_k
ests$new_theta
# closed form for theta
(inner(ests$new_beta_b[-seq_along(my_X)]) + sum(diag(solve(kbb))))/my_k
my_beta = c(1, -0.7, 0.5)
my_theta = 1
my_k = 10
my_nk = 10
my_X = c("X1", "X2", "X3")
ds <- one_dataset(list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit0 <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2 + X3, data = ds)
my_start_parameters <- c(coef(fit0), rep(0, my_k))
names(my_start_parameters) <- c(my_X, paste0("Z", seq_len(my_k)))
test_loop <- estimate_parameters_loop(start_theta = 0.5,
start_parms = my_start_parameters,
X = my_X,
stat_time = stat_time,
cluster = "M",
dij = stat,
data = ds)
ests <- tail(test_loop$estimate_history, 1)[[1]]
fit_theta <- optim(par = ests$new_theta,
fn = theta_ipl,
gr = theta_ipl_gr,
parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = 'M',
data = ds,
method = "L-BFGS-B",
control = list(fnscale = -1),
lower = 0.00001,
upper = 1000,
hessian = TRUE)
q <- nrow(kbb)
q
fit_theta
solve(-fit_theta$hessian)
kbb <- bb(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
theta = ests$new_theta,
cluster = "M",
data = ds,
return_matrix = TRUE)
q <- nrow(kbb)
# closed form for theta
(inner(ests$new_beta_b[-seq_along(my_X)]) - sum(diag(solve(kbb))))/q
# closed form for theta
(inner(ests$new_beta_b[-seq_along(my_X)]) - sum(diag(solve(kbb))))/q
the <- ests$new_theta
kbb_inv <- solve(kbb)
# should i change the sign here too? need to check this expression
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)))^(-1)
the_var
solve(-fit_theta$hessian)
D_inv <- solve(the * diag(q))
D_inv
D_inv %*% D_inv + D_inv
sum(diag(D_inv %*% D_inv + D_inv))
sum(diag( D_inv %*% D_inv + D_inv )) + sum(diag( kbb_inv %*% kbb_inv - kbb_inv ))
0.5 * (sum(diag( D_inv %*% D_inv + D_inv )) + sum(diag( kbb_inv %*% kbb_inv - kbb_inv )))
I <- 0.5 * (sum(diag( D_inv %*% D_inv + D_inv )) + sum(diag( kbb_inv %*% kbb_inv - kbb_inv )))
I^-1
the_var
solve(-fit_theta$hessian)
I <- 0.5 * (sum(diag( D_inv %*% D_inv + D_inv )) +
sum(diag( kbb_inv %*% D_inv %*% D_inv %*% kbb_inv %*% D_inv %*% D_inv - 2 * kbb_inv %*% D_inv %*% D_inv %*% D_inv )))
I^-1
solve(-fit_theta$hessian)
the_var
I <- (sum(diag( D_inv %*% D_inv + D_inv )) +
sum(diag( kbb_inv %*% D_inv %*% D_inv %*% kbb_inv %*% D_inv %*% D_inv - 2 * kbb_inv %*% D_inv %*% D_inv %*% D_inv )))
I^-1
I <- 0.5 * (sum(diag( D_inv %*% D_inv + D_inv )) +
sum(diag( kbb_inv %*% D_inv %*% D_inv %*% kbb_inv %*% D_inv %*% D_inv - 2 * kbb_inv %*% D_inv %*% D_inv %*% D_inv )))
I^-1
the_var
I^-1
solve(-fit_theta$hessian)
# should i change the sign here too? need to check this expression
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)))
the_var
fit_theta$hessian
solve(-fit_theta$hessian)
the_var^-1
# should i change the sign here too? need to check this expression
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)))
the_var
# should i change the sign here too? need to check this expression
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)))^-1
the_var
# should i change the sign here too? need to check this expression
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)))
the_var^-1
q <- nrow(kbb)
kbb_inv <- solve(kbb)
# closed form for theta
(inner(ests$new_beta_b[-seq_along(my_X)]) - sum(diag(kbb_inv)))/q
fit_theta
ests$new_theta
fit_theta$par
ests$new_theta == fit_theta$par
ests$new_theta - fit_theta$par
the <- ests$new_theta
# should i change the sign here too? need to check this expression
the_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)))^-1
the_var
BB(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
theta = ests$new_theta,
cluster = "M",
data = ds,
return_matrix = TRUE)
kbb <- bb(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = "M",
data = ds)
BB(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = "M",
data = ds)
devtools::load_all(".")
BB(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = "M",
data = ds)
BB(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = "M",
data = ds,)
devtools::load_all(".")
BB(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = "M",
data = ds, return_matrix = TRUE)
kBB <- BB(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = "M",
data = ds,
return_matrix = TRUE)
kBB
diag(solve(-kBB))
devtools::load_all(".")
# global pars
max_iterations <- 10 # max iterations for the estimation loop
# global pars
max_iterations <- 1000 # max iterations for the estimation loop
nreps <- 1 # replicates for each parameter combo
par_combos_df <- expand.grid(k = 50, nk = c(4, 10), theta = c(0.5, 1, 2))
par_combos_list <- split(control_df, seq_len(nrow(control_df)))
par_combos_df <- expand.grid(k = 50, nk = c(4, 10), theta = c(0.5, 1, 2))
par_combos_df <- expand.grid(k = 50, nk = c(4, 10), theta = c(0.5, 1, 2))
par_combos_list <- split(par_combos_df, seq_len(nrow(control_df)))
par_combos_list <- split(par_combos_df, seq_len(nrow(par_combos_df)))
par_combos_list <- lapply(control_list, function(one_par){
one_list <- as.list(one_par)
append(one_list, list(beta = c(1, -0.5, 0.7),
X = c("X1", "X2", "X3")))
})
par_combos_list <- lapply(par_combos_list, function(one_par){
one_list <- as.list(one_par)
append(one_list, list(beta = c(1, -0.5, 0.7),
X = c("X1", "X2", "X3")))
})
par_combos_list
par_combos_list_replicated <- rep(par_combos_list, nreps)
par_combos_list_replicated[[1]]
one_rep <- function(control){
my_k <- control$k
my_nk <- control$nk
my_beta <- control$beta
my_theta <- control$theta
my_X <- control$X
ds <- one_dataset(list(k = my_k, nk = my_nk, beta = my_beta, theta = my_theta))
fit0 <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2 + X3, data = ds)
my_start_parameters <- c(coef(fit0), rep(0, my_k))
names(my_start_parameters) <- c(my_X, paste0("Z", seq_len(my_k)))
test_loop <- estimate_parameters_loop(start_theta = 0.5,
start_parms = my_start_parameters,
X = my_X,
stat_time = stat_time,
cluster = "M",
dij = stat,
data = ds, max_iter = max_iterations)
ests <- tail(test_loop$estimate_history, 1)[[1]]
####
kbb <- bb(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
theta = ests$new_theta,
cluster = "M",
data = ds,
return_matrix = TRUE)
kBB <- BB(parms = ests$new_beta_b,
X = my_X,
stat_time = stat_time,
dij = stat,
cluster = "M",
data = ds,
return_matrix = TRUE)
fixed_effects_var <- diag(solve(-kBB))
q <- nrow(kbb)
kbb_inv <- solve(kbb)
the <- ests$new_theta
theta_var <- 2 * the^2 * (q + (1/the^2) * sum(diag(kbb_inv %*% kbb_inv)) - (2/the) * sum(diag(kbb_inv)))^-1
####
list(
fixed_effects = ests$new_beta_b[seq_along(my_X)],
random_effects = ests$new_beta_b[-seq_along(my_X)],
theta = ests$new_theta,
fixed_effects_var = fixed_effects_var,
theta_var = theta_var
)
}
one_rep(par_combos_list_replicated[[1]])
devtools::load_all(".")
results_replicate_ripatti_table <- readRDS("C:/Users/bdra011/OneDrive - The University of Auckland/PhD/outputs/simulations/data/results_replicate_ripatti_table.rds")
View(results_replicate_ripatti_table)
sqrt(0.00959)
2*sqrt(0.00959)
