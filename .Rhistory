dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
#
# data.frame(model = rep(c("coxph_weighted_robust", "svycoxph", "svycoxph_rep"), each = length(true_coefs)),
#            X = names(coef(svycoxph_fit_d2)),
#            true_value = true_coefs,
#            estimate = c(coef(coxph_robust_fit_d2),
#                         coef(svycoxph_fit_d2),
#                         coef(svycoxph_rep_fit_d2)),
#            rbind(confint(coxph_robust_fit_d2),
#                  confint(svycoxph_fit_d2),
#                  confint(svycoxph_rep_fit_d2))) |>
#   dplyr::mutate(error = estimate - true_value,
#                 hit = true_value >= X2.5.. & true_value <= X97.5..)
}
one_rep()
library(survey)
one_rep <- function(){
sample_clusters <- dplyr::bind_rows(
pop |>
dplyr::filter(stratum == 0) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
#
# data.frame(model = rep(c("coxph_weighted_robust", "svycoxph", "svycoxph_rep"), each = length(true_coefs)),
#            X = names(coef(svycoxph_fit_d2)),
#            true_value = true_coefs,
#            estimate = c(coef(coxph_robust_fit_d2),
#                         coef(svycoxph_fit_d2),
#                         coef(svycoxph_rep_fit_d2)),
#            rbind(confint(coxph_robust_fit_d2),
#                  confint(svycoxph_fit_d2),
#                  confint(svycoxph_rep_fit_d2))) |>
#   dplyr::mutate(error = estimate - true_value,
#                 hit = true_value >= X2.5.. & true_value <= X97.5..)
}
one_rep()
res <- one_rep()
res$var
res$vvar
devtools::load_all(".")
devtools::load_all(".")
.libPaths()
library(MuMIn)
remove.packages("MuMIn")
devtools::load_all(".")
my_theta <- 0.1
cluster_str <- data.frame(table(Size = rpois(2.5e5, 2) + 2)) |>
dplyr::filter(Freq >=10)
cluster_str_list <- split(cluster_str, seq(nrow(cluster_str)))
max_cluster_digits <- max(nchar(as.character(cluster_str$Size)))
max_cluster_freq_digits <- max(nchar(as.character(cluster_str$Freq)))
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits)
nk_id <- formatC(nk, width = max_cluster_digits)
the_data <- one_dataset(~X1 + X2 + X3 + stratum + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
stratum = ~rep(c(0, 1), c(floor(2/3 * k) * nk, ceiling(1/3 * k) * nk))),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(1, -0.7, 0.5, -1),
random_effect_variance = c(M=0.1)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M, sep = "_" ))
})
pop <- Reduce(rbind.data.frame, pop_list)
true_coefs = c(1, -0.7, 0.5, -1)
library(survey)
one_rep <- function(){
sample_clusters <- dplyr::bind_rows(
pop |>
dplyr::filter(stratum == 0) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
#
# data.frame(model = rep(c("coxph_weighted_robust", "svycoxph", "svycoxph_rep"), each = length(true_coefs)),
#            X = names(coef(svycoxph_fit_d2)),
#            true_value = true_coefs,
#            estimate = c(coef(coxph_robust_fit_d2),
#                         coef(svycoxph_fit_d2),
#                         coef(svycoxph_rep_fit_d2)),
#            rbind(confint(coxph_robust_fit_d2),
#                  confint(svycoxph_fit_d2),
#                  confint(svycoxph_rep_fit_d2))) |>
#   dplyr::mutate(error = estimate - true_value,
#                 hit = true_value >= X2.5.. & true_value <= X97.5..)
}
res <- one_rep()
res$vvar
one_rep <- function(){
sample_clusters <- dplyr::bind_rows(
pop |>
dplyr::filter(stratum == 0) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme_fit <- svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
svycoxme_theta <- unlist(coxme::VarCorr(svycoxme_fit))
ci = svycoxme_theta + sqrt(diag(svycoxme_fit$vvar)) %o% qt(c(0.025, 0.975), Inf)
colnames(ci) <- c("lower", "upper")
data.frame(coxme_theta = unlist(coxme::VarCorr(coxme_fit)),
svycoxme_theta = svycoxme_theta, ci)
}
res <- one_rep()
one_rep <- function(){
sample_clusters <- dplyr::bind_rows(
pop |>
dplyr::filter(stratum == 0) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme_fit <- svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
svycoxme_theta <- unlist(coxme::VarCorr(svycoxme_fit))
ci = svycoxme_theta + sqrt(diag(svycoxme_fit$vvar)) %o% qt(c(0.025, 0.975), Inf)
colnames(ci) <- c("lower", "upper")
data.frame(coxme_theta = unlist(coxme::VarCorr(svycoxme_fit)),
svycoxme_theta = svycoxme_theta, ci)
}
res <- one_rep()
res
one_rep <- function(){
sample_clusters <- dplyr::bind_rows(
pop |>
dplyr::filter(stratum == 0) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme_fit <- svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
svycoxme_theta <- unlist(coxme::VarCorr(svycoxme_fit))
ci = svycoxme_theta + sqrt(diag(svycoxme_fit$vvar)) %o% qt(c(0.025, 0.975), Inf)
colnames(ci) <- c("lower", "upper")
data.frame(svycoxme_theta = svycoxme_theta, ci)
}
res <- one_rep()
(res <- one_rep())
one_rep <- function(){
sample_clusters <- dplyr::bind_rows(
pop |>
dplyr::filter(stratum == 0) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme_fit <- svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
svycoxme_theta <- unlist(coxme::VarCorr(svycoxme_fit))
ci = svycoxme_theta + sqrt(diag(svycoxme_fit$vvar)) %o% qt(c(0.025, 0.975), Inf)
colnames(ci) <- c("lower", "upper")
data.frame(theta = svycoxme_theta, ci)
}
(res <- one_rep())
res$theta - my_theta
replicate(n = 10, expr = one_rep())
install.packages("microbenchmark")
microbenchmark::microbenchmark(one_rep(), times = 10)
5 * 1000 / 60
5 * 1000 / 60 / 60
one_rep <- function(rep = 0){
sample_clusters <- dplyr::bind_rows(
pop |>
dplyr::filter(stratum == 0) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme_fit <- svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
svycoxme_theta <- unlist(coxme::VarCorr(svycoxme_fit))
ci = svycoxme_theta + sqrt(diag(svycoxme_fit$vvar)) %o% qt(c(0.025, 0.975), Inf)
colnames(ci) <- c("lower", "upper")
data.frame(theta = svycoxme_theta, ci, rep = rep)
}
one_rep()
# set cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
# load svycoxme in all the nodes.
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
devtools::load_all(path = "/home/bdra011/svycoxme")
library(survey)
})
# set cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
# load svycoxme in all the nodes.
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
library(survey)
})
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("one_rep", "pop"))
fits <- parallel::parLapply(cl, 1:10, one_rep)
fits
Sys.time()
Sys.time()
# set cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
# load svycoxme in all the nodes.
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
library(survey)
})
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("one_rep", "pop"))
start = Sys.time()
fits <- parallel::parLapply(cl, 1:10, one_rep)
Sys.time() - start
#stop the cluster
parallel::stopCluster(cl)
17/10
make_pop <- function(theta){
cluster_str <- data.frame(table(Size = rpois(2.5e5, 2) + 2)) |>
dplyr::filter(Freq >=10)
cluster_str_list <- split(cluster_str, seq(nrow(cluster_str)))
max_cluster_digits <- max(nchar(as.character(cluster_str$Size)))
max_cluster_freq_digits <- max(nchar(as.character(cluster_str$Freq)))
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits)
nk_id <- formatC(nk, width = max_cluster_digits)
the_data <- one_dataset(~X1 + X2 + X3 + stratum + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
stratum = ~rep(c(0, 1), c(floor(2/3 * k) * nk, ceiling(1/3 * k) * nk))),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = c(1, -0.7, 0.5, -1),
random_effect_variance = c(M=0.1)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M, sep = "_" ))
})
pop <- Reduce(rbind.data.frame, pop_list)
pop
}
# global setup
results_dir = ""
results_name_suffix = "respart_"
results_name_extn = ".rds"
# global setup
results_dir = "C:/Users/Bradley/OneDrive - The University of Auckland/PhD/outputs/simulations/data"
results_name_suffix = "respart_"
results_name_extn = ".rds"
nreps = 10 # reps per theta
thetas = c(0.5, 1, 2)
true_coefs = c(1, -0.7, 0.5, -1)
library(survey)
make_pop <- function(theta){
cluster_str <- data.frame(table(Size = rpois(2.5e5, 2) + 2)) |>
dplyr::filter(Freq >=10)
cluster_str_list <- split(cluster_str, seq(nrow(cluster_str)))
max_cluster_digits <- max(nchar(as.character(cluster_str$Size)))
max_cluster_freq_digits <- max(nchar(as.character(cluster_str$Freq)))
pop_list <- lapply(cluster_str_list, function(cluster_info){
k <- cluster_info$Freq
nk <- as.numeric(as.character(cluster_info$Size))
k_id <- formatC(k, width = max_cluster_freq_digits)
nk_id <- formatC(nk, width = max_cluster_digits)
the_data <- one_dataset(~X1 + X2 + X3 + stratum + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n),
stratum = ~rep(c(0, 1), c(floor(2/3 * k) * nk, ceiling(1/3 * k) * nk))),
dist_args = list(k = k, nk = nk,
n = k * nk),
coefficients = true_coefs,
random_effect_variance = c(M=theta)
)
dplyr::mutate(the_data, id = paste(nk_id,k_id, M, sep = "_" ))
})
pop <- Reduce(rbind.data.frame, pop_list)
pop
}
one_rep <- function(rep = 0){
sample_clusters <- dplyr::bind_rows(
pop |>
dplyr::filter(stratum == 0) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50),
pop |>
dplyr::filter(stratum == 1) |>
dplyr::distinct(stratum, id) |>
dplyr::mutate(prob = 50/dplyr::n()) |>
dplyr::slice_sample(n = 50)
) |> dplyr::select(stratum, id, prob)
sample_data <- dplyr::left_join(sample_clusters, pop, by = c("stratum", "id")) |>
dplyr::mutate(scaled_weight = (1/prob)/(1/mean(prob)))
d2 <- svydesign(~id, probs = ~prob, strata = ~stratum, data = sample_data)
d3 <- as.svrepdesign(d2)
svycoxme_fit <- svycoxme(Surv(stat_time, stat) ~ X1 + X2 + X3 + stratum + (1 | M), design = d3)
svycoxme_theta <- unlist(coxme::VarCorr(svycoxme_fit))
ci = svycoxme_theta + sqrt(diag(svycoxme_fit$vvar)) %o% qt(c(0.025, 0.975), Inf)
colnames(ci) <- c("lower", "upper")
data.frame(theta = svycoxme_theta, ci, rep = rep)
}
for (my_theta in thetas) {
results_file_name <- paste0(results_name_suffix, which(my_theta == thetas), results_name_extn)
results_file_path <- file.path(results_dir, results_file_name)
print(results_file_name)
# pop <- make_pop(theta = my_theta)
#
# parallel::clusterExport(cl, c("pop"))
#
# fits <- parallel::parLapply(cl, seq(nreps), one_rep)
#
#
#
# readr::write_rds(fits, results_filepath)
}
# set cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
# load svycoxme in all the nodes.
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
library(survey)
})
parallel::clusterExport(cl, c("one_rep"))
for (my_theta in thetas) {
results_file_name <- paste0(results_name_suffix, which(my_theta == thetas), results_name_extn)
pop <- make_pop(theta = my_theta)
parallel::clusterExport(cl, c("pop"))
fits <- parallel::parLapply(cl, seq(nreps), one_rep)
readr::write_rds(fits, file.path(results_dir, results_file_name))
}
devtools::load_all(".")
for (my_theta in thetas) {
results_file_name <- paste0(results_name_suffix, which(my_theta == thetas), results_name_extn)
pop <- make_pop(theta = my_theta)
parallel::clusterExport(cl, c("pop"))
fits <- parallel::parLapply(cl, seq(nreps), one_rep)
readr::write_rds(fits, file.path(results_dir, results_file_name))
}
results_file_names <- vector(mode = "character", length = length(results_file_name))
for (my_theta in thetas) {
results_file_name <- paste0(results_name_suffix, which(my_theta == thetas), results_name_extn)
pop <- make_pop(theta = my_theta)
parallel::clusterExport(cl, c("pop"))
fits <- parallel::parLapply(cl, seq(nreps), one_rep)
readr::write_rds(fits, file.path(results_dir, results_file_name))
}
for (my_theta in thetas) {
t_index = which(my_theta == thetas)
results_file_name <- paste0(results_name_suffix, t_index, results_name_extn)
results_file_names[t_index] <- results_file_name
}
results_file_names <- vector(mode = "character", length = length(results_file_name))
for (my_theta in thetas) {
t_index = which(my_theta == thetas)
results_file_name <- paste0(results_name_suffix, t_index, results_name_extn)
results_file_names[t_index] <- results_file_name
}
# assemble results
lres <- lapply(results_file_names, readr::read_rds)
for (my_theta in thetas) {
t_index = which(my_theta == thetas)
results_file_name <- paste0(results_name_suffix, t_index, results_name_extn)
results_filepaths[t_index] <- file.path(results_dir, results_file_name)
}
results_filepaths <- vector(mode = "character", length = length(results_file_name))
for (my_theta in thetas) {
t_index = which(my_theta == thetas)
results_file_name <- paste0(results_name_suffix, t_index, results_name_extn)
results_filepaths[t_index] <- file.path(results_dir, results_file_name)
}
# assemble results
lres <- lapply(results_filepaths, readr::read_rds)
lres
lres[[1]]
list2DF(lres[[1]])
Reduce(rbind.data.frame, lres[[1]])
# set cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
# load svycoxme in all the nodes.
parallel::clusterEvalQ(cl, {
# devtools::load_all(path = "C:/Users/bdra011/Documents/PhD_local/svycoxme")
devtools::load_all(path = "C:/Users/Bradley/Documents/PhD_local/svycoxme")
# devtools::load_all(path = "/home/bdra011/svycoxme")
library(survey)
})
parallel::clusterExport(cl, c("one_rep"))
results_filepaths <- vector(mode = "character", length = length(results_file_name))
for (my_theta in thetas) {
t_index = which(my_theta == thetas)
results_file_name <- paste0(results_name_suffix, t_index, results_name_extn)
results_filepaths[t_index] <- file.path(results_dir, results_file_name)
pop <- make_pop(theta = my_theta)
parallel::clusterExport(cl, c("pop"))
fits <- parallel::parLapply(cl, seq(nreps), one_rep)
fits_df <- Reduce(rbind.data.frame, fits)
fits_df$true_theta = my_theta
readr::write_rds(fits_df, results_filepaths[t_index])
}
parallel::stopCluster(cl)
# assemble results
lres <- lapply(results_filepaths, readr::read_rds)
Reduce(rbind.data.frame, lres)
results_assembled_name = "theta_ci_res.rds"
res <- Reduce(rbind.data.frame, lres)
readr::write_rds(res, file.path(results_dir, results_assembled_name))
lapply(results_filepaths, file.remove)
