X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = list(M = my_theta)
)
# new lp and lp_grd functions that take sorted, parsed data instead of raw.
# trials with generic function and class-specific methods.
lp <- function(params, formula, parsed_data, theta){
UseMethod("lp", parsed_data)
}
lp_gr_beta <- function(params, formula, parsed_data, theta){
UseMethod("lp_gr_beta", parsed_data)
}
lp_gr_b <- function(params, formula, parsed_data, theta){
UseMethod("lp_gr_b", parsed_data)
}
lp_gr <- function(params, formula, parsed_data, theta){
UseMethod("lp_gr", parsed_data)
}
lp.ppl <- function(params, formula, parsed_data, theta) {
# These steps are moved to improve performance of optim.
# # This sort var could be pulled out of the formula.
# ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
#
# parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
# drop the intercept column from the X model.matrix
risk_score <- parsed_data$X[, -1] %*% beta + Matrix::crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
# calculate risk sets
# I do it this way to preserve the class and other slots. rev(risk_score) coerces to a numeric vector.
# probably no point, as cumsum convert it anyway, and I need to remake the matrix with Matrix.
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix::Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
# would be good to peel stat out of the Surv() object in the parsed formula.
# This is awkward because Surv() doesn't preserve the variable names, so I may
# need to parse the formula myself, and including consideration of the "type"
# attribute from the evaluated call.
stat <- Matrix::Matrix(ds_sorted$stat, ncol = 1)
# penalty
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
penalty <- 0.5 * t(b) %*% Matrix::solve(parsed_data$reTrms$Lambdat) %*% b
penalised_likelihood <- sum(stat * (risk_score - log(at_risk))) - penalty
penalised_likelihood@x
}
lp_gr_beta.ppl <- function(params, formula, parsed_data, theta) {
# ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
#
# parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
exp_risk_score_X <- exp_risk_score * parsed_data$X[,-1]
## I replaced this with fast_risk_sets, which is faster when there are lots of columns. Else it's about the same.
#
# at_risk_list <- apply(exp_risk_score_X, 2, function(column){
#   Matrix(rev(cumsum(rev(column))), ncol = 1)
# })
#
# at_risk_X <- Reduce(cbind, at_risk_list)
at_risk_X <- fast_risk_sets(exp_risk_score_X)
stat <- Matrix(ds_sorted$stat, ncol = 1)
likelihood_gradients <- colSums(stat * (parsed_data$X[, -1] - at_risk_X/at_risk))
likelihood_gradients
}
lp_gr_b.ppl <- function(params, formula, parsed_data, theta) {
#
# ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
#
# parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
bl <- length(b)
exp_risk_score_Z <- Matrix(rep(exp_risk_score, bl), ncol = bl) * t(parsed_data$reTrms$Zt)
# at_risk_list <- apply(exp_risk_score_Z, 2, function(column){
#   Matrix(rev(cumsum(rev(column))), ncol = 1)
# })
#
# at_risk_Z <- Reduce(cbind, at_risk_list)
at_risk_Z <- fast_risk_sets(exp_risk_score_Z)
stat <- Matrix(ds_sorted$stat, ncol = 1)
likelihood_gradients_unpenalised <- colSums(stat * (t(parsed_data$reTrms$Zt) - at_risk_Z/at_risk))
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
penalty <- t(b) %*% solve(parsed_data$reTrms$Lambdat)
# this accessing @x is probably poor practice?
likelihood_gradients_unpenalised - penalty@x
}
lp_gr.ppl <- function(params, formula, parsed_data, theta) {
c(lp_gr_beta(params = params, formula = formula, parsed_data = parsed_data, theta = theta),
lp_gr_b(   params = params, formula = formula, parsed_data = parsed_data, theta = theta))
}
make_ppl <- function(data){
stopifnot(is.data.frame(data))
class(data) <- c("ppl", oldClass(data))
data
}
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
ds.ppl <- make_ppl(parsed_data)
make_ppl
make_ppl <- function(data){
# stopifnot(is.data.frame(data))
class(data) <- c("ppl", oldClass(data))
data
}
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M)
my_k = 50
my_nk = 4
my_theta = 1
my_beta = c(1, 1, 1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k * my_nk),
coefficients = my_beta,
random_effect_variance = list(M = my_theta)
)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
ds.ppl <- make_ppl(parsed_data)
fixed_formula <- lme4:::getFixedFormula(my_formula)
fit0 <- survival::coxph(fixed_formula, data = ds)
start_params <- c(coef(fit0), rep(0, my_k))
lp(start_params, formula = my_formula, parsed_data = ds.ppl, theta = my_theta)
ests <- optim(par = start_params,
fn = lp,
gr = lp_gr,
formula = my_formula,
parsed_data = ds.ppl,
theta = my_theta,
method = "BGFS",
control = list(fnscale = -1))
ests <- optim(par = start_params,
fn = lp,
gr = lp_gr,
formula = my_formula,
parsed_data = ds.ppl,
theta = my_theta,
method = "BFGS",
control = list(fnscale = -1))
fast_risk_sets <- function(a_matrix){
# flip it
rev_index <- rev(seq_len(nrow(a_matrix)))
m <- a_matrix[rev_index, ]
# cumsums
m <- matrixStats::colCumsums(as.matrix(m))
# flip it back
m <- m[rev_index,]
# restore class
Matrix(m)
}
ests <- optim(par = start_params,
fn = lp,
gr = lp_gr,
formula = my_formula,
parsed_data = ds.ppl,
theta = my_theta,
method = "BFGS",
control = list(fnscale = -1))
microbenchmark::microbenchmark(
ppl(d = sortedData$stat, X = as.matrix(sortedData[, xColumns]),
Z = as.matrix(sortedData[, zColumns]), B = B, b = b, D = D_theta),
lp(start_params, formula = my_formula, parsed_data = ds.ppl, theta = my_theta),
)
microbenchmark::microbenchmark(
lp(start_params, formula = my_formula, parsed_data = ds.ppl, theta = my_theta)
)
new_theta_ipl <- function(theta, formula, data){
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
# set up D
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
D <- parsed_data$reTrms$Lambdat
n_fixed <- length(attr(terms(coxme:::formula1(formula)$fixed), "order"))
fixed_formula <- lme4:::getFixedFormula(formula)
fit0 <- survival::coxph(fixed_formula, data = data)
start_params <- c(coef(fit0), rep(0, length(parsed_data$reTrms$Lind)))
ests <- optim(par = start_params,
fn = lp,
gr = lp_gr,
formula = formula,
parsed_data = parsed_data,
theta = theta,
method = "BFGS",
control = list(fnscale = -1),
hessian = TRUE)
# take the part of the hessian associated with the random effects only
Kbb <- ests$hessian[-(1:n_fixed), -(1:n_fixed)]
-0.5 * determinant(D)$modulus -0.5 * determinant(Kbb)$modulus + ests$value
}
new_theta_ipl(my_theta, my_formula, ds)
new_theta_ipl <- function(theta, formula, data){
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
# set up D
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
D <- parsed_data$reTrms$Lambdat
n_fixed <- length(attr(terms(coxme:::formula1(formula)$fixed), "order"))
fixed_formula <- lme4:::getFixedFormula(formula)
fit0 <- survival::coxph(fixed_formula, data = data)
start_params <- c(coef(fit0), rep(0, length(parsed_data$reTrms$Lind)))
ests <- optim(par = start_params,
fn = lp,
gr = lp_gr,
formula = formula,
parsed_data = make_ppl(parsed_data),
theta = theta,
method = "BFGS",
control = list(fnscale = -1),
hessian = TRUE)
# take the part of the hessian associated with the random effects only
Kbb <- ests$hessian[-(1:n_fixed), -(1:n_fixed)]
-0.5 * determinant(D)$modulus -0.5 * determinant(Kbb)$modulus + ests$value
}
new_theta_ipl(my_theta, my_formula, ds)
new_theta_ipl <- function(theta, formula, data){
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
# set up D
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
D <- parsed_data$reTrms$Lambdat
n_fixed <- length(attr(terms(coxme:::formula1(formula)$fixed), "order"))
fixed_formula <- lme4:::getFixedFormula(formula)
fit0 <- survival::coxph(fixed_formula, data = data)
start_params <- c(coef(fit0), rep(0, length(parsed_data$reTrms$Lind)))
ests <- optim(par = start_params,
fn = lp,
gr = lp_gr,
formula = formula,
parsed_data = make_ppl(parsed_data),
theta = theta,
method = "BFGS",
control = list(fnscale = -1),
hessian = TRUE)
# take the part of the hessian associated with the random effects only
Kbb <- ests$hessian[-(1:n_fixed), -(1:n_fixed)]
c(-0.5 * determinant(D)$modulus -0.5 * determinant(Kbb)$modulus + ests$value)
}
new_theta_ipl(my_theta, my_formula, ds)
new_theta_ipl <- function(theta, formula, data){
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
# set up D
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
D <- parsed_data$reTrms$Lambdat
n_fixed <- length(attr(terms(coxme:::formula1(formula)$fixed), "order"))
fixed_formula <- lme4:::getFixedFormula(formula)
fit0 <- survival::coxph(fixed_formula, data = data)
start_params <- c(coef(fit0), rep(0, length(parsed_data$reTrms$Lind)))
optim(par = start_params,
fn = lp,
gr = lp_gr,
formula = formula,
parsed_data = make_ppl(parsed_data),
theta = theta,
method = "BFGS",
control = list(fnscale = -1))
}
new_theta_ipl(my_theta, my_formula, ds)
new_theta_ipl(my_theta, my_formula, ds)
lme4:::reexpr(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1) + (1 | M2))
lme4:::reexpr(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1) + (1 | M2))
coxme:::formula1(survival::Surv(time, stat) ~ (1 | M1/M2))
parsed_data$reTrms$flist
length(parsed_data$reTrms$flist)
devtools::load_all(".")
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M)
my_k = 20
my_nk = 4
my_theta = 1
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k*my_nk),
coefficients = c(1, 1, 1),
random_effect_variance = list(M = 1)
)
est_parameters(my_formula, ds)
svycoxme::lp.ppl
devtools::load_all(".")
est_parameters(my_formula, ds)
devtools::load_all(".")
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k*my_nk),
coefficients = c(1, 1, 1),
random_effect_variance = list(M = 1)
)
est_parameters(my_formula, ds)
debugonce(est_parameters)
est_parameters(my_formula, ds)
theta_ipl
debugonce(lp.ppl)
est_parameters(my_formula, ds)
parsed_data$fr
parsed_data$fr$`survival::Surv(stat_time, stat)`
unlist(parsed_data$fr$`survival::Surv(stat_time, stat)`)
unclass(parsed_data$fr$`survival::Surv(stat_time, stat)`)
unclass(parsed_data$fr[,1]`)
)
)
unclass(parsed_data$fr[,1])
unclass(parsed_data$fr[,1])$status
unclass(parsed_data$fr[,1])[, "status"]
devtools::load_all(".")
est_parameters(my_formula, ds)
devtools::load_all(".")
est_parameters(my_formula, ds)
devtools::load_all(".")
est_parameters(my_formula, ds)
devtools::load_all(".")
est_parameters(my_formula, ds)
devtools::load_all(".")
est_parameters(my_formula, ds)
devtools::load_all(".")
est_parameters(my_formula, ds)
devtools::load_all(".")
est_parameters(my_formula, ds)
debugonce(lp_gr_beta)
est_parameters(my_formula, ds)
debugonce(lp_gr_beta.ppl)
est_parameters(my_formula, ds)
debugonce(lp_gr_beta.ppl)
est_parameters(my_formula, ds)
parsed_data$reTrms$Zt
b
crossprod(parsed_data$reTrms$Zt, b)
Matrix::crossprod(parsed_data$reTrms$Zt, b)
devtools::load_all(".")
est_parameters(my_formula, ds)
est_parameters
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
theta_start <- get_start_theta(length(parsed_data$reTrms$flist))
theta_start
n_fixed <- length(attr(terms(coxme:::formula1(my_formula)$fixed), "order"))
n_fixed
fixed_formula <- lme4:::getFixedFormula(my_formula)
fixed_formula
fit0 <- survival::coxph(fixed_formula, data = ds)
start_params <- c(coef(fit0), rep(0, length(parsed_data$reTrms$Lind)))
start_params
# assumes that the response is of the form Surv(time, stat). Behaviour for other Surv formats is undefined.
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
stat
optim(par = start_params,
fn = lp,
gr = lp_gr,
formula = my_formula,
parsed_data = make_ppl(parsed_data),
other_args = list(theta = my_theta,
stat = stat),
method = "BFGS",
control = list(fnscale = -1))
theta_start
theta_ipl
theta_ipl(1, my_formula, parsed_data,
other_args = list(n_fixed = n_fixed,
start_params = start_params,
stat = stat))
theta_est <- optim(par = theta_start,
fn = theta_ipl,
gr = NULL,
formula = my_formula,
parsed_data = parsed_data,
other_args = list(n_fixed = n_fixed,
start_params = start_params,
stat = stat),
method = "BFGS",
control = list(fnscale = -1))
theta_est
theta_est <- optim(par = theta_start,
fn = theta_ipl,
gr = NULL,
formula = my_formula,
parsed_data = parsed_data,
other_args = list(n_fixed = n_fixed,
start_params = start_params,
stat = stat),
method = "Nelder-Mead",
control = list(fnscale = -1))
theta_est <- optim(par = theta_start,
fn = theta_ipl,
gr = NULL,
formula = my_formula,
parsed_data = parsed_data,
other_args = list(n_fixed = n_fixed,
start_params = start_params,
stat = stat),
method = "L-BFGS-B",
control = list(fnscale = -1),
lower = 0.00001, upper = 3)
theta_est
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit
coxme_fit$loglik[2]
theta_ipl
coxme::VarCorr(coxme_fit)
theta_est <- optim(par = theta_start,
fn = theta_ipl,
gr = NULL,
formula = my_formula,
parsed_data = parsed_data,
other_args = list(n_fixed = n_fixed,
start_params = start_params,
stat = stat),
method = "L-BFGS-B",
control = list(fnscale = -1),
lower = 0.00001, upper = Inf)
theta_est
devtools::load_all(".")
my_formula <- survival::Surv(stat_time, stat)~X1 + X2 + X3 + (1 | M)
my_k = 20
my_nk = 4
my_theta = 1
my_beta
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k*my_nk),
coefficients = my_beta,
random_effect_variance = list(M = my_theta)
)
est_parameters(my_formula, ds)
my_beta = c(1, -0.7, 0.5)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = my_k, nk = my_nk, n = my_k*my_nk),
coefficients = my_beta,
random_effect_variance = list(M = my_theta)
)
est_parameters(my_formula, ds)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit$loglik[2]
coxme::VarCorr(coxme_fit)
coxme::random.effects(coxme_fit)
coxme::fixed.effects(coxme_fit)
ds <- one_dataset(~X1 + X2 + X3 + (1 | M1) + (1| M2),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, M2 = 2)
)
devtools::load_all(".")
head(ds)
ds <- one_dataset(~X1 + X2 + X3 + (1 | M1) + (1| M2),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
M2 = ~rep(c("l", "r"), ceiling(n/2))[seq_len(n)],
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 50, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 1, M2 = 2)
)
head(ds)
one_dataset
vignette(package = "lme4")
vignette("lmer",package = "lme4")
methods(survey::svycoxph)
svycoxph.survey.design
survey::svycoxph.survey.design
survey:::svycoxph.survey.design
vignette("Theory",package = "lme4")
