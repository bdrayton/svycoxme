hessian = -unchol(coxme_fit$hmat))
ses <- c(numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)))
ses
}
# are the analytical ses systematically smaller?
ress <- replicate(n = 100, one_rep(0.5, 50, 4))
devtools::load_all(".")
res <- one_rep(0.5, 200, 20)
res
# are the analytical ses systematically smaller?
ress <- replicate(n = 100, try(one_rep(0.5, 50, 4)))
res
# dump errors, make data frame
is_error <- sapply(ress, inherits, what = "try-error")
table(is_error)
ress_df <- Reduce(rbind, ress[!is_error])
lapply(ress_df, mean)
ress_df <- Reduce(rbind, ress[!is_error]) |> data.frame()
ress_df
lapply(ress_df, mean)
plot(density(ress_df[,1]))
lines(density(ress_df[,2]))
plot(density(ress_df[,2]))
lines(density(ress_df[,1]))
Zpp <- function(theta, beta, b , parsed_data, stat) {
# set up D
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
D <- parsed_data$reTrms$Lambdat
D_inverse <- Matrix::solve(D)
# drop the intercept column from the X model.matrix
risk_score <- parsed_data$X[, -1, drop = FALSE] %*% beta + Matrix::crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
# calculate risk sets
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix::Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
# Need cumulative hazard (breslow), and Zt(Z)
cumulative_hazard <- Matrix::Matrix(cumsum(other_args$stat/at_risk), ncol = 1)
Zt <- parsed_data$reTrms$Zt
Zt_ncol <- ncol(Zt)
ZtZ_exp_risk_score <- vector(mode = "list", length = Zt_ncol)
for (i in seq_len(Zt_ncol)) {
ZtZ_exp_risk_score[[i]] <-  cumulative_hazard[i] * exp_risk_score[i] * Matrix::tcrossprod(Zt[,i, drop = FALSE])
}
K <- Reduce("+", ZtZ_exp_risk_score) + D_inverse
K
}
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
ses <- c(numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)))
ses
}
# debugonce(calc_hessian_cell)
debugonce(one_rep)
res <- one_rep(0.5, 200, 20)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
Kpp <- function(theta, beta, b , parsed_data, stat) {
# set up D
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
D <- parsed_data$reTrms$Lambdat
D_inverse <- Matrix::solve(D)
# drop the intercept column from the X model.matrix
risk_score <- parsed_data$X[, -1, drop = FALSE] %*% beta + Matrix::crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
# calculate risk sets
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix::Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
# Need cumulative hazard (breslow), and Zt(Z)
cumulative_hazard <- Matrix::Matrix(cumsum(other_args$stat/at_risk), ncol = 1)
Zt <- parsed_data$reTrms$Zt
Zt_ncol <- ncol(Zt)
ZtZ_exp_risk_score <- vector(mode = "list", length = Zt_ncol)
for (i in seq_len(Zt_ncol)) {
ZtZ_exp_risk_score[[i]] <-  cumulative_hazard[i] * exp_risk_score[i] * Matrix::tcrossprod(Zt[,i, drop = FALSE])
}
K <- Reduce("+", ZtZ_exp_risk_score) + D_inverse
K
}
# debugonce(calc_hessian_cell)
debugonce(one_rep)
res <- one_rep(0.5, 200, 20)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
res <- one_rep(0.5, 200, 20)
Kpp <- function(theta, beta, b , parsed_data, stat) {
# set up D
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
D <- parsed_data$reTrms$Lambdat
D_inverse <- Matrix::solve(D)
# drop the intercept column from the X model.matrix
risk_score <- parsed_data$X[, -1, drop = FALSE] %*% beta + Matrix::crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
# calculate risk sets
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix::Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
# Need cumulative hazard (breslow), and Zt(Z)
cumulative_hazard <- Matrix::Matrix(cumsum(stat/at_risk), ncol = 1)
Zt <- parsed_data$reTrms$Zt
Zt_ncol <- ncol(Zt)
ZtZ_exp_risk_score <- vector(mode = "list", length = Zt_ncol)
for (i in seq_len(Zt_ncol)) {
ZtZ_exp_risk_score[[i]] <-  cumulative_hazard[i] * exp_risk_score[i] * Matrix::tcrossprod(Zt[,i, drop = FALSE])
}
K <- Reduce("+", ZtZ_exp_risk_score) + D_inverse
K
}
res <- one_rep(0.5, 200, 20)
calc_hessian_cell
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
v2 <- q/(2*ests$theta^2) - tr(solve(K))/(theta^3) + tr(K%*%K)/(2*ests$theta^4) - (t(b) %*% b)/theta^3
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
ses <- c(numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)),
analytical_se2 = sqrt(solve(-v2)))
ses
}
# debugonce(calc_hessian_cell)
debugonce(one_rep)
res <- one_rep(0.5, 200, 20)
function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
v2 <- q/(2*ests$theta^2) - tr(solve(K))/(theta^3) + tr(K%*%K)/(2*ests$theta^4) - (t(b) %*% b)/theta^3
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
ses <- c(numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)),
analytical_se2 = sqrt(solve(-v2)))
ses
}
K
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
v2 <- q/(2*ests$theta^2) - tr(solve(K))/(ests$theta^3) + tr(K%*%K)/(2*ests$theta^4) - (t(b) %*% b)/theta^3
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
ses <- c(numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)),
analytical_se2 = sqrt(solve(-v2)))
ses
}
res <- one_rep(0.5, 200, 20)
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
K
v2 <- q/(2*ests$theta^2) - tr(solve(K))/(ests$theta^3) + tr(K%*%K)/(2*ests$theta^4) - (t(b) %*% b)/ests$theta^3
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
sqrt(solve(-v2))
v2
-v2
-ana_hess
# debugonce(calc_hessian_cell)
debugonce(Kpp)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
D
D_inverse
# drop the intercept column from the X model.matrix
risk_score <- parsed_data$X[, -1, drop = FALSE] %*% beta + Matrix::crossprod(parsed_data$reTrms$Zt, b)
risk_score
cumulative_hazard
Reduce("+", ZtZ_exp_risk_score)
Reduce("+", ZtZ_exp_risk_score)
Reduce("+", ZtZ_exp_risk_score)
D_inverse
K
K_inv <- solve(K_inv)
K_inv <- solve(K)
v2 <- q/(2*ests$theta^2) - tr(K_inv)/(ests$theta^3) + tr(K_inv%*%K_inv)/(2*ests$theta^4) - (t(b) %*% b)/ests$theta^3
v2
sqrt(solve(-v2))
sqrt(solve(-ana_hess))
diag(sqrt(solve(-attr(ests, "theta_est")$hessian)))
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
K_inv <- solve(K)
v2 <- q/(2*ests$theta^2) - tr(K_inv)/(ests$theta^3) + tr(K_inv%*%K_inv)/(2*ests$theta^4) - (t(b) %*% b)/ests$theta^3
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
ses <- c(numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)),
analytical_se2 = sqrt(solve(-v2)))
ses
}
res <- one_rep(0.5, 200, 20)
res
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
K_inv <- solve(K)
v2 <- q/(2*ests$theta^2) - tr(K_inv)/(ests$theta^3) + tr(K_inv%*%K_inv)/(2*ests$theta^4) - (t(b) %*% b)/ests$theta^3
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
ses <- c(numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)),
analytical_se2 = c(sqrt(solve(-v2))))
ses
}
(res <- one_rep(0.5, 200, 20))
res[3]
unclass(res[3])
res[3]@x
str(res[3])
str(res[[3]])
res[[3]]@x
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
K_inv <- solve(K)
v2 <- q/(2*ests$theta^2) - tr(K_inv)/(ests$theta^3) + tr(K_inv%*%K_inv)/(2*ests$theta^4) - (t(b) %*% b)/ests$theta^3
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
ses <- c(numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)),
analytical_se2 = sqrt(solve(-v2@x)))
ses
}
(res <- one_rep(0.5, 200, 20))
# are the analytical ses systematically smaller?
ress <- replicate(n = 100, try(one_rep(0.5, 50, 4)))
# dump errors, make data frame
is_error <- sapply(ress, inherits, what = "try-error")
table(is_error)
ress_df <- Reduce(rbind, ress[!is_error]) |> data.frame()
lapply(ress_df, mean)
ress_df <- Reduce(rbind, ress[!is_error]) |> data.frame()
lapply(ress_df, mean)
ress_df <- Reduce(rbind, ress[!is_error]) |> data.frame()
ress
rowMeans(ress)
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
b <- Matrix(ests$b, ncol = 1)
beta <- Matrix(ests$beta, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
stat <- Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1)
K <- Kpp(theta = ests$theta, beta = beta, b = b, parsed_data = parsed_data, stat = stat)
K_inv <- solve(K)
v2 <- q/(2*ests$theta^2) - tr(K_inv)/(ests$theta^3) + tr(K_inv%*%K_inv)/(2*ests$theta^4) - (t(b) %*% b)/ests$theta^3
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
ses <- c(theta = ests$theta,
numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)),
analytical_se2 = sqrt(solve(-v2@x)))
ses
}
(res <- one_rep(0.5, 200, 20))
in_ci <- function(res){
lower = res[1] - 1.96 * res[-1]
upper = res[1] + 1.96 * res[-1]
true_theta >= lower & true_theta <= upper
}
in_ci(res)
in_ci(res)
# are the analytical ses systematically smaller?
ress <- replicate(n = 100, try(one_rep(0.5, 50, 4)), simplify = FALSE)
hit_list <- lapply(ress, in_ci)
Reduce(rbind, hit_list) |> colMeans()
# are the analytical ses systematically smaller?
ress <- replicate(n = 100, try(one_rep(0.5, 50, 10)), simplify = FALSE)
hit_list <- lapply(ress, in_ci)
Reduce(rbind, hit_list) |> colMeans()
survey::svycoxph
survey::svycoxph.survey.design2
survey:::svycoxph.survey.design2
survey:::svycoxph.survey.design
svyrecvar
multistage
survey:::multistage
qr.resid
?qr.resid
14.18/42.96
