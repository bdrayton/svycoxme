betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
#
#   theta <- unlist(coxme::VarCorr(model))
#   D <- diag(length(bs)) * theta
#
#   penalty <- c(rep(0, p_fixef), solve(D) %*% matrix(bs))
#
#   unpenalised - penalty
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
test2$weights <- rep(runif(4, 2, 6), table(test2$idK))
test2 <- test2[order(test2$timeb, test2$timea), ]
fit <- coxme::coxme(Surv(timea, timeb, event) ~ x + x2 + (1 | idK), test2)
parts3 <- make_parts(fit, data = test2)
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
my_grad_func <- function(betas_bs, model, data){
# hack to put user-specified betas and bs into the model.
# wont work for more than one random effect.
fixed_effects <- coxme::fixef(model)
random_effects <- coxme::ranef(model)
p_fixef <- length(fixed_effects)
q_ranef <- length(unlist(random_effects))
betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
#
#   theta <- unlist(coxme::VarCorr(model))
#   D <- diag(length(bs)) * theta
#
#   penalty <- c(rep(0, p_fixef), solve(D) %*% matrix(bs))
#
#   unpenalised - penalty
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
fit <- coxme::coxme(Surv(timea, timeb, event) ~ x + x2 + (1 | idK), test2, weights = weights)
parts3 <- make_parts(fit, data = test2)
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
my_grad_func <- function(betas_bs, model, data){
# hack to put user-specified betas and bs into the model.
# wont work for more than one random effect.
fixed_effects <- coxme::fixef(model)
random_effects <- coxme::ranef(model)
p_fixef <- length(fixed_effects)
q_ranef <- length(unlist(random_effects))
betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
#
#   theta <- unlist(coxme::VarCorr(model))
#   D <- diag(length(bs)) * theta
#
#   penalty <- c(rep(0, p_fixef), solve(D) %*% matrix(bs))
#
#   unpenalised - penalty
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
my_grad_func(test_vals, fit, data = test2)
debugonce(make_parts.coxme)
parts3 <- make_parts(fit, data = test2)
names(parsed_data)
weights(coxme.object)
parsed_data
debugonce(make_parts.coxme)
parts3 <- make_parts(fit, data = test2)
weights
weights %*% Z
weights %*% Z / colSums(Z)
Z
test2 <- list(
idK =  as.character(c(1,1, 1, 2,2, 2, 3,3,   4,  4)),
# timea=c(1,2, 5, 0,7, 8, 0,9,   0,  6),
timea= c(0,0, 0, 0,0, 0, 0, 0,  0,  0),
timeb= c(2,5,10, 7,8,13, 9,14,  6, 15),
event=c(1,1, 1, 1,1, 0, 1, 0,  1,  0),
x=    c(1,1, 1, 0,0, 0, 1,1,   0,  0),
x2 = rnorm(10)) |>
as.data.frame()
test2$weights <- rep(runif(4, 2, 6), table(test2$idK))
test2 <- test2[order(test2$timeb, test2$timea), ]
fit <- coxme::coxme(Surv(timea, timeb, event) ~ x + x2 + (1 | idK), test2, weights = weights)
test2$weights
debugonce(make_parts.coxme)
parts3 <- make_parts(fit, data = test2)
weights
weights(coxme.object)
weights
weights
weights %*% Z
weights %*% Z / colSums(Z)
weights
diag(4)
devtools::load_all(".")
devtools::load_all(".")
test2 <- list(
idK =  as.character(c(1,1, 1, 2,2, 2, 3,3,   4,  4)),
# timea=c(1,2, 5, 0,7, 8, 0,9,   0,  6),
timea= c(0,0, 0, 0,0, 0, 0, 0,  0,  0),
timeb= c(2,5,10, 7,8,13, 9,14,  6, 15),
event=c(1,1, 1, 1,1, 0, 1, 0,  1,  0),
x=    c(1,1, 1, 0,0, 0, 1,1,   0,  0),
x2 = rnorm(10)) |>
as.data.frame()
set.seed(89474)
test2$weights <- rep(runif(4, 2, 6), table(test2$idK))
test2 <- test2[order(test2$timeb, test2$timea), ]
fit <- coxme::coxme(Surv(timea, timeb, event) ~ x + x2 + (1 | idK), test2, weights = weights)
parts3 <- make_parts(fit, data = test2)
debugonce(make_parts.coxme)
parts3 <- make_parts(fit, data = test2)
cluster_weights
diag(cluster_weights)
devtools::load_all(".")
parts3 <- make_parts(fit, data = test2)
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
my_grad_func <- function(betas_bs, model, data){
# hack to put user-specified betas and bs into the model.
# wont work for more than one random effect.
fixed_effects <- coxme::fixef(model)
random_effects <- coxme::ranef(model)
p_fixef <- length(fixed_effects)
q_ranef <- length(unlist(random_effects))
betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
#
#   theta <- unlist(coxme::VarCorr(model))
#   D <- diag(length(bs)) * theta
#
#   penalty <- c(rep(0, p_fixef), solve(D) %*% matrix(bs))
#
#   unpenalised - penalty
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
get_information(fit)
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
debugonce(make_parts.coxme)
parts3 <- make_parts(fit, data = test2)
diag(cluster_weights@x) %*% D
coxme.object$penalty
b
t(b) %*% D %*% b
t(b) %*% D %*% b / 2
devtools::load_all(".")
my_grad_func <- function(betas_bs, model, data){
# hack to put user-specified betas and bs into the model.
# wont work for more than one random effect.
fixed_effects <- coxme::fixef(model)
random_effects <- coxme::ranef(model)
p_fixef <- length(fixed_effects)
q_ranef <- length(unlist(random_effects))
betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
#
#   theta <- unlist(coxme::VarCorr(model))
#   D <- diag(length(bs)) * theta
#
#   penalty <- c(rep(0, p_fixef), solve(D) %*% matrix(bs))
#
#   unpenalised - penalty
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
parts3$ui_penalty
colSums(parts3$ui_penalty)
weights(fit)
6.429428/3.472594
theta <- unlist(coxme::VarCorr(fit))
unlist(coxme::ranef(fit))
bs = unlist(coxme::ranef(fit))
D <- diag(length(bs)) * theta
solve(D) %*% matrix(bs)
my_grad_func(test_vals, fit, data = test2)
devtools::load_all(".")
my_grad_func(test_vals, fit, data = test2)
parts3 <- make_parts(fit, data = test2)
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
devtools::load_all(".")
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
score_mine
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
test2 <- list(
idK =  as.character(c(1,1, 1, 2,2, 2, 3,3,   4,  4)),
# timea=c(1,2, 5, 0,7, 8, 0,9,   0,  6),
timea= c(0,0, 0, 0,0, 0, 0, 0,  0,  0),
timeb= c(2,5,10, 7,8,13, 9,14,  6, 15),
event=c(1,1, 1, 1,1, 0, 1, 0,  1,  0),
x=    c(1,1, 1, 0,0, 0, 1,1,   0,  0),
x2 = rnorm(10)) |>
as.data.frame()
test2$weights <- rep(runif(4, 2, 6), table(test2$idK))
test2 <- test2[order(test2$timeb, test2$timea), ]
fit <- coxme::coxme(Surv(timea, timeb, event) ~ x + x2 + (1 | idK), test2, weights = weights)
parts3 <- make_parts(fit, data = test2)
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
my_grad_func <- function(betas_bs, model, data){
# hack to put user-specified betas and bs into the model.
# wont work for more than one random effect.
fixed_effects <- coxme::fixef(model)
random_effects <- coxme::ranef(model)
p_fixef <- length(fixed_effects)
q_ranef <- length(unlist(random_effects))
betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
test2$weights <- rep(runif(4, 2, 6), table(test2$idK))
test2 <- test2[order(test2$timeb, test2$timea), ]
fit <- coxme::coxme(Surv(timea, timeb, event) ~ x + x2 + (1 | idK), test2, weights = weights)
# debugonce(make_parts.coxme)
parts3 <- make_parts(fit, data = test2)
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
my_grad_func <- function(betas_bs, model, data){
# hack to put user-specified betas and bs into the model.
# wont work for more than one random effect.
fixed_effects <- coxme::fixef(model)
random_effects <- coxme::ranef(model)
p_fixef <- length(fixed_effects)
q_ranef <- length(unlist(random_effects))
betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
test2 <- list(
idK =  as.character(c(1,1, 1, 2,2, 2, 3,3,   4,  4)),
timea=c(1,2, 5, 0,7, 8, 0,9,   0,  6),
# timea= c(0,0, 0, 0,0, 0, 0, 0,  0,  0),
timeb= c(2,5,10, 7,8,13, 9,14,  6, 15),
event=c(1,1, 1, 1,1, 0, 1, 0,  1,  0),
x=    c(1,1, 1, 0,0, 0, 1,1,   0,  0),
x2 = rnorm(10)) |>
as.data.frame()
test2$weights <- rep(runif(4, 2, 6), table(test2$idK))
test2 <- test2[order(test2$timeb, test2$timea), ]
fit <- coxme::coxme(Surv(timea, timeb, event) ~ x + x2 + (1 | idK), test2, weights = weights)
parts3 <- make_parts(fit, data = test2)
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
my_grad_func <- function(betas_bs, model, data){
# hack to put user-specified betas and bs into the model.
# wont work for more than one random effect.
fixed_effects <- coxme::fixef(model)
random_effects <- coxme::ranef(model)
p_fixef <- length(fixed_effects)
q_ranef <- length(unlist(random_effects))
betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
I
vv <- get_information(fit)
results_path <- file.path(Sys.getenv("OneDriveCommercial"), "PhD/outputs/simulations/data/variances_12.rds")
res <- readr::read_rds(results_path)
error_messages <- lapply(res, "[[", "error")
warning_messages <- lapply(res, "[[", "warning")
returned_values <- lapply(res, "[[", "value")
is.error <- sapply(error_messages, inherits, "error")
is.warning <- sapply(warning_messages, inherits, "warning")
res_times <- attr(res, 'times')
difftime(res_times[[2]], res_times[[1]])
attributes(res)
table(is.error) |> prop.table()
table(is.warning)
results_with_warnings <- res[is.warning]
non_error_fits <- returned_values[!is.error]
non_error_fits[[1]]
shape_res <- function(one_fit){
covars <- names(one_fit$coefs)
v1 <- one_fit$svycoxme_var
v2 <- one_fit$svycoxme_var_jackknife
v3 <- one_fit$fisher_var
tibble::tibble(
method = rep(c("sandwich_finite_pop", "cluster_jackknife", "fisher_info"), each = 3),
n_clusters_in_sample = one_fit$specs$n_clusters_in_sample,
cluster_size = one_fit$specs$cluster_size,
theta = one_fit$specs$theta,
covariate = rep(covars, 3),
coefs = rep(one_fit$coefs, 3),
true_coefs = rep(c(1, -0.7, 0.5), 3),
variance = c(v1, v2, v3),
lower = one_fit$coefs + qnorm(0.025) * sqrt(c(v1, v2, v3)),
upper = one_fit$coefs + qnorm(0.975) * sqrt(c(v1, v2, v3)),
hit = lower < true_coefs & upper > true_coefs
)
}
shape_res(non_error_fits[[1]])
df <- plyr::ldply(non_error_fits, shape_res)
coverage_summary <- df %>%
group_by(method, covariate, theta)  %>%
summarise(coverage = mean(hit, na.rm = TRUE),
prop_nas = sum(is.na(hit))/n(),
.groups = "drop")
library(tidyverse)
coverage_summary <- df %>%
group_by(method, covariate, theta)  %>%
summarise(coverage = mean(hit, na.rm = TRUE),
prop_nas = sum(is.na(hit))/n(),
.groups = "drop")
coverage_summary
coverage_summary %>%
ggplot(aes(theta, coverage, colour = method)) +
geom_line() + facet_grid(rows = vars(covariate)) +
geom_hline(yintercept = 0.95)
test2$rweights = test2$weights/mean(test2$weights)
fit <- coxme::coxme(Surv(timea, timeb, event) ~ x + x2 + (1 | idK), test2, weights = rweights)
parts3 <- make_parts(fit, data = test2)
# debugonce(calc_ui.coxme_parts)
score_mine <- calc_ui(parts3)
my_grad_func <- function(betas_bs, model, data){
# hack to put user-specified betas and bs into the model.
# wont work for more than one random effect.
fixed_effects <- coxme::fixef(model)
random_effects <- coxme::ranef(model)
p_fixef <- length(fixed_effects)
q_ranef <- length(unlist(random_effects))
betas <- betas_bs[seq_len(p_fixef)]
bs <- betas_bs[seq_len(q_ranef) + p_fixef]
if(p_fixef + q_ranef != length(betas_bs)) stop(paste("betas_bs must have length", p_fixef + q_ranef))
fixed_effects[] <- betas
random_effects[[1]] <- bs
model$coefficients <- betas
model$frail <- random_effects
make_parts(model, data) |> calc_ui() |> colSums()
}
test_vals <- c(coxme::fixef(fit),
unlist(coxme::ranef(fit)))
my_grad_func(test_vals, fit, data = test2)
hess <- numDeriv::jacobian(my_grad_func, x = test_vals,
model = fit, data = test2)
# the same!
max(solve(-hess) - get_information(fit))
# these are the parameter combinations
true_coefs = c(X1 = 1, X2 = -0.7, X3 = 0.5, Z1 = log(2))
the_data <- one_dataset(~X1 + X2 + X3 + Z1 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
Z1 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 5000, nk = 10,
n = 5000 * 10),
coefficients = true_coefs,
random_effect_variance = c(M=1)
)
devtools::load_all(".")
# these are the parameter combinations
true_coefs = c(X1 = 1, X2 = -0.7, X3 = 0.5, Z1 = log(2))
the_data <- one_dataset(~X1 + X2 + X3 + Z1 + (1 | M),
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
Z1 = ~rep(rbinom(k, 1, 0.5), each = nk),
M = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 5000, nk = 10,
n = 5000 * 10),
coefficients = true_coefs,
random_effect_variance = c(M=1)
)
pop <- dplyr::mutate(the_data, id = M)
# sample from it
# one cluster sample
pop_clusters <- dplyr::select(pop, id, Z1) %>%
dplyr::mutate(pr_sel = 2/75 * (1 + Z1))
sample_of_cluster = dplyr::slice_sample(pop_clusters, n = 100, weight_by = pr_sel)
my_samp <- pop[pop$id %in% sample_of_cluster$id, ]
my_samp <- dplyr::left_join(my_samp, pop_clusters, by = c("Z1", "id"))
my_samp$weights <- my_samp$pr_sel^-1
# rescale_weights
my_samp$rweights <- (1/my_samp$pr_sel)/mean(1/my_samp$pr_sel)
my_samp <- my_samp[order(my_samp$stat_time), ]
form <- survival::Surv(stat_time, stat)~ X1 + X2 + X3 + Z1 + (1|id)
coxme_fit <- coxme::coxme(form, data = my_samp, weights = rweights)
summary(coxme_fit)
my_des <- svydesign(~id, weights = ~weights, data = my_samp)
my_des_jackknife <- as.svrepdesign(my_des, type = "JK1")
my_des_bootstrap <- as.svrepdesign(my_des, type = "bootstrap")
svycoxme_fit <- eval(bquote( svycoxme(.(form), des = my_des) ))
svycoxme_fit_jackknife <- eval(bquote( svycoxme(form, des = my_des_jackknife) ))
class(svycoxme_fit)
summary(svycoxme_fit)
print(svycoxme_fit)
print(svycoxme_fit$survey.design)
class(svycoxme_fit)
summary(svycoxme_fit)
svycoxme_fit_toy <- svycoxme_fit
class(svycoxme_fit_toy) <- "svycoxme"
class(svycoxme_fit_toy)
summary(svycoxme_fit_toy)
methods(summary)
trace(summary.svycoxme)
summary(svycoxme_fit)
devtools::load_all(".")
devtools::load_all(".")
summary(svycoxme_fit)
summary(svycoxme_fit)
coef(svycoxme_fit)
methods(class = "coxme")
logLik(svycoxme_fit)
logLik.coxme
coxme::logLik.coxme
coxme:::logLik.coxme
coxme:::formula.coxme
methods(vcov)
coxph:::vcov.coxph
survival:::vcov.coxph
