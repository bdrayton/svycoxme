M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = specs$k, nk = specs$nk,
n = specs$k*specs$nk),
coefficients = specs$coefficients,
random_effect_variance = specs$random_effect_variance)
ds_des <- survey::svydesign(~M1, weights = ~1, data = ds)
ds_svrepdes <- survey::as.svrepdesign(ds_des)
start_time <- Sys.time()
# ests <- svycoxme(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), design = ds_svrepdes)
# ests <- eval(parse(text = glue::glue("svycoxme({specs$model}, design = ds_svrepdes")))
full <- substitute(svycoxme(f, design = ds_svrepdes), list(f = specs$model))
#
ests <- eval(full)
attr(ests, "run_time_mins") <- as.numeric(difftime(Sys.time(), start_time), units = 'mins')
attr(ests, "specs") <- specs
ests
}
test <- lapply(spec_list[1], one_rep)
global_specs <- list(
model = Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
k = 50,
nk = 4,
coefficients = c(1, -0.7, 0.5)
)
# reps per spec combination
nreps = 1
# thetas to try. Same as Ripatti and Palmgren
thetas <- c(0.5, 1, 2)
# build the spec list for reps
spec_list <- lapply(rep(thetas, each = nreps), function(theta){
c(global_specs, random_effect_variance = list(c(M1 = theta)))
})
one_rep <- function(specs){
ds <- one_dataset(specs$model,
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = specs$k, nk = specs$nk,
n = specs$k*specs$nk),
coefficients = specs$coefficients,
random_effect_variance = specs$random_effect_variance)
ds_des <- survey::svydesign(~M1, weights = ~1, data = ds)
ds_svrepdes <- survey::as.svrepdesign(ds_des)
start_time <- Sys.time()
# ests <- svycoxme(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), design = ds_svrepdes)
# ests <- eval(parse(text = glue::glue("svycoxme({specs$model}, design = ds_svrepdes")))
full <- substitute(svycoxme(f, design = ds_svrepdes), list(f = specs$model))
#
ests <- eval(full)
attr(ests, "run_time_mins") <- as.numeric(difftime(Sys.time(), start_time), units = 'mins')
attr(ests, "specs") <- specs
ests
}
test <- lapply(spec_list[1], one_rep)
one_rep <- function(specs){
ds <- one_dataset(specs$model,
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = specs$k, nk = specs$nk,
n = specs$k*specs$nk),
coefficients = specs$coefficients,
random_effect_variance = specs$random_effect_variance)
ds_des <- survey::svydesign(~M1, weights = ~1, data = ds)
ds_svrepdes <- survey::as.svrepdesign(ds_des)
# is this really the way to do it? bquote is being weird.
form <- Reduce(paste, deparse(specs$model))
start_time <- Sys.time()
ests <- eval(parse(text = glue::glue("svycoxme({form}, design = ds_svrepdes")))
attr(ests, "run_time_mins") <- as.numeric(difftime(Sys.time(), start_time), units = 'mins')
attr(ests, "specs") <- specs
ests
}
test <- lapply(spec_list[1], one_rep)
one_rep <- function(specs){
ds <- one_dataset(specs$model,
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = specs$k, nk = specs$nk,
n = specs$k*specs$nk),
coefficients = specs$coefficients,
random_effect_variance = specs$random_effect_variance)
ds_des <- survey::svydesign(~M1, weights = ~1, data = ds)
ds_svrepdes <- survey::as.svrepdesign(ds_des)
# is this really the way to do it? bquote is being weird.
form <- Reduce(paste, deparse(specs$model))
start_time <- Sys.time()
ests <- eval(parse(text = glue::glue("svycoxme({form}, design = ds_svrepdes)")))
attr(ests, "run_time_mins") <- as.numeric(difftime(Sys.time(), start_time), units = 'mins')
attr(ests, "specs") <- specs
ests
}
debugonce(one_rep)
test <- lapply(spec_list[1], one_rep)
#
attr(test[[1]], "run_time")
attr(test[[1]], "specs")
confint(test[[1]])
one_rep <- function(specs){
ds <- one_dataset(specs$model,
dists = list(X1 = ~rnorm(n),
X2 = ~rep(rnorm(k), each = nk),
X3 = ~rep(rbinom(k, 1, 0.5), each = nk),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = specs$k, nk = specs$nk,
n = specs$k*specs$nk),
coefficients = specs$coefficients,
random_effect_variance = specs$random_effect_variance)
ds_des <- survey::svydesign(~M1, weights = ~1, data = ds)
ds_svrepdes <- survey::as.svrepdesign(ds_des)
# is this really the way to do it? bquote is being weird.
form <- Reduce(paste, deparse(specs$model))
start_time <- Sys.time()
ests <- eval(parse(text = glue::glue("svycoxme({form}, design = ds_svrepdes)")))
attr(ests, "run_time_mins") <- as.numeric(difftime(Sys.time(), start_time), units = 'mins')
attr(ests, "specs") <- specs
ests
}
coxme::VarCorr(test[[1]])
#stop the cluster
parallel::stopCluster(cl)
b = matrix(rnorm(10), ncol = 1)
b
t(b)%*% b
t(b)%*% diag(10) %*% b
devtools::load_all(".")
true_theta = 0.5
k = 50
nk = 4
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
# ests <- est_parameters(my_formula, data = ds)
b <- Matrix(ests$b, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
# # could just take ests from coxme. I do this - see above
# th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
#                       formula = my_formula,
#                       parsed_data = make_ppl(parsed_data),
#                       other_args = list(start_params = ests$par,
#                                         stat = Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1),
#                                         reltol = 1e-13))
th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
formula = my_formula,
parsed_data = make_ppl(parsed_data),
ests = coxme_fit_ests,
simple = simple)
ses <- c(sqrt(unlist(th)),
numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)))
attr(ses, "analytical_parts") <- attr(ana_hess, "parts")
ses
}
res <- one_rep(0.5, 50, 10)
devtools::load_all(".")
tr
res <- one_rep(0.5, 50, 10)
unchol <- function(chol_mat){
L <- as.matrix(chol_mat)
D <- diag(chol_mat)
L %*% diag(D) %*% t(L)
}
res <- one_rep(0.5, 50, 10)
res
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
debug(calc_hessian_cell)
b <- Matrix(ests$b, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]))
hess_ij
hess_ij_simple
(t(b) %*% b) / theta^3
-q/theta^2
tr(Kbb_inv %*% Kbb_inv)/theta^4 - 2*tr(Kbb_inv)/theta^3
2 * (t(b) %*% b) / theta^3
simple
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]),
simple = simple)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]),
simple = TRUE)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
formula = my_formula,
parsed_data = make_ppl(parsed_data),
ests = coxme_fit_ests,
simple = simple)
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
# ests <- est_parameters(my_formula, data = ds)
b <- Matrix(ests$b, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]),
simple = simple)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
# # could just take ests from coxme. I do this - see above
# th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
#                       formula = my_formula,
#                       parsed_data = make_ppl(parsed_data),
#                       other_args = list(start_params = ests$par,
#                                         stat = Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1),
#                                         reltol = 1e-13))
th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
formula = my_formula,
parsed_data = make_ppl(parsed_data),
ests = coxme_fit_ests,
simple = simple)
ses <- c(sqrt(unlist(th)),
numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)))
# attr(ses, "analytical_parts") <- attr(ana_hess, "parts")
ses
}
devtools::load_all(".")
res <- one_rep(0.5, 50, 10)
res <- one_rep(0.5, 50, 10, simple = TRUE)
res
debugonce(one_rep)
debug(calc_hessian_cell)
res <- one_rep(0.5, 50, 10, simple = TRUE)
function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
# ests <- est_parameters(my_formula, data = ds)
b <- Matrix(ests$b, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]),
simple = simple)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
# # could just take ests from coxme. I do this - see above
# th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
#                       formula = my_formula,
#                       parsed_data = make_ppl(parsed_data),
#                       other_args = list(start_params = ests$par,
#                                         stat = Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1),
#                                         reltol = 1e-13))
th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
formula = my_formula,
parsed_data = make_ppl(parsed_data),
ests = coxme_fit_ests,
simple = simple)
ses <- c(sqrt(unlist(th)),
numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)))
# attr(ses, "analytical_parts") <- attr(ana_hess, "parts")
ses
}
th
sqrt(unlist(th))
sqrt(solve(-ana_hess))
sqrt(solve(ana_hess))
diag(sqrt(solve(-attr(ests, "theta_est")$hessian)))
res
calc_hessian_cell <- function(dD_i, dD_j, D_inv, q, theta, b, Kbb_inv, simple = FALSE, ...){
t1 = -tr( D_inv %*% dD_j %*% D_inv %*% dD_i )
# t1_simple = -q/theta^2
t2 =tr( Kbb_inv %*% D_inv %*% dD_j %*% D_inv %*% Kbb_inv %*% D_inv %*% dD_i %*% D_inv
- Kbb_inv %*% ( D_inv %*% dD_j %*% D_inv %*% dD_i %*% D_inv
+ D_inv %*% dD_i %*% D_inv %*% dD_j %*% D_inv))
# t2_simple = tr(Kbb_inv %*% Kbb_inv)/theta^4 - 2*tr(Kbb_inv)/theta^3
t3 = t(b)%*%(D_inv%*%dD_j%*%D_inv%*%dD_i%*%D_inv + D_inv%*%dD_i%*%D_inv%*%dD_j%*%D_inv)%*%b
# t3_simple = 2 * (t(b) %*% b) / theta^3
hess_ij <- -0.5 * ( t1 + t2 + t3 )
# hess_ij_simple <- -0.5 * (t1_simple + t2_simple + t3_simple)
hess_ij_simple = q/theta^2 + tr(Kbb_inv)/theta^3 + tr(Kbb_inv %*% Kbb_inv)/(2*theta^4) + (t(b) %*% b)/theta^3
# if(!all.equal(hess_ij, hess_ij_simple)) stop("simple and complex computations not the same")
if(simple){
r <- hess_ij_simple@x
# attr(r, "parts") <- -0.5 * c(t1_simple, t2_simple, t3_simple@x)
} else {
r <- hess_ij@x
attr(r, "parts") <- -0.5 * c(t1, t2, t3@x)
}
r
}
# the numerical variance from est_parameters is about the same as reported in the
# ripatti paper.
# The analytical variance should be about the same as the numerical version.
# Here I compare them as a check of both the simple and complex versions.
true_theta = 0.5
k = 50
nk = 4
# library(bdsmatrix)
unchol <- function(chol_mat){
L <- as.matrix(chol_mat)
D <- diag(chol_mat)
L %*% diag(D) %*% t(L)
}
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
# ests <- est_parameters(my_formula, data = ds)
b <- Matrix(ests$b, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]),
simple = simple)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
# # could just take ests from coxme. I do this - see above
# th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
#                       formula = my_formula,
#                       parsed_data = make_ppl(parsed_data),
#                       other_args = list(start_params = ests$par,
#                                         stat = Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1),
#                                         reltol = 1e-13))
th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
formula = my_formula,
parsed_data = make_ppl(parsed_data),
ests = coxme_fit_ests,
simple = simple)
ses <- c(sqrt(unlist(th)),
numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)))
# attr(ses, "analytical_parts") <- attr(ana_hess, "parts")
ses
}
res <- one_rep(0.5, 50, 10, simple = TRUE)
devtools::load_all(".")
res <- one_rep(0.5, 50, 10, simple = TRUE)
res
devtools::load_all(".")
res <- one_rep(0.5, 50, 10, simple = TRUE)
res
0.86^2
true_theta = 0.5
k = 50
nk = 450
# library(bdsmatrix)
unchol <- function(chol_mat){
L <- as.matrix(chol_mat)
D <- diag(chol_mat)
L %*% diag(D) %*% t(L)
}
one_rep <- function(true_theta, nk, k, simple = TRUE){
my_formula <- survival::Surv(stat_time, stat)~ X1 + (1 | M1)
ds <- one_dataset(my_formula,
dists = list(X1 = ~rnorm(n),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = k, nk = nk, n = k*nk),
coefficients = c(1),
random_effect_variance = c(M1 = true_theta)
)
ests <- est_parameters(my_formula, data = ds, control = control.list(grad = TRUE))
# ests <- est_parameters(my_formula, data = ds)
b <- Matrix(ests$b, ncol = 1)
q <- length(b)
dD <- diag(q)
ana_hess <- calc_hessian_cell(dD_i = dD,
dD_j = dD,
q = q,
D_inv = solve(ests$theta * dD),
theta = ests$theta,
b = b,
Kbb_inv = solve(attr(ests, "beta_b_est")$hessian[-1, -1]),
simple = simple)
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(my_formula, data = ds_sorted)
coxme_fit <- coxme::coxme(my_formula, data = ds)
coxme_fit_ests <- list(par = c(coxme::fixef(coxme_fit), coxme::ranef(coxme_fit)$M1),
hessian = -unchol(coxme_fit$hmat))
# # could just take ests from coxme. I do this - see above
# th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
#                       formula = my_formula,
#                       parsed_data = make_ppl(parsed_data),
#                       other_args = list(start_params = ests$par,
#                                         stat = Matrix(unclass(parsed_data$fr[,1])[, "status"], ncol = 1),
#                                         reltol = 1e-13))
th <- theta_ipl_hess(theta = coxme::VarCorr(coxme_fit)$M1,
formula = my_formula,
parsed_data = make_ppl(parsed_data),
ests = coxme_fit_ests,
simple = simple)
ses <- c(sqrt(unlist(th)),
numeric = diag(sqrt(solve(-attr(ests, "theta_est")$hessian))),
analytical_se = sqrt(solve(-ana_hess)))
# attr(ses, "analytical_parts") <- attr(ana_hess, "parts")
ses
}
res <- one_rep(0.5, 50, 10, simple = TRUE)
res
res <- one_rep(0.5, 50, 10, simple = TRUE)
res
