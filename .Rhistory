fit_beta_b <- optim(par = c(beta, b),
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
stat_time = stat_time ,
cluster = "M",
dij = stat,
theta = theta,
data = ds,
method = "BFGS",
control = list(fnscale = -1))
fit_beta_b <- optim(par = c(beta, b),
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
stat_time = stat_time ,
cluster = "M1",
dij = stat,
theta = theta,
data = ds,
method = "BFGS",
control = list(fnscale = -1))
fit_beta_b
c(beta, b)
fit0 <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2 + X3, data = ds)
my_start_parameters <- c(coef(fit0), rep(0, 50))
names(my_start_parameters) <- c(c("X1", "X2", "X3"), paste0("Z", seq_len(50)))
my_start_parameters <- c(coef(fit0), rep(0, 10))
fit_beta_b <- optim(par = my_start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
stat_time = stat_time ,
cluster = "M1",
dij = stat,
theta = theta,
data = ds,
method = "BFGS",
control = list(fnscale = -1))
fit_beta_b
my_start_parameters <- c(coef(fit0), rep(0, 10))
names(my_start_parameters) <- c(c("X1", "X2", "X3"), paste0("Z", seq_len(10)))
fit_beta_b <- optim(par = my_start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
stat_time = stat_time ,
cluster = "M1",
dij = stat,
theta = theta,
data = ds,
method = "BFGS",
control = list(fnscale = -1))
new_lp <- function(params, formula, data, theta) {
# This sort var could be pulled out of the formula.
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_along(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
# drop the intercept column from the X model.matrix
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
# calculate risk sets
# I do it this way to preserve the class and other slots. rev(risk_score) coerces to a numeric vector.
# probably no point, as cumsum convert it anyway, and I need to remake the matrix with Matrix.
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
# would be good to peel stat out of the Surv() obeject in the parsed formula...
stat <- Matrix(ds_sorted$stat, ncol = 1)
# penalty
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
penalty <- 0.5 * t(b) %*% solve(parsed_data$reTrms$Lambdat) %*% b
penalised_likelihood <- sum(stat * (risk_score - log(at_risk))) - penalty
penalised_likelihood@x
}
new_lp(params = c(beta, b), survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), data = ds, theta = theta)
debugonce(new_lp)
new_lp(params = c(beta, b), survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), data = ds, theta = theta)
parsed_data$X
ncol(parsed_data$X)
ncol(parsed_data$X) - 1
new_lp <- function(params, formula, data, theta) {
# This sort var could be pulled out of the formula.
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
# drop the intercept column from the X model.matrix
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
# calculate risk sets
# I do it this way to preserve the class and other slots. rev(risk_score) coerces to a numeric vector.
# probably no point, as cumsum convert it anyway, and I need to remake the matrix with Matrix.
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
# would be good to peel stat out of the Surv() obeject in the parsed formula...
stat <- Matrix(ds_sorted$stat, ncol = 1)
# penalty
parsed_data$reTrms$Lambdat@x <- theta[parsed_data$reTrms$Lind]
penalty <- 0.5 * t(b) %*% solve(parsed_data$reTrms$Lambdat) %*% b
penalised_likelihood <- sum(stat * (risk_score - log(at_risk))) - penalty
penalised_likelihood@x
}
new_lp(params = c(beta, b), survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), data = ds, theta = theta)
new_fit_beta_b <- optim(par = my_start_parameters,
fn = new_lp,
gr = NULL,
formula = survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds,
theta = theta)
fit_beta_b
cbind(
fit_beta_b$par,
new_fit_beta_b$par)
new_fit_beta_b <- optim(par = my_start_parameters,
fn = new_lp,
gr = NULL,
formula = survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds,
theta = theta,
method = "BFGS",
control = list(fnscale = -1))
cbind(
fit_beta_b$par,
new_fit_beta_b$par)
microbenchmark::microbenchmark(
fit_beta_b <- optim(par = my_start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
stat_time = stat_time ,
cluster = "M1",
dij = stat,
theta = theta,
data = ds,
method = "BFGS",
control = list(fnscale = -1)),
new_fit_beta_b <- optim(par = my_start_parameters,
fn = new_lp,
gr = NULL,
formula = survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds,
theta = theta,
method = "BFGS",
control = list(fnscale = -1))
)
risk_sets_X <- calcRiskSets(r1, c("X1", "X2", "X3"), "Xr")
r1 <- calcLinearPredictor(data_with_Z, X = c("X1", "X2", "X3"), Z = attr(data_with_Z, "Z_names"), c(beta, b))
data_with_Z <- add_Z(ds_sorted, "M1")
ds_sorted <- sortAndIndex(ds, sort_vars = stat_time)
parsed_data <- lme4::lFormula(survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), data = ds_sorted)
# drop the intercept column from the X model.matrix
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
data_with_Z <- add_Z(ds_sorted, "M1")
r1 <- calcLinearPredictor(data_with_Z, X = c("X1", "X2", "X3"), Z = attr(data_with_Z, "Z_names"), c(beta, b))
table(r1 == as.vector(risk_score))
cbind(r1$lp, risk_score@x, r1$lp - risk_score@x)
max(r1$lp - risk_score@x) < .Machine$double.eps*10
# calculate risk sets
# I do it this way to preserve the class and other slots. rev(risk_score) coerces to a numeric vector.
# probably no point, as cumsum convert it anyway, and I need to remake the matrix with Matrix.
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
risk_sets <- calcRiskSets(data = r1)
max(risk_sets$cumsum_A - at_risk@x)
risk_sets_X <- calcRiskSets(r1, c("X1", "X2", "X3"), "Xr")
risk_sets_X
at_risk
parsed_data
parsed_data$X
str(parsed_data$X)
parsed_data$X[-1]
parsed_data$X[,-1]
at_risk * parsed_data$X[,-1]
exp_risk_score_X <- exp_risk_score * parsed_data$X[,-1]
exp_risk_score@x
exp_risk_score
exp_risk_score
parsed_data$X[,-1]
exp_risk_score_X
exp_risk_score_X@x
lapply(exp_risk_score_X, function(column){
Matrix(rev(cumsum(column)), ncol = 1)
})
apply(exp_risk_score_X, 2, function(column){
Matrix(rev(cumsum(column)), ncol = 1)
})
apply(exp_risk_score_X, 2, function(column){
Matrix(rev(cumsum(column)), ncol = 1)
}) |> cbind()
at_risk_list <- apply(exp_risk_score_X, 2, function(column){
Matrix(rev(cumsum(column)), ncol = 1)
})
Reduce(cbind, at_risk_list)
at_risk_X <- Reduce(cbind, at_risk_list)
# would be good to peel stat out of the Surv() obeject in the parsed formula...
stat <- Matrix(ds_sorted$stat, ncol = 1)
at_risk_X
at_risk
at_risk_X/at_risk
parsed_data$X[-1] - at_risk_X/at_risk
parsed_data$X[-1]
parsed_data$X[, -1] - at_risk_X/at_risk
stat * (parsed_data$X[, -1] - at_risk_X/at_risk)
colSums(stat * (parsed_data$X[, -1] - at_risk_X/at_risk))
lp_gr_beta <- function(params, formula, data, theta) {
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
exp_risk_score_X <- exp_risk_score * parsed_data$X[,-1]
at_risk_list <- apply(exp_risk_score_X, 2, function(column){
Matrix(rev(cumsum(column)), ncol = 1)
})
at_risk_X <- Reduce(cbind, at_risk_list)
stat <- Matrix(ds_sorted$stat, ncol = 1)
likelihood_gradients <- colSums(stat * (parsed_data$X[, -1] - at_risk_X/at_risk))
likelihood_gradients
}
ds <- one_dataset(~X1 + X2 + X3 + (1 | M1),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 10, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 0.5)
)
beta = c(1, 1, 1)
b <- c(rnorm(10, mean = 0, sd = 1))
theta <- 1
lp(parms = c(beta, b),
X = c("X1", "X2", "X3"), stat_time = stat_time, dij = stat, theta = theta, cluster = "M1", data = ds)
dlp_beta(parms = c(beta, b),
X = c("X1", "X2", "X3"),
stat_time = stat_time,
dij = stat,
theta = theta,
cluster = "M1", data = ds)
lp_gr_beta(params = c(beta, b), survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), data = ds, theta = theta)
lp_gr_beta <- function(params, formula, data, theta) {
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
exp_risk_score_X <- exp_risk_score * parsed_data$X[,-1]
at_risk_list <- apply(exp_risk_score_X, 2, function(column){
Matrix(rev(cumsum(rev(column))), ncol = 1)
})
at_risk_X <- Reduce(cbind, at_risk_list)
stat <- Matrix(ds_sorted$stat, ncol = 1)
likelihood_gradients <- colSums(stat * (parsed_data$X[, -1] - at_risk_X/at_risk))
likelihood_gradients
}
dlp_beta(parms = c(beta, b),
X = c("X1", "X2", "X3"),
stat_time = stat_time,
dij = stat,
theta = theta,
cluster = "M1", data = ds)
lp_gr_beta(params = c(beta, b), survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), data = ds, theta = theta)
microbenchmark::microbenchmark(
dlp_beta(parms = c(beta, b),
X = c("X1", "X2", "X3"),
stat_time = stat_time,
dij = stat,
theta = theta,
cluster = "M1", data = ds),
lp_gr_beta(params = c(beta, b), survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1), data = ds, theta = theta)
)
parsed_data$reTrms$Zt
t(parsed_data$reTrms$Zt)
solve(parsed_data$reTrms$Lambdat) %*% b
lp_gr_b <- function(params, formula, data, theta) {
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
exp_risk_score_Z <- exp_risk_score * t(parsed_data$reTrms$Zt)
at_risk_list <- apply(exp_risk_score_Z, 2, function(column){
Matrix(rev(cumsum(rev(column))), ncol = 1)
})
at_risk_Z <- Reduce(cbind, at_risk_list)
stat <- Matrix(ds_sorted$stat, ncol = 1)
likelihood_gradients <- colSums(stat * (t(parsed_data$reTrms$Zt) - at_risk_Z/at_risk))
likelihood_gradients
}
lp_gr_b(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta)
debugonce(lp_gr_b)
lp_gr_b(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta)
exp_risk_score
t(parsed_data$reTrms$Zt)
exp_risk_score * t(parsed_data$reTrms$Zt)
dim(exp_risk_score)
dim(t(parsed_data$reTrms$Zt))
t(parsed_data$reTrms$Zt) * exp_risk_score
Matrix(rep(exp_risk_score, length(b)), ncol = length(b)) * t(parsed_data$reTrms$Zt)
lp_gr_b <- function(params, formula, data, theta) {
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
bl <- length(b)
exp_risk_score_Z <- Matrix(rep(exp_risk_score, bl), ncol = bl) * t(parsed_data$reTrms$Zt)
at_risk_list <- apply(exp_risk_score_Z, 2, function(column){
Matrix(rev(cumsum(rev(column))), ncol = 1)
})
at_risk_Z <- Reduce(cbind, at_risk_list)
stat <- Matrix(ds_sorted$stat, ncol = 1)
likelihood_gradients <- colSums(stat * (t(parsed_data$reTrms$Zt) - at_risk_Z/at_risk))
likelihood_gradients
}
lp_gr_b(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta)
D <- theta * daig(10)
D <- theta * diag(10)
dlp_b(parms = c(beta, b),
X = c("X1", "X2", "X3"),
stat_time = stat_time,
dij = stat,
theta = theta,
D = theta * diag(10),
cluster = "M1", data = ds)
theta * diag(10)
my_params <- c(beta, b)
my_params
names(my_params) <- c(c("X1", "X2", "X3"), paste0("Z", seq_len(10)))
dlp_b(parms = my_params,
X = c("X1", "X2", "X3"),
stat_time = stat_time,
dij = stat,
theta = theta,
D = theta * diag(10),
cluster = "M1", data = ds)
lp_gr_b(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta)
lp_gr_b(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta) |> str()
0.5 * t(b) %*% solve(parsed_data$reTrms$Lambdat)
t(b) %*% solve(parsed_data$reTrms$Lambdat)
lp_gr_b <- function(params, formula, data, theta) {
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
bl <- length(b)
exp_risk_score_Z <- Matrix(rep(exp_risk_score, bl), ncol = bl) * t(parsed_data$reTrms$Zt)
at_risk_list <- apply(exp_risk_score_Z, 2, function(column){
Matrix(rev(cumsum(rev(column))), ncol = 1)
})
at_risk_Z <- Reduce(cbind, at_risk_list)
stat <- Matrix(ds_sorted$stat, ncol = 1)
likelihood_gradients_unpenalised <- colSums(stat * (t(parsed_data$reTrms$Zt) - at_risk_Z/at_risk))
penalty <- t(b) %*% solve(parsed_data$reTrms$Lambdat)
likelihood_gradients_unpenalised - penalty
}
lp_gr_b(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta)
dlp_b(parms = my_params,
X = c("X1", "X2", "X3"),
stat_time = stat_time,
dij = stat,
theta = theta,
D = theta * diag(10),
cluster = "M1", data = ds)
lp_gr_b <- function(params, formula, data, theta) {
ds_sorted <- sortAndIndex(data, sort_vars = stat_time)
parsed_data <- lme4::lFormula(formula, data = ds_sorted)
beta_index <- seq_len(ncol(parsed_data$X) - 1)
beta <- params[beta_index]
b <- params[-beta_index]
risk_score <- parsed_data$X[, -1] %*% beta + crossprod(parsed_data$reTrms$Zt, b)
exp_risk_score <- exp(risk_score)
rev_exp_risk_score <- exp_risk_score
rev_exp_risk_score@x <- rev(exp_risk_score@x)
at_risk <- Matrix(rev(cumsum(rev_exp_risk_score)), ncol = 1)
bl <- length(b)
exp_risk_score_Z <- Matrix(rep(exp_risk_score, bl), ncol = bl) * t(parsed_data$reTrms$Zt)
at_risk_list <- apply(exp_risk_score_Z, 2, function(column){
Matrix(rev(cumsum(rev(column))), ncol = 1)
})
at_risk_Z <- Reduce(cbind, at_risk_list)
stat <- Matrix(ds_sorted$stat, ncol = 1)
likelihood_gradients_unpenalised <- colSums(stat * (t(parsed_data$reTrms$Zt) - at_risk_Z/at_risk))
penalty <- t(b) %*% solve(parsed_data$reTrms$Lambdat)
# this accessing @x is probably poor practice?
likelihood_gradients_unpenalised - penalty@x
}
dlp_b(parms = my_params,
X = c("X1", "X2", "X3"),
stat_time = stat_time,
dij = stat,
theta = theta,
D = theta * diag(10),
cluster = "M1", data = ds)
lp_gr_b(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta)
microbenchmark::microbenchmark(
dlp_b(parms = my_params,
X = c("X1", "X2", "X3"),
stat_time = stat_time,
dij = stat,
theta = theta,
D = theta * diag(10),
cluster = "M1", data = ds)
,
lp_gr_b(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta)
)
lp_gr <- function(params, formula, data, theta) {
c(lp_gr_beta(params = params, formula = formula, data = data, theta = theta),
lp_gr_b(params = params, formula = formula, data = data, theta = theta))
}
lp_gr(params = c(beta, b),
survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds, theta = theta)
new_fit_beta_b <- optim(par = my_start_parameters,
fn = new_lp,
gr = lp_gr,
formula = survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds,
theta = theta,
method = "BFGS",
control = list(fnscale = -1))
ds <- one_dataset(~X1 + X2 + X3 + (1 | M1),
dists = list(X1 = ~rnorm(n),
X2 = ~rnorm(k * nk),
X3 = ~rbinom(n, 1, 0.5),
M1 = ~rep(1:k, each = nk),
error = ~rexp(n, 10),
stat = ~sample(rep(c(0, 1), round(n * c(0.2, 0.8))), n)),
dist_args = list(k = 10, nk = 4, n = 200),
coefficients = c(1, 1, 1),
random_effect_variance = list(M1 = 0.5)
)
beta = c(1, 1, 1)
b <- c(rnorm(10, mean = 0, sd = 1))
theta <- 1
fit0 <- survival::coxph(survival::Surv(stat_time, stat) ~ X1 + X2 + X3, data = ds)
my_start_parameters <- c(coef(fit0), rep(0, 10))
names(my_start_parameters) <- c(c("X1", "X2", "X3"), paste0("Z", seq_len(10)))
microbenchmark::microbenchmark(
fit_beta_b <- optim(par = my_start_parameters,
fn = lp,
gr = lp_grd,
X = c("X1", "X2", "X3"),
stat_time = stat_time ,
cluster = "M1",
dij = stat,
theta = theta,
data = ds,
method = "BFGS",
control = list(fnscale = -1)),
new_fit_beta_b <- optim(par = my_start_parameters,
fn = new_lp,
gr = lp_gr,
formula = survival::Surv(stat_time, stat) ~ X1 + X2 + X3 + (1 | M1),
data = ds,
theta = theta,
method = "BFGS",
control = list(fnscale = -1))
)
10.09987/2.58403
2.58403/10.09987
