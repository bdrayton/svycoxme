# if(!is.null(random_effect_seed)) set.seed(random_effect_seed[[re]])
b <- rnorm(length(group_counts), mean = 0, sd = sqrt(random_effect_variance[[re]]))
b_rep <- dplyr::left_join(data.frame(re_name = re_factor),
data.frame(re_name = names(group_counts), re = b), by = "re_name")
# This is the random effect repeated for each observation
re <- b_rep$re
# this is the unique random effects
names(b) <- names(group_counts)
attr(re, "random_effects") <- b
re
})
lp_random_effects <- Reduce("cbind", lp_random_effects_list)
random_effects <- lapply(lp_random_effects_list, attr, "random_effects")
# reset randomness
# set.seed(arbitraty_seed)
} else {
random_effects <- NULL
}
# transpose non-zero length coefficients
if(length(coefficients))
coefficients <- t(coefficients)
risk_score_parts_list <- list(fixed = tcrossprod(as.matrix(data[, fixed_term_variables]), coefficients),
random = lp_random_effects)
risk_score_parts_list <- risk_score_parts_list[lapply(risk_score_parts_list, length)>0]
risk_score_parts_matrix <- Reduce(cbind, risk_score_parts_list)
if(!is.null(risk_score_parts_matrix)) {
risk_score <- .rowSums(risk_score_parts_matrix,
m = nrow(risk_score_parts_matrix), n = ncol(risk_score_parts_matrix))
} else {
risk_score <- rep(0, length(error))
data <- data.frame(stat_time = numeric(length(error)))
}
# this is the old way.
# vars_df$stat_time <- exp(-risk_score) * error
# instead
# this wont work generally.
# there are four scenarios:
# no changes in covariates
# no one event
# no changes in covariates,
# multiple events
# changes in covariates,
# one event
# changes in covariates,
# multiple events
# make the time accounting consistent. so always time_start and time_stop.
response_type = attr(model_response, 'type')
if(response_type == "right"){
# time_stop = response[,"time"]
# time_start = rep(0, length(time_stop))
# stat = response[,'status']
} else if(response_type == "counting") {
# time_start = response[,"start"]
# time_stop = response[,"stop"]
# stat = response[,"status"]
} else {
stop("response type is not supported")
}
# probably need a better solution for id. coerce from what ever it is to
# integer, with a way to get the original ids mapped back to the result
d_list <- C_draw_event_times(id = as.integer(my_data[,idx]),
start_time = as.double(data[,Surv_vars[1]]),
end_time = as.double(data[,Surv_vars[2]]),
status = as.integer(data[,Surv_vars[3]]),
X = as.matrix(X),
risk_score = risk_score,
baseline_hazard = baseline_hazard,
baseline_hazard_start = t,
baseline_hazard_end = end_of_follow_up,
end_of_follow_up = end_of_follow_up,
origin = origin,
single = as.integer(event == "single"))
data_with_events <- data.frame(d_list[[1]],
d_list[[5]])
names(data_with_events) <- c(idx, colnames(X))
data_with_events[Surv_vars[1]] <- d_list[[2]]
data_with_events[Surv_vars[2]] <- d_list[[3]]
data_with_events[Surv_vars[3]] <- d_list[[4]]
# lets see where we're at at this point.
return(data_with_events)
}
# debugonce(draw_event_times)
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t=0 , origin = 0, id = id, event = "single", end_of_follow_up = 10)
# debugonce(draw_event_times)
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t = 0 , origin = 0, id = id, event = "single", end_of_follow_up = 10)
# debugonce(draw_event_times)
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t = 0 , origin = 0, id = id, event = "single", end_of_follow_up = 10)
devtools::load_all(".")
t_follow_up_starts = 0
t_follow_up_ends = 5
# get some change points, and generate X1 and X2.
n = 2
n_changes = 3
n_obs = n_changes + 1
t_change <- matrix(runif(n_changes * n,
min = t_follow_up_starts,
max = t_follow_up_ends/n_changes),
nrow = n_changes, ncol = n)
changes <- matrixStats::colCumsums(t_change)
starts = rbind(matrix(0, nrow = 1, ncol = n), changes) |> as.vector()
ends = rbind(changes, matrix(t_follow_up_ends, nrow = 1, ncol = n)) |> as.vector()
# X1 - cumulative exposure
X1 <-  matrix(rnorm(n_obs * n) |> abs(), nrow = n_obs, ncol = n) |>
matrixStats::colCumsums() |> as.vector()
my_data = data.frame(id = rep(seq(n), each = n_obs),
t_start = starts,
t_end = ends,
X1 = X1,
X2 = rbinom(n * n_obs, size = 1, prob = 0.5))
X <- as.matrix(my_data[c("X1", "X2")])
my_data
C_draw_event_times(id = my_data$id, start_time = my_data$t_start, end_time = my_data$t_end,
status = integer(length = nrow(my_data)),  X = X, risk_score = rnorm(nrow(my_data)),
baseline_hazard = 0.5, baseline_hazard_start = 0, baseline_hazard_end = 5,
end_of_follow_up = 5, origin = 0, single = 0)
C_draw_event_times(id = my_data$id, start_time = my_data$t_start, end_time = my_data$t_end,
status = integer(length = nrow(my_data)),  X = X, risk_score = rnorm(nrow(my_data)),
baseline_hazard = 0.5, baseline_hazard_start = 0, baseline_hazard_end = 5, origin = 0, single = 0)
# debugonce(draw_event_times)
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t = 0 , origin = 0, id = id, event = "single")
max(my_data$t_end)
C_draw_event_times(id = my_data$id, start_time = my_data$t_start, end_time = my_data$t_end,
status = integer(length = nrow(my_data)),  X = X, risk_score = rnorm(nrow(my_data)),
baseline_hazard = 0.5, baseline_hazard_start = 0, baseline_hazard_end = max(my_data$t_end),
origin = 0, single = 0)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
C_draw_event_times(id = my_data$id, start_time = my_data$t_start, end_time = my_data$t_end,
status = integer(length = nrow(my_data)),  X = X, risk_score = rnorm(nrow(my_data)),
baseline_hazard = 0.5, baseline_hazard_start = 0,
origin = 0, single = 0)
# debugonce(draw_event_times)
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t = 0 , origin = 0, id = id, event = "single")
draw_event_times <- function(formula, data, coefficients = c(), random_effect_variance = list(), id,
baseline_hazard = 1, t = 0, event = c("single", "recurrent"),
origin = 0, end_of_follow_up = NULL) {
Call <- match.call()
event <- match.arg(event)
Call_id <- Call[["id"]]
if (is.null(Call_id)){
stop("id required")
} else if (is.name(Call_id)) {
idx <- as.character(Call_id)
}
if (is.null(end_of_follow_up) & event == "recurrent") stop("end_of_follow_up must be specified for recurrent events")
fixed_terms <- stats::terms(lme4::nobars(formula))
# These are the fixed term variables in the formula, even if there are interactions.
fixed_term_variables <- colnames(attr(fixed_terms, "factors"))
bars = lme4::findbars(formula)
barnames = lme4:::barnames(bars)
random_terms = terms(as.formula(paste("~", paste(c(1, barnames), collapse = "+"))))
random_term_variables <- rownames(attr(random_terms, "factors"))
variables <- c(fixed_term_variables, random_term_variables)
if(attr(fixed_terms, "response") == 0) stop("formula must have a Surv response")
# strata
# find the strata spec in the form.
# make sure there is a baseline hazard for each stratum
# clustering. dont allow a cluster() call in the formula. instead ask for (1|cluster_id).
# Or allow it and covert it.
# will need an associated random effect.
# cluster in the sandwich means that the variances are cluster-specific. need to allow input of variance structure?
# data will have start and stop times, as specified, but only if there is time-varying covariates.
# otherwise there wont be times.
# and there wont be a stat variable.
Surv_Call <- Call$formula[[2]]
# get time names out of the Call.
# cant use the attribute, because the data need the variables in the call before calling model.frame.
# but I'll use the length of the Surv_call instead. This will probably break if anything but one or two times
# are passed to Surv. Maybe I need to evaluate Surv? Nope. need the vars first.
# Surv_evaluated <- eval(Surv_Call)
# if(attr(model_response, "type") == "counting"){
if(length(Surv_Call) == 4){
start_name <- Surv_Call[[2]]
stop_name <- Surv_Call[[3]]
status_name <- Surv_Call[[4]]
Surv_vars <- c(start_name, stop_name, status_name)
# } else if(attr(model_response, "type") == "right"){
} else if(length(Surv_Call) == 3) {
start_name <- "origin"
stop_name <- Surv_Call[[2]]    # actually called time, not stop
status_name <- Surv_Call[[3]]
if(start_name == stop_name) {stop("You need to call your event times something other than, 'origin'")}
Surv_vars <- c(start_name, stop_name, status_name)
}
# convert Surv_vars from a list of names to a character vector
Surv_vars <- sapply(Surv_vars, as.character)
# check if variables in the Surv() Call are already in the data set.
Surv_vars_in_data <- Surv_vars %in% colnames(data)
# add the ones that aren't
# need a message or warning? Probably not. Just explain in documentation
# message(paste(Surv_vars[Surv_vars_in_data], collapse = ", "), paste(" will be modified"))
if(any(!Surv_vars_in_data)){
data[Surv_vars[!Surv_vars_in_data]] <- double(length = nrow(data))
}
model_frame <- model.frame(lme4:::getFixedFormula(formula), data)
model_response <- model.response(model_frame)
X <- model_frame[, -1, drop = FALSE]
# response_type = attr(response, 'type')
#
# if(response_type == "right"){
#
#   time_stop = response[,"time"]
#   time_start = rep(0, length(time_stop))
#   stat = response[,'status']
#
# } else if(response_type == "counting") {
#
#   time_start = response[,"start"]
#   time_stop = response[,"stop"]
#   stat = response[,"status"]
#
# } else {
#
#   stop("response type is not supported")
#
# }
lp_random_effects <- list()
if(length(barnames)) {
data$ytemp <- 1
formula <- update(formula, ytemp ~ .)
parsed_data <- lme4::lFormula(formula, data = data)
data <- dplyr::select(data, -ytemp)
# for each random effect term, need to generate the random effect terms, and join them to the data.
# if terms don't exist in the data, they will be in flist.
re_terms <- names(parsed_data$reTrms$cnms)
names(re_terms) <- re_terms
if(length(re_terms) != length(random_effect_variance))
stop("I need one variance for each random effect term. Note that (1 | M1/M2) breaks down into M1, M2 and M1:M2")
# save the seed. It will be restored after this.
lp_random_effects_list <- lapply(re_terms, function(re){
re_factor <- parsed_data$reTrms$flist[[re]]
group_counts <- table(re_factor)
# set a seed
# if(!is.null(random_effect_seed)) set.seed(random_effect_seed[[re]])
b <- rnorm(length(group_counts), mean = 0, sd = sqrt(random_effect_variance[[re]]))
b_rep <- dplyr::left_join(data.frame(re_name = re_factor),
data.frame(re_name = names(group_counts), re = b), by = "re_name")
# This is the random effect repeated for each observation
re <- b_rep$re
# this is the unique random effects
names(b) <- names(group_counts)
attr(re, "random_effects") <- b
re
})
lp_random_effects <- Reduce("cbind", lp_random_effects_list)
random_effects <- lapply(lp_random_effects_list, attr, "random_effects")
# reset randomness
# set.seed(arbitraty_seed)
} else {
random_effects <- NULL
}
# transpose non-zero length coefficients
if(length(coefficients))
coefficients <- t(coefficients)
risk_score_parts_list <- list(fixed = tcrossprod(as.matrix(data[, fixed_term_variables]), coefficients),
random = lp_random_effects)
risk_score_parts_list <- risk_score_parts_list[lapply(risk_score_parts_list, length)>0]
risk_score_parts_matrix <- Reduce(cbind, risk_score_parts_list)
if(!is.null(risk_score_parts_matrix)) {
risk_score <- .rowSums(risk_score_parts_matrix,
m = nrow(risk_score_parts_matrix), n = ncol(risk_score_parts_matrix))
} else {
risk_score <- rep(0, length(error))
data <- data.frame(stat_time = numeric(length(error)))
}
# this is the old way.
# vars_df$stat_time <- exp(-risk_score) * error
# instead
# this wont work generally.
# there are four scenarios:
# no changes in covariates
# no one event
# no changes in covariates,
# multiple events
# changes in covariates,
# one event
# changes in covariates,
# multiple events
# make the time accounting consistent. so always time_start and time_stop.
response_type = attr(model_response, 'type')
if(response_type == "right"){
# time_stop = response[,"time"]
# time_start = rep(0, length(time_stop))
# stat = response[,'status']
} else if(response_type == "counting") {
# time_start = response[,"start"]
# time_stop = response[,"stop"]
# stat = response[,"status"]
} else {
stop("response type is not supported")
}
# probably need a better solution for id. coerce from what ever it is to
# integer, with a way to get the original ids mapped back to the result
d_list <- C_draw_event_times(id = as.integer(my_data[,idx]),
start_time = as.double(data[,Surv_vars[1]]),
end_time = as.double(data[,Surv_vars[2]]),
status = as.integer(data[,Surv_vars[3]]),
X = as.matrix(X),
risk_score = risk_score,
baseline_hazard = baseline_hazard,
baseline_hazard_start = t,
origin = origin,
single = as.integer(event == "single"))
data_with_events <- data.frame(d_list[[1]],
d_list[[5]])
names(data_with_events) <- c(idx, colnames(X))
data_with_events[Surv_vars[1]] <- d_list[[2]]
data_with_events[Surv_vars[2]] <- d_list[[3]]
data_with_events[Surv_vars[3]] <- d_list[[4]]
# lets see where we're at at this point.
return(data_with_events)
}
# debugonce(draw_event_times)
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t = 0 , origin = 0, id = id, event = "single")
draw_event_times(survival::Surv(t_start, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t = 0 , origin = 0, id = id, event = "single")
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.01, t = 0 , origin = 0, id = id, event = "recurrent")
draw_event_times <- function(formula, data, coefficients = c(), random_effect_variance = list(), id,
baseline_hazard = 1, t = 0, event = c("single", "recurrent"),
origin = 0, end_of_follow_up = NULL) {
Call <- match.call()
event <- match.arg(event)
Call_id <- Call[["id"]]
if (is.null(Call_id)){
stop("id required")
} else if (is.name(Call_id)) {
idx <- as.character(Call_id)
}
fixed_terms <- stats::terms(lme4::nobars(formula))
# These are the fixed term variables in the formula, even if there are interactions.
fixed_term_variables <- colnames(attr(fixed_terms, "factors"))
bars = lme4::findbars(formula)
barnames = lme4:::barnames(bars)
random_terms = terms(as.formula(paste("~", paste(c(1, barnames), collapse = "+"))))
random_term_variables <- rownames(attr(random_terms, "factors"))
variables <- c(fixed_term_variables, random_term_variables)
if(attr(fixed_terms, "response") == 0) stop("formula must have a Surv response")
# strata
# find the strata spec in the form.
# make sure there is a baseline hazard for each stratum
# clustering. dont allow a cluster() call in the formula. instead ask for (1|cluster_id).
# Or allow it and covert it.
# will need an associated random effect.
# cluster in the sandwich means that the variances are cluster-specific. need to allow input of variance structure?
# data will have start and stop times, as specified, but only if there is time-varying covariates.
# otherwise there wont be times.
# and there wont be a stat variable.
Surv_Call <- Call$formula[[2]]
# get time names out of the Call.
# cant use the attribute, because the data need the variables in the call before calling model.frame.
# but I'll use the length of the Surv_call instead. This will probably break if anything but one or two times
# are passed to Surv. Maybe I need to evaluate Surv? Nope. need the vars first.
# Surv_evaluated <- eval(Surv_Call)
# if(attr(model_response, "type") == "counting"){
if(length(Surv_Call) == 4){
start_name <- Surv_Call[[2]]
stop_name <- Surv_Call[[3]]
status_name <- Surv_Call[[4]]
Surv_vars <- c(start_name, stop_name, status_name)
# } else if(attr(model_response, "type") == "right"){
} else if(length(Surv_Call) == 3) {
start_name <- "origin"
stop_name <- Surv_Call[[2]]    # actually called time, not stop
status_name <- Surv_Call[[3]]
if(start_name == stop_name) {stop("You need to call your event times something other than, 'origin'")}
Surv_vars <- c(start_name, stop_name, status_name)
}
# convert Surv_vars from a list of names to a character vector
Surv_vars <- sapply(Surv_vars, as.character)
# check if variables in the Surv() Call are already in the data set.
Surv_vars_in_data <- Surv_vars %in% colnames(data)
# add the ones that aren't
# need a message or warning? Probably not. Just explain in documentation
# message(paste(Surv_vars[Surv_vars_in_data], collapse = ", "), paste(" will be modified"))
if(any(!Surv_vars_in_data)){
data[Surv_vars[!Surv_vars_in_data]] <- double(length = nrow(data))
}
model_frame <- model.frame(lme4:::getFixedFormula(formula), data)
model_response <- model.response(model_frame)
X <- model_frame[, -1, drop = FALSE]
# response_type = attr(response, 'type')
#
# if(response_type == "right"){
#
#   time_stop = response[,"time"]
#   time_start = rep(0, length(time_stop))
#   stat = response[,'status']
#
# } else if(response_type == "counting") {
#
#   time_start = response[,"start"]
#   time_stop = response[,"stop"]
#   stat = response[,"status"]
#
# } else {
#
#   stop("response type is not supported")
#
# }
lp_random_effects <- list()
if(length(barnames)) {
data$ytemp <- 1
formula <- update(formula, ytemp ~ .)
parsed_data <- lme4::lFormula(formula, data = data)
data <- dplyr::select(data, -ytemp)
# for each random effect term, need to generate the random effect terms, and join them to the data.
# if terms don't exist in the data, they will be in flist.
re_terms <- names(parsed_data$reTrms$cnms)
names(re_terms) <- re_terms
if(length(re_terms) != length(random_effect_variance))
stop("I need one variance for each random effect term. Note that (1 | M1/M2) breaks down into M1, M2 and M1:M2")
# save the seed. It will be restored after this.
lp_random_effects_list <- lapply(re_terms, function(re){
re_factor <- parsed_data$reTrms$flist[[re]]
group_counts <- table(re_factor)
# set a seed
# if(!is.null(random_effect_seed)) set.seed(random_effect_seed[[re]])
b <- rnorm(length(group_counts), mean = 0, sd = sqrt(random_effect_variance[[re]]))
b_rep <- dplyr::left_join(data.frame(re_name = re_factor),
data.frame(re_name = names(group_counts), re = b), by = "re_name")
# This is the random effect repeated for each observation
re <- b_rep$re
# this is the unique random effects
names(b) <- names(group_counts)
attr(re, "random_effects") <- b
re
})
lp_random_effects <- Reduce("cbind", lp_random_effects_list)
random_effects <- lapply(lp_random_effects_list, attr, "random_effects")
# reset randomness
# set.seed(arbitraty_seed)
} else {
random_effects <- NULL
}
# transpose non-zero length coefficients
if(length(coefficients))
coefficients <- t(coefficients)
risk_score_parts_list <- list(fixed = tcrossprod(as.matrix(data[, fixed_term_variables]), coefficients),
random = lp_random_effects)
risk_score_parts_list <- risk_score_parts_list[lapply(risk_score_parts_list, length)>0]
risk_score_parts_matrix <- Reduce(cbind, risk_score_parts_list)
if(!is.null(risk_score_parts_matrix)) {
risk_score <- .rowSums(risk_score_parts_matrix,
m = nrow(risk_score_parts_matrix), n = ncol(risk_score_parts_matrix))
} else {
risk_score <- rep(0, length(error))
data <- data.frame(stat_time = numeric(length(error)))
}
# this is the old way.
# vars_df$stat_time <- exp(-risk_score) * error
# instead
# this wont work generally.
# there are four scenarios:
# no changes in covariates
# no one event
# no changes in covariates,
# multiple events
# changes in covariates,
# one event
# changes in covariates,
# multiple events
# make the time accounting consistent. so always time_start and time_stop.
response_type = attr(model_response, 'type')
if(response_type == "right"){
# time_stop = response[,"time"]
# time_start = rep(0, length(time_stop))
# stat = response[,'status']
} else if(response_type == "counting") {
# time_start = response[,"start"]
# time_stop = response[,"stop"]
# stat = response[,"status"]
} else {
stop("response type is not supported")
}
# probably need a better solution for id. coerce from what ever it is to
# integer, with a way to get the original ids mapped back to the result
d_list <- C_draw_event_times(id = as.integer(my_data[,idx]),
start_time = as.double(data[,Surv_vars[1]]),
end_time = as.double(data[,Surv_vars[2]]),
status = as.integer(data[,Surv_vars[3]]),
X = as.matrix(X),
risk_score = risk_score,
baseline_hazard = baseline_hazard,
baseline_hazard_start = t,
origin = origin,
single = as.integer(event == "single"))
data_with_events <- data.frame(d_list[[1]],
d_list[[5]])
names(data_with_events) <- c(idx, colnames(X))
data_with_events[Surv_vars[1]] <- d_list[[2]]
data_with_events[Surv_vars[2]] <- d_list[[3]]
data_with_events[Surv_vars[3]] <- d_list[[4]]
# lets see where we're at at this point.
return(data_with_events)
}
# debugonce(draw_event_times)
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t = 0 , origin = 0, id = id, event = "single")
draw_event_times(survival::Surv(t_start, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.5, t = 0 , origin = 0, id = id, event = "single")
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.01, t = 0 , origin = 0, id = id, event = "recurrent")
draw_event_times(survival::Surv(t_start, t_end, stat) ~ X1 + X2, data = my_data, coefficients = c(X1 = 1.1, X2 = 0.5),
baseline_hazard = 0.01, t = 0 , origin = 0, id = id, event = "recurrent")
