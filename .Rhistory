summary(fit)
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "df"), data = ds)
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "aic"), data = ds)
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "aic"), data = ds)
fit2 <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
str(fit)
summary(fit)
fit$history
fit$history$theta
fit$history$`frailty(M, distribution = "gaussian", method = "aic")`$theta
sqrt(fit$history$`frailty(M, distribution = "gaussian", method = "aic")`$theta)
fit$frail
var(fit$frail)
fit$fvar
mean(fit$fvar)
sqrt(mean(fit$fvar))
fit$var2
summarise(fit)
summary(fit)
str(fit)
grep("0.987709", "blah0.9877098blah")
grep("0.987709", fit)
fit[17]
0.9877098^2
summary(fit)
fit[17]
fit[[17]]
fit[[17]][[3]]
fit[[17]][3]
fit[[17]][1]
fit[[17]][[1]]
fit[[17]][[1]]$history
fit[[17]][[1]]$history["theta"]
class(fit[[17]][[1]]$history)
fit[[17]][[1]][ ,"theta"]
dim(fit[[17]][[1]])
fit[[17]][[1]]
dim(fit[[17]][[1]]$history)
fit[[17]][[1]]$history[, "theta"]
last(fit[[17]][[1]]$history[, "theta"], 1)
last
tail(fit[[17]][[1]]$history[, "theta"], 1)
get_theta <- function(fit){
theta <- tail(fit[[17]][[1]]$history[, "theta"], 1)
theta
}
get_theta(fit)
one_ph_rep <- function(){
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "aic"), data = ds)
}
one_ph_rep()
one_ph_rep <- function(){
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "aic"), data = ds)
get_theta(fit)
}
one_ph_rep()
one_ph_rep()
one_ph_rep()
one_ph_rep()
one_ph_rep()
one_ph_rep()
one_ph_rep()
thetas <- replicate(1000, one_ph_rep())
mean(thetas)
one_ph_rep <- function(){
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
get_theta(fit)
}
thetas <- replicate(1000, one_ph_rep())
mean(thetas)
fit[[17]][[1]]$history
coef(fit)
confint(fit)
sqrt(diag(vcov(coxme_fit)))
sqrt(diag(vcov(fit)))
get_beta_theta <- function(coxph_fit){
coef_est = cbind(coef(coxme_fit), confint(coxme_fit), sqrt(diag(vcov(coxme_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = get_theta(coxph_fit), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
get_beta_theta(fit)
get_beta_theta <- function(coxph_fit){
coef_est = cbind(coef(coxph_fit), confint(coxph_fit), sqrt(diag(vcov(coxph_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = get_theta(coxph_fit), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
get_beta_theta(fit)
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit_me <- try(coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = ds))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
one_ph_rep(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5), ))
one_ph_rep(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
one_ph_rep(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
library(dplyr)
results_filepath <- "/home/bdra011/data/results.rds"
n_reps <- 10
thetas <- c(0.5, 1, 2)
par_combos <- data.frame(
k  = c(   100,  100, 100,  50, 50, 50),
nk = c(     2,    2,   2,   4,  4,  4),
theta = c(0.5,    1,   2, 0.5,  1,  2)
)
par_combo_list <- split(par_combos, seq(nrow(par_combos)))
par_combo_list <- lapply(par_combo_list, function(df){
one_list <- as.list(df)
append(one_list, values = list(beta = c(1, -0.7, 0.5),
max_iter = 10))
})
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
get_theta <- function(fit){
theta <- tail(fit[[17]][[1]]$history[, "theta"], 1)
theta
}
get_beta_theta <- function(coxph_fit){
coef_est = cbind(coef(coxph_fit), confint(coxph_fit), sqrt(diag(vcov(coxph_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = get_theta(coxph_fit), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
one_ph_rep <- function(){
ds <- one_dataset(control = list(k = 50, nk = 4, theta = 0.5, beta = c(1, -0.7, 0.5)))
get_theta(fit)
}
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit_me <- try(coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1|M), data = ds))
fit <- coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
control_list_to_df <- function(control){
tibble::tibble(k = control$k,
nk = control$nk,
theta = control$theta,
param_name = c("beta_1", "beta_2", "beta_3", "theta"),
param_true = c(control$beta, control$theta))
}
stack_results <- function(results) {
stacked_results <- plyr::ldply(results, '[[', "results", .id = NULL)
control_lists <- lapply(results, '[[', "control")
control_dfs <- plyr::ldply(control_lists, control_list_to_df, .id = NULL)
dplyr::bind_cols(control_dfs, stacked_results) %>%
dplyr::as_tibble()
}
#create cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("par_combo_list", "one_dataset", "get_beta_theta", "one_me_rep", "%>%"))
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("par_combo_list", "one_dataset", "get_theta", "get_beta_theta", "one_ph_rep", "%>%"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_me_rep(control = params)
})
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_ph_rep(control = params)
})
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit <- survival::coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_ph_rep(control = params)
})
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("par_combo_list", "one_dataset", "get_theta", "get_beta_theta", "one_ph_rep", "%>%"))
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_ph_rep(control = params)
})
# script to run sims on the ihaka server.
# runs 100000 iterations of something in parallel
# set up control
# file.path on remote machine that holds the fits.
# results_fits_filepath <- "/home/bdra011/data/fits.rds"
# results_fits_filepath <- "C:/Users/Bradley/OneDrive - The University of Auckland/PhD/outputs/simulations/data/fits.rds"
library(dplyr)
results_filepath <- "/home/bdra011/data/results.rds"
n_reps <- 10
thetas <- c(0.5, 1, 2)
par_combos <- data.frame(
k  = c(   100,  100, 100,  50, 50, 50),
nk = c(     2,    2,   2,   4,  4,  4),
theta = c(0.5,    1,   2, 0.5,  1,  2)
)
par_combo_list <- split(par_combos, seq(nrow(par_combos)))
par_combo_list <- lapply(par_combo_list, function(df){
one_list <- as.list(df)
append(one_list, values = list(beta = c(1, -0.7, 0.5),
max_iter = 10))
})
## Below here, no parameters should need changing.
# these are the functions for one simulation rep
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
get_theta <- function(fit){
theta <- tail(fit[[17]][[1]]$history[, "theta"], 1)
theta
}
get_beta_theta <- function(coxph_fit){
coef_est = cbind(coef(coxph_fit), confint(coxph_fit), sqrt(diag(vcov(coxph_fit))))  %>%
as.data.frame()
names(coef_est) <- c("param_est", "lower", "upper", "se")
theta_est = data.frame(param_est = get_theta(coxph_fit), lower = NA, upper = NA, se = NA)
dplyr::bind_rows(coef_est, theta_est)
}
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit <- survival::coxph(Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
one_ph_rep(par_combo_list[[1]])
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3 + frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
one_ph_rep(par_combo_list[[1]])
one_ph_rep <- function(control){
fit_class <- " "
iter <- 1
# check parameters
if(!all(c("k", "nk", "beta", "theta") %in% names(control))) {
stop("I don't have the parameters I need")
}
ds <- one_dataset(control = control)
fit <- survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3 + survival::frailty(M, distribution = "gaussian", method = "reml"), data = ds)
list(control = control,
results = get_beta_theta(fit))
}
one_ph_rep(par_combo_list[[1]])
control_list_to_df <- function(control){
tibble::tibble(k = control$k,
nk = control$nk,
theta = control$theta,
param_name = c("beta_1", "beta_2", "beta_3", "theta"),
param_true = c(control$beta, control$theta))
}
stack_results <- function(results) {
stacked_results <- plyr::ldply(results, '[[', "results", .id = NULL)
control_lists <- lapply(results, '[[', "control")
control_dfs <- plyr::ldply(control_lists, control_list_to_df, .id = NULL)
dplyr::bind_cols(control_dfs, stacked_results) %>%
dplyr::as_tibble()
}
#create cluster
cl <- parallel::makeCluster(parallel::detectCores()-1)
# put objects in place that might be needed for the code
parallel::clusterExport(cl, c("par_combo_list", "one_dataset", "get_theta", "get_beta_theta", "one_ph_rep", "%>%"))
# Set a different seed on each member of the cluster (just in case)
parallel::clusterSetRNGStream(cl)
fits <- parallel::parLapply(cl, rep(par_combo_list, each = n_reps), function(params) {
one_ph_rep(control = params)
})
#stop the cluster
parallel::stopCluster(cl)
fits_df <- stack_results(fits)
# summary of the results
summarised_results <- fits_df %>%
dplyr::group_by(k, nk, theta, param_name) %>%
dplyr::mutate(is_hit = (param_true >= lower) & (param_true <= upper)) %>%
dplyr::summarise(true_value = first(param_true),
mean = mean(param_est),
estimated_se = mean(se, na.rm = TRUE),
empirical_se = sqrt(var(param_est)),
hits = mean(is_hit) * 100, .groups = "drop")
summarised_results
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = c(1, -0.7, 0.5), theta = 1))
sample_data
source("~/.active-rstudio-document")
devtools::load_all(".")
sortAndIndex
d1 <- sortAndIndex(sample_data)
d1 <- sortAndIndex(sample_data, t)
d1
X <-
calcLinearPredictor
one_dataset <- function(control) {
n = control$k*control$nk
M = rep(1:control$k, each = control$nk)
X1 = rnorm(n, 0, 1)
X2 = rep(rnorm(control$k, 0, 1), each = control$nk)
# cluster level binary treatment allocation
X3 = rep(rep(c(1, 0), ceiling(control$k/2))[1:control$k], each = control$nk)
X = cbind(X1, X2, X3)
b = rep(rnorm(control$k, 0, sqrt(control$theta)), each = control$nk)
error = rexp(n, 10)
t = exp(-X%*%control$beta - b) * error
stat =  sample(rep(c(0, 1), round(n*c(0.2, 0.8))), n)
data.frame(X, t, stat, M)
}
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = c(1, -0.7, 0.5), theta = 1))
install.packages("learnr")
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = c(1, -0.7, 0.5), theta = 1))
devtools::load_all(".")
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = c(1, -0.7, 0.5), theta = 1))
d1 <- dplyr::bind_cols(sample_data, data.frame(Z))
sample_data
my_beta = c(1, -0.7, 0.5)
my_theta = 1
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = my_beta, theta = my_theta))
my_beta = c(1, -0.7, 0.5)
my_theta = 1
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = my_beta, theta = my_theta))
my_parms <- c(my_beta, b <- attr(sample_data, "random_effects"))
D = my_theta * diag(b)
D = my_theta * diag(length(b))
Z <- model.frame(~ M - 1, data = sample_data)
Z
Z <- model.frame(~ as.factor(M) - 1, data = sample_data)
Z
sample_data <- one_dataset(control = list(k = 50, nk = 4, beta = my_beta, theta = my_theta))
my_parms <- c(my_beta, b <- attr(sample_data, "random_effects"))
D = my_theta * diag(length(b))
Z_matrix <- model.matrix( ~ as.factor(M) - 1, data = data)
Z_matrix <- model.matrix( ~ as.factor(M) - 1, data = sample_data)
colnames(Z_matrix) <- paste0("Z", seq(ncol(Z_matrix)))
data_with_Z <- dplyr::bind_cols(sample_data, data.frame(Z_matrix))
d2 <- sortAndIndex(data_with_Z, t)
d3 <- calcLinearPredictor(data = d2, X = c("X1", "X2", "X3"), Z = colnames(Z), parms = myParms)
d3 <- calcLinearPredictor(data = d2, X = c("X1", "X2", "X3"), Z = colnames(Z_matrix), parms = myParms)
d3 <- calcLinearPredictor(data = d2, X = c("X1", "X2", "X3"), Z = colnames(Z_matrix), parms = my_parms)
d3
exp(3.5)
exp(3.5299593)
exp(-0.3431188)
d4 <- calcRiskSets(d3)
d4
sum(d4$A)
b
b%*%D%*%b
lp <- function(parms, X, t, cluster, dij, D, data) {
Z_matrix <- model.matrix( ~ as.factor(M) - 1, data = data)
colnames(Z_matrix) <- paste0("Z", seq(ncol(Z_matrix)))
data_with_Z <- dplyr::bind_cols(data, data.frame(Z_matrix))
b <- parms[-seq_len(length.out = length(X))]
penalty <- data |>
dplyr::distinct({{ cluster }}) |>
dplyr::mutate(
theta_inverse = diag(solve(D)),
penalty = dplyr::all_of(b)^2 * theta_inverse
) |>
dplyr::summarise(penalty = 0.5 * sum(penalty)) |>
dplyr::pull(penalty)
sortedIndexedData <- sortAndIndex(data_with_Z, {{ t }})
terms1 <- calcLinearPredictor(sortedIndexedData, X = X, Z = colnames(Z_matrix), parms = parms)
terms2 <- calcRiskSets(terms1)
ll <- terms2 |>
dplyr::mutate(li =  {{ dij }} * (lp - log(cumsum_A))) |>
dplyr::summarise(ll = sum(li)) |>
dplyr::pull(ll)
ppl <- ll - penalty
attr(ppl, "penalty") <- penalty
ppl
}
lp(myParms, X = c("X1", "X2", "X3"), t = t, cluster = M, dij = stat, D = D, data = sample_data)
lp(my_parms, X = c("X1", "X2", "X3"), t = t, cluster = M, dij = stat, D = D, data = sample_data)
lp(my_parms, X = c("X1", "X2", "X3"), t = t, cluster = M, dij = stat, D = D, data = sample_data)
b%*%D%*%b
0.5 * b%*%D%*%b
fit_coxph <-
tryCatch(
survival::coxph(survival::Surv(t, stat) ~ X1 + X2 + X3 +
survival::frailty(M,
distribution = "gaussian",
method = "reml"),
control = survival::coxph.control(iter.max = 5000,
outer.max = 20,
timefix = FALSE),
data = sample_data),
warning = function(w) w,
error = function(e) e)
fit_coxph$penalty
fit_coxph$penalty
coxme::coxme(Surv(t, stat) ~ X1 + X2 + X3 + (1 | M), data = sample_data)
coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1 | M), data = sample_data)
fit_coxme <- coxme::coxme(survival::Surv(t, stat) ~ X1 + X2 + X3 + (1 | M), data = sample_data)
fit_coxme$penalty
0.5 * b%*%D%*%b
names(fit_coxme)
loglik(fit_coxme)
logLik(fit_coxme)
fit_coxme$loglik
0.5 * b%*%D%*%b
0.5 * D%*%b
0.5 * b%*%D
sum(0.5 * b%*%D)
library(coxme)
fixef(fit_coxme)
ranef(fit_coxme)
ranef(fit_coxme)$M
VarCorr(fit_coxme)
VarCorr(fit_coxme)$M
b_fit <- ranef(fit_coxme)$M
theta_fit <- VarCorr(fit_coxme)$M
diag(length(b_fit))
D_theta_fit <- theta_fit * diag(length(b_fit))
b_fit <- ranef(fit_coxme)$M
theta_fit <- VarCorr(fit_coxme)$M
b_fit %*% D_theta_fit %*% b_fit
0.5 * b_fit %*% D_theta_fit %*% b_fit
fit_coxme$penalty
fit_coxme$u
fit_coxme$loglik
str(fit_coxme$loglik)
fit_coxme$loglik[2] - fit_coxme$loglik[3]
c(fixef(fit_coxme), ranef(fit_coxme))
lp(c(fixef(fit_coxme), ranef(fit_coxme)),
X = c("X1", "X2", "X3"), t = t, cluster = M, dij = stat, D = D, data = sample_data)
ranef(fit_coxme)$M
lp(c(fixef(fit_coxme), ranef(fit_coxme)$M),
X = c("X1", "X2", "X3"), t = t, cluster = M, dij = stat, D = D, data = sample_data)
lp(c(fixef(fit_coxme), ranef(fit_coxme)$M),
X = c("X1", "X2", "X3"), t = t, cluster = M, dij = stat, D = D, data = sample_data)
fit_coxme$penalty
fit_coxme$frail
fit_coxme$control
str(fit_coxme)
lp(c(fixef(fit_coxme), ranef(fit_coxme)$M),
X = c("X1", "X2", "X3"), t = t, cluster = M, dij = stat, D = D, data = sample_data)
D_theta_fit
lp(c(fixef(fit_coxme), ranef(fit_coxme)$M),
X = c("X1", "X2", "X3"), t = t, cluster = M, dij = stat, D = D_theta_fit, data = sample_data)
coxme$loglik
fit_coxme$loglik
fit_coxme$penalty
